<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[春雏集-流动的思绪]]></title>
      <url>%2F2017%2F03%2F05%2F%E6%98%A5%E9%9B%8F%E9%9B%86-%E6%B5%81%E5%8A%A8%E7%9A%84%E6%80%9D%E7%BB%AA%2F</url>
      <content type="text"><![CDATA[&nbsp; &nbsp; &nbsp; &nbsp;所有的思绪被一场大雨冲刷的一干二净，窗花外的朦胧又梦幻般的世界，炫耀了莫名的姿色，五颜六色霓虹如五味杂陈般又塞满了整个空间。 &nbsp; &nbsp; &nbsp; &nbsp;车如流水马如龙，身如浮萍，难定踪迹。安静的车厢，闪烁的车灯，荧屏映衬着冷漠的脸，扶手也冷冷的释放着冷意，窗外的雨越发的朦胧，翻起的水雾遮拢了这个小城。 &nbsp; &nbsp; &nbsp; &nbsp;从繁华到落幕，笔直的大道，到底掩含了多少如流水般如你我般在相似而又落寞的世界里禹禹独行。追寻着光明，却曾未被照耀。但还是，在黑夜中坚持的前进着，心中一直坚定的信念，曾未如此光明过，不断的放大放大，直到思绪飘离了这里，在苍穹之上，默默的俯视着光怪陆离的世界。我看到了街边行乞的流浪人，祈求着每一个路人，只为了一顿三餐；我看到了在公园里哭泣的小女孩，眼中充满的渴望和泪水，只是想得到关爱；我看到了吵架的情侣，相互指责着对方，可是他倆又是那么的相爱；我看到了，我看到了世界，我看到了平常未曾感知到的色彩，生活如此。 &nbsp; &nbsp; &nbsp; &nbsp;“我的心愿的是世界和平！”一句会被嘲笑的话，此刻却是那么有力，那么渴望。相互扮演着让着这个世界运行下去的角色，有时你会生出挫败的无力感，此刻些许能明白些所谓的“看破红尘，遁入空门”这般话语。追心而去，逐念而去，坚守本心。 &nbsp; &nbsp; &nbsp;&nbsp;谁的思绪飞越了尽头，如流水般一去不返。 &nbsp; &nbsp; &nbsp; &nbsp;昨日而去，今日而追。心若有念，不曾有晚。 &nbsp; &nbsp; &nbsp; &nbsp;流动的思绪，翻腾的水雾，220照样在行驶，霓虹照样五味杂陈。每一次行程，如洗礼般，净化污浊，保持自我的纯真和最初的信念。 &nbsp; &nbsp; &nbsp; &nbsp;飘飞的思绪，随着耸动的人流下了车。我在窗外，看了看脚下的流水，却没了在窗内的思绪，笃定了思绪，默默前行。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[javaee上课笔记-Servlet事件监听器]]></title>
      <url>%2F2017%2F03%2F03%2Fjavaee%E4%B8%8A%E8%AF%BE%E7%AC%94%E8%AE%B0-Servlet%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E5%99%A8%2F</url>
      <content type="text"><![CDATA[学习目标 掌握监听器的相关API 掌握监听器域对象中的属性变更 掌握感知被HttpSession绑定的事件监听器 #]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[春雏集：看见花落也凋零]]></title>
      <url>%2F2017%2F03%2F01%2F%E6%98%A5%E9%9B%8F%E9%9B%86%EF%BC%9A%E7%9C%8B%E8%A7%81%E8%8A%B1%E8%90%BD%E4%B9%9F%E5%87%8B%E9%9B%B6%2F</url>
      <content type="text"><![CDATA[春雏集：看见花落也凋零 看见花落也凋零。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[javaee上课笔记:DBUtils工具]]></title>
      <url>%2F2017%2F03%2F01%2Fjavaee%E4%B8%8A%E8%AF%BE%E7%AC%94%E8%AE%B0-DBUtils%E5%B7%A5%E5%85%B7%2F</url>
      <content type="text"><![CDATA[javaee上课笔记:DBUtils工具学习目标 了解DBUtils工具中的api 学会使用DBUtils工具对数据库进行增删改查的操作 学会使用DBUtils工具处理事务点我下载DBUtils API介绍核心类 &amp; 接口 类 org.apache.commons.dbutils.DbUtils org.apache.commons.dbutils.QueryRunner 接口 org.apache.commons.dbutils.ResultSetHandler DBUtils 类 DBUtils类 主要为如何关闭，装载JDBC驱动程序之类的常规工作提供方法，它提供的方法都是静态方法， 1.close() 方法关闭数据库连接 2.closeQuietly(Connection con,Statement stmt,ResultSet rs) 方法该方法用来关闭Connection，Statement和ResultSet对象。还会隐藏一些在程序中抛出的sql异常 3.commitAndCloseQuiely(Connection con)该方法用来提交连接，然后关闭连接， 且在关闭时不抛出sql异常 4.LoadDrive（java.lang.String driverClassName）该方法用于装载jdbc驱动程序，如果成功返回true。使用时，不需要捕捉ClassNotFoundException异常 QueryRunner 类该类简化了执行sql语句的代码，它与ResultSetHandler 组合在一起，能完成大部分的数据库操作，大大减少编码量。提供了两个构造方法：1.默认的构造方法2.需要javax.sql.DataSource 作为参数 1.query(Connection conn,String sql,ResultSetHandler rsh,Object[] params) 方法该方法用于执行查询操作参数params表示一个对象数组，该数组中每个元素都被用来作为查询语句的置换参数注意：该方法会自动处理PrepareSatement 和 ResultSet的创建和关闭 2.query(String sql,ResultSetHandler rsh,Object[] params)方法该方法用于执行查询操作，与第一个方法相比它不需要传递Connection对象给方法，它可以从提供给构造方法的数据源DateSource或使用setDateSource()中获得连接。 3.query(Connection conn，String sql,ResultSetHandler rsh)方法该方法用于执一个不需要置换参数的查询操作 4.update(Connection conn，String sql,Object[] params)方法该方法用来执行插入、更新或者删除操作，其中，参数params 表示SQL语句中的置换参数。 5.update(Connection conn,String sql) 方法该方法用于执行插入、更新或者删操作，它需要置换参数操作。 ## ResultSetHandler 接口 该接口用于处理ResultSet结果集，它可以将结果集中的数据转化为不同的形式。根据结果集中数据类型的不同，ResultHandler提供了不同的实现类。如下： 1.AbstractKeyedHandler:该类为抽象类，能够把结果集里面的数据转换为用Map存储。 2.AbstractListHandler：该类为抽象类，—如上—-转换为用List存储。 3.ArrayHandler：把结果集中的第一行数据转成数据对象数组 4.ArrayListHandler：把结果集中的每一行数据转成一个对象数组，再将数组存放到List中。 5.BaseResultSetHandler：把结果集转换成其他对象的扩展。 6.BeanHandler :将结果集中的第一行数据封到一个对应的JavaBean实例中。 7.BeanListHandler：将结果集中的每一行数据都封装到一个对应的 JavaBean实例中，存放到list中 8.BeanMapHandler：结果集中的每一行数据都封装到一个对应的 JavaBean实例中，然后在根据指定的key把每个JavaBean在存放到一个Map里 9.ColumnListHandler：将结果集中某一列的数据存放到List中 10.将结果集中的每一行数据封装到一个map里，然后在根据指定的key把每个MAp在存放到一个map里。 11.MapHandler：将结集中的每一行数据封装到一个map里。可以是列名，value是对应的值。 12.MapListHandler：将结果集中的每一行数据封装到一个Map中，然后在存放到list中 13.ScalarHandler：将结果集中的某一条记录的其中某一列的数据存储成Object对象 另外，在ResultSetHandler接口中，提供了一个单独的方法handle（java.sql.ResultSet rs）,如果上述实现类没有提供想要的功能，可以通过自定义一个实现ResultSetHandler接口的类，然后重写handel()方法，实现结果集的处理。 代码实现ArrayHandler 和 ArrayListHandler 12345678public static void testArrayHandler() throws SQLException&#123; BaseDao beseDao = new BaseDao(); String sql = &quot;select * from NEWSINFO where nid=?&quot;; Object[] arr = (Object[]) BaseDao.query(sql, new ArrayHandler(), new Object[]&#123;50&#125;); for(int i=0;i&lt;arr.length;i++)&#123; System.out.println(arr[i]+&quot;,&quot;); &#125; 实现步骤 1.创建QueryRunner对象 （配置了C3p0数据池，参数获取数据源） QueryRunner runner = new QueryRunner（C3p0Utils.getDateSource（）） 2.编写Sql语句 String sql = &quot;&quot; 3.调用QueryRunner中的方法 runner.query() runner.update() 参数参考上面 DBUtils 处理事务 创建JDBCUtils,该类封装了创建连接，开启事务，关闭事务等方法 需要注意的是，请求中的一个事务涉及到了多个数据库操作，如果这些Connection是 从连接池中获取的，两个DAO操作就用到了两个Connection，这样是没办法完成一个事务的， 所以，需要借助ThreadLoacl类。 ThreadLoacl类的作用是在一个线程里记录变量。可以生成一个连接放在这个线程中， 只要是这个线程中的任何对象都可以共享这个连接，当线程结束后就删除这个连接，这样， 就保证了一个事务，一个连接。直接上代码:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package party.lvc.jdbc.utils;import java.sql.Connection;import java.sql.SQLException;import javax.sql.DataSource;import com.mchange.v2.c3p0.ComboPooledDataSource;public class JDBCUtils &#123; // 创建一个ThreadLocal 对象，以当前线程作为key private static ThreadLocal&lt;Connection&gt; threadLocal = new ThreadLocal&lt;Connection&gt;(); // 从c3p0-config.xml配置文件中读取默认的数据库配置，生成c3p0数据源 private static DataSource ds = new ComboPooledDataSource(); // 返回数据源对象 public static DataSource getDataSource() &#123; return ds; &#125; // 获取c3p0数据库连接池中的连接对象 public static Connection getConnection() throws SQLException &#123; Connection conn = threadLocal.get(); if (conn == null) &#123; conn = ds.getConnection(); threadLocal.set(conn); &#125; return conn; &#125; // 开启事务 public static void startTransaction() &#123; try &#123; // 获得链接 Connection conn = getConnection(); // 开启事务 conn.setAutoCommit(false); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; // 提交事务 public static void commit() &#123; try &#123; // 获得链接 Connection conn = threadLocal.get(); // 提交事务 if (conn != null) conn.commit(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; // 回滚事务 public static void rollback() &#123; try &#123; // 获得链接 Connection conn = threadLocal.get(); // 回滚事务 if (conn != null) conn.rollback(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; // 关闭数据库连接，释放资源 public static void close() &#123; // 获得链接 Connection conn = threadLocal.get(); // 关闭事务 if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; // 从集合中移除当前绑定的连接 threadLocal.remove(); conn = null; &#125; &#125; &#125;&#125; 事务的实现。通过银行转账业务，来举个栗子。创建Business，该类包括了转账过程的逻辑方法。1234567891011121314151617181920212223242526272829303132333435363738394041package party.lvc.example;import java.sql.SQLException;import cn.itcast.jdbc.example.dao.AccountDao;import cn.itcast.jdbc.example.domain.Account;import cn.itcast.jdbc.utils.JDBCUtils;public class Business &#123; public static void transfer(String sourceAccountName, String toAccountName, float money) &#123; try &#123; // 开启事务 JDBCUtils.startTransaction(); // 根据用户名查询数据并存入实体类对象中 AccountDao dao = new AccountDao(); Account accountfrom = dao.find(sourceAccountName); Account accountto = dao.find(toAccountName); // 完成转账操作 if(money&lt;accountfrom.getMoney())&#123; accountfrom.setMoney(accountfrom.getMoney()-money); &#125;else&#123; System.out.println(&quot;转出账户余额不足&quot;); &#125; accountto.setMoney(accountto.getMoney()+money); dao.update(accountfrom); dao.update(accountto); // 提交事务 JDBCUtils.commit(); System.out.println(&quot;提交成功&quot;); &#125; catch (SQLException e) &#123; System.out.println(&quot;提交失败&quot;); JDBCUtils.rollback(); e.printStackTrace(); &#125; finally &#123; // 关闭事务 JDBCUtils.close(); &#125; &#125; public static void main(String[] args) throws SQLException &#123; // 调用方法，实现a向b转账200元操作 transfer(&quot;a&quot;, &quot;b&quot;, 200); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android上课笔记-快速入门]]></title>
      <url>%2F2017%2F02%2F25%2FAndroid%E4%B8%8A%E8%AF%BE%E7%AC%94%E8%AE%B0-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%2F</url>
      <content type="text"><![CDATA[Android项目的目录结构 Activity：应用被打开时显示的界面 src：项目代码 R.java：项目中所有资源文件的资源id Android.jar：Android的jar包，导入此包方可使用Android的api libs：导入第三方jar包 assets：存放资源文件，比方说mp3、视频文件 bin：存放编译打包后的文件 res：存放资源文件，存放在此文件夹下的所有资源文件都会生成资源id drawable：存放图片资源 layout：存放布局文件，把布局文件通过资源id指定给activity，界面就会显示出该布局文件定义的布局 menu：定义菜单的样式 Strings.xml：存放字符串资源，每个资源都会有一个资源id Android的配置文件（清单文件） 指定应用的包名 package=”com.itheima.helloworld”data/data/com.itheima.helloworld(上面代码指定的包名)应用生成的文件都会存放在此路径下 Android的四大组件在使用前全部需要在清单文件中配置 的配置对整个应用生效 的配置对该activity生效DDMS Dalvik debug monitor service Dalvik调试监控服务 常用的adb指令Android debug bridge：安卓调试桥 adb start-server:启动adb进程 adb kill-server：杀死adb进程 adb devices：查看当前与开发环境连接的设备，此命令也可以启动adb进程 adb install XXX.apk：往模拟器安装apk adb uninstall 包名：删除模拟器中的应用 adb shell:进入linux命令行 ps：查看运行进程 ls：查看当前目录下的文件结构 netstat -ano：查看占用端口的进程电话拨号器 功能：用户输入一个号码，点击拨打按钮，启动系统打电话的应用把号码拨打出去 1. 定义布局 组件必须设置宽高，否则不能通过编译 12android:layout_width=&quot;wrap_content&quot;android:layout_height=&quot;wrap_content&quot; 如果要在java代码中操作某个组件，则组件需要设置id，这样才能在代码中通过id拿到这个组件 android:id=&quot;@+id/et_phone&quot; 2. 给按钮设置点击侦听 给按钮设置侦听1234 //通过id拿到按钮对象Button bt_call = (Button) findViewById(R.id.bt_call);//给按钮设置点击bt_call.setOnClickListener(new MyListener()); 3. 得到用户输入的号码123//得到用户输入的号码，先拿到输入框组件EditText et_phone = (EditText) findViewById(R.id.et_phone);String phone = et_phone.getText().toString(); 4. 把号码打出去 Android系统中基于动作机制，来调用系统的应用，你告诉系统你想做什么动作，系统就会把能做这个动作的应用给你，如果没有这个应用，会抛异常 设置动作，通过意图告知系统12345678//把号码打出去 //先创建一个意图对象 Intent intent = new Intent(); //设置动作，打电话 intent.setAction(Intent.ACTION_CALL); intent.setData(Uri.parse(&quot;tel:&quot; + phone)); //把意图告诉系统 startActivity(intent); 添加权限 &lt;uses-permission android:name=&quot;android.permission.CALL_PHONE&quot;/&gt; 点击事件的四种写法第一种 定义一个MyListener实现onClickListener接口 12Button bt1 = (Button) findViewById(R.id.bt1);bt1.setOnClickListener(new MyListener()); 第二种 定义一个匿名内部类实现onClickListener接口 123456789Button bt2 = (Button) findViewById(R.id.bt2);bt2.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; System.out.println(&quot;第二种&quot;); &#125;&#125;); 第三种 让当前activity实现onClickListener接口 12Button bt3 = (Button) findViewById(R.id.bt3);bt3.setOnClickListener(this); 第四种 给Button节点设置onClick属性， android:onClick=&quot;click&quot; 然后在activity中定义跟该属性值同名的方法 123public void click(View v)&#123; System.out.println(&quot;第四种&quot;);&#125; 短信发送器 功能：用户输入号码和短信内容，点击发送按钮，调用短信api把短信发送给指定号码 1. 定义布局 输入框的提示android:hint=&quot;请输入号码&quot; 2. 完成点击事件 先给Button组件设置onClick属性onClick=&quot;send&quot; 在Activity中定义此方法public void send(View v){} 3. 获取到用户输入的号码和内容1234EditText et_phone = (EditText) findViewById(R.id.et_phone);EditText et_content = (EditText) findViewById(R.id.et_content);String phone = et_phone.getText().toString();String content = et_content.getText().toString(); 4. 调用发送短信的api12345//调用发送短信的apiSmsManager sm = SmsManager.getDefault();//发送短信sm.sendTextMessage(phone, null, content, null, null); 添加权限 1&lt;uses-permission android:name=&quot;android.permission.SEND_SMS&quot;/&gt; 如果短信过长，需要拆分List&lt;String&gt; smss = sm.divideMessage(content);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[android笔记-Drawable]]></title>
      <url>%2F2017%2F02%2F24%2Fandroid%E7%AC%94%E8%AE%B0-Drawable%2F</url>
      <content type="text"><![CDATA[Android 的 Drawable Drawable 表示的是一中可以在Canvas上进行绘制的抽象概念，它的种类很多，最常见的颜色和 图片度可以是一个Drawable。 Drawable一般都是通过XML定义的，也可以使用代码来创建。 Drawable的分类BitmapDrawable 几乎是是最简单的Drawable，它就是表示一张图片。 xml文件， 属性123456789android:antialias 抗锯齿 android:dither 抖动效果 android:filter 过滤效果android:gravity 对图片进行定位，当图片小于容器时。android:mipMap android:src android:tileMode 平铺模式 disabled 、clamp、reapt 、mirrorandroid:tileModeXandroid:tileModeY ShapeDrawable 形状的Drawable咯,定义基本的几何图形,如(矩形,圆形,线条等),根元素是 节点比较多，相关的节点如下： ① shape: ~ visible:设置是否可见 ~ shape:形状,可选:rectangle(矩形,包括正方形),oval(椭圆,包括圆),line(线段),ring(环形) ~ innerRadiusRatio:当shape为ring才有效,表示环内半径所占半径的比率,如果设置了innerRadius, 他会被忽略 ~ innerRadius:当shape为ring才有效,表示环的内半径的尺寸 ~ thicknessRatio:当shape为ring才有效,表环厚度占半径的比率 ~ thickness:当shape为ring才有效,表示环的厚度,即外半径与内半径的差 ~ useLevel:当shape为ring才有效,表示是否允许根据level来显示环的一部分 ② size ~ width:图形形状宽度 ~ height:图形形状高度 ③ &lt;gradient 》 后面GradientDrawable再讲~ ④ solid ~ color:背景填充色,设置solid后会覆盖gradient设置的所有效果!!!!!! ⑤ stroke ~ width:边框的宽度 ~ color:边框的颜色 ~ dashWidth:边框虚线段的长度 ~ dashGap:边框的虚线段的间距 ⑥ conner ~ radius:圆角半径,适用于上下左右四个角 ~ topLeftRadius,topRightRadius,BottomLeftRadius,tBottomRightRadius: 依次是左上,右上,左下,右下的圆角值,按自己需要设置! ⑦ padding left,top,right,bottm:依次是左上右下方向上的边距! LayerDrawableStateListDrawable属性： drawable:引用的Drawable位图,我们可以把他放到最前面,就表示组件的正常状态~ state_focused:是否获得焦点 state_window_focused:是否获得窗口焦点 state_enabled:控件是否可用 state_checkable:控件可否被勾选,eg:checkbox state_checked:控件是否被勾选 state_selected:控件是否被选择,针对有滚轮的情况 state_pressed:控件是否被按下 state_active:控件是否处于活动状态,eg:slidingTab state_single:控件包含多个子控件时,确定是否只显示一个子控件 state_first:控件包含多个子控件时,确定第一个子控件是否处于显示状态 state_middle:控件包含多个子控件时,确定中间一个子控件是否处于显示状态 state_last:控件包含多个子控件时,确定最后一个子控件是否处于显示状态 LeveListDrawableTransitionDrawablwInsetDrawableScaleDrawableclipDrawable自定义Drawable]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[春雏集:优雅的活着]]></title>
      <url>%2F2017%2F02%2F22%2F%E6%98%A5%E9%9B%8F%E9%9B%86-%E4%BC%98%E9%9B%85%E7%9A%84%E6%B4%BB%E7%9D%80%2F</url>
      <content type="text"><![CDATA[春雏集:优雅的活着 我和丽丽有相同的观点就是，优雅的活着 每天一句早安，每天一句晚安，相逢总是思念。 她想优雅的活着，我想优雅的陪她，陪伴每个366天，多一天都是值得。 那一天，在回寝室的路上，抬头看落叶的飘零，不知为何，又想起了优雅的活着，优雅的生活，心中的那个念头，牵扯了感触。 今天给她分享了，李宗盛的《山丘》，她说，看不懂。其实很简单，我想，越过每一个山丘，然后陪你。 越发想念的越是醉人的，迷蒙的夜色神游的我俩。 晚安，亲爱的丽丽!我想陪你，过优雅的日子。 我希望有个如你一般的人如山间清爽的风如古城温暖的光从清晨到夜晚由山野到书房只要最后是你就好 ——张嘉佳 《从你的全世界路过》]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android上课笔记-第一课]]></title>
      <url>%2F2017%2F02%2F20%2FAndroid%E4%B8%8A%E8%AF%BE%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E8%AF%BE%2F</url>
      <content type="text"><![CDATA[Android 简介 通信技术 Android 起源 Android 体系架构 Dalvik 虚拟机Dalvik 包含了一整套的Android运行环境虚拟机，每个app都会分配Dalvik虚拟机来保证相互之间不收干扰，并不保持独立。它的特点是在运行时编译。 ART采用的是安装时就进行编译。 克服瓶颈期的最好办好就是六个字–总结 、归纳、演绎。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[javaweb实战：网上书城]]></title>
      <url>%2F2017%2F02%2F20%2Fjavaweb%E5%AE%9E%E6%88%98%EF%BC%9A%E7%BD%91%E4%B8%8A%E4%B9%A6%E5%9F%8E%2F</url>
      <content type="text"><![CDATA[javawe实战：网上书城 前台项目概述需求分析 1.统一友好的操作界面，具有良好的用户体验。 2.商品分类详尽，可按不同类别查看商品信息。 3.公告栏，本周热卖。 4.网站首页轮播图满足图书广告的需要。 5.用户信息的注册和验证。 6.通过图书名模糊搜索相关商品。 7.通过购物车一次购买多件商品。 8.提供简单的安全模型，用户必须登录后购买商品。 9.用户选择商品后可以在线提交订单。 10.用户可以查看自己的订单信息。 11.设计网站后台，管理网站的各项基本数据. 12.系统运行安全稳定且响应及时。 功能结构 项目预览数据库设计E-R图设计创建数据库和数据表项目前期准备 1.新建一个动态的web项目，名称为BooKStore 2.确定项目运行的环境版本 网上书城项目使用数据库MYSQL5.7版本，Java开发包为1.8 ，开发IDE MyEclipse 2016 3.将本项目所需jar包导入项目的lib文件下。 a.本项目使用c3p0数据源链接数据库，需要c3p0的jar包。 b.项目的jsp页面使用了JSTL标签库，需要jstl.jar和 standard.jar包。 c.项目中使用DBUtils工具处理数据的持久化操作，需要导入BeanUtils工具包。 d.由于在注册时系统还会给注册用户填写的邮箱发送一封激活码，需要导入mail.jar包。 本项目所需jar包如图所示： 4.配置c3p0-config.xml。 在项目Src根目录下创建该文件夹 配置如图所示： 5.编写filter过滤器 a.防止项目请求和响应时出现的乱码情况，需要编写一个过滤器 EcondingFilter.java 来统一全站编码， b.由于本项目分为前后台，只有超级用户才能登陆后台管理系统，所以在用户登录时需要 一个能够判断当前用户是否具有权限登录后台的过滤器，AdminPrivilegeFilter.java 编写工具类DataSourceUtils该类用于获取数据源和数据库的链接 用户注册和登录模块用户注册用户登录购物车模块模块描述实现购物车的基本功能实现订单的相关功能图书信息查询模块商品分类导航栏搜索功能公告板和本周热卖前台小结javawe实战：网上书城 后端管理后台管理系统概述商品管理模块商品管理模块简介实现查询商品列表功能实现添加商品信息功能实现编辑商品信息功能实现删除商品信息功能销售榜单模块订单管理模块订单管理模块简介实现查询订单列表功能实现查看订单详情功能实现删除订单功能后台小结]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[开学笔记]]></title>
      <url>%2F2017%2F02%2F20%2F%E5%BC%80%E5%AD%A6%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[语录 javaEE开学第一课 学习项目开发 项目框架非常的熟 业务走向，业务开发能力 学习要达到精通水平，是为了就业 学习三大框架ssh，只是学习了 编程的魅力，今天你学习了这个知识，过一段时间回过头来，一定会有全新的体验，不同的理解总结：温故而知新 荒唐的背后是什么 看小说，收到小说的的毒害。打架之后面的东西，是勇气。 总结：什么都懂一点，但是不深奥。寻求本质！ 基于MVC开发模式 课程计划–javaweb程序开发进阶 传智播客 jsp进阶 为期 10周 过滤器 监听器 EL表达式 JSP标签库 数据池 文件上传与下载 收现金开发一个 学习的本质，just with youself 新打算 以后将在此记录上课笔记，仅当记录那些年我们学过的 Hello World！ lvc唯爱]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[春雏集-三月花]]></title>
      <url>%2F2017%2F02%2F10%2F%E6%98%A5%E9%9B%8F%E9%9B%86-%E4%B8%89%E6%9C%88%E8%8A%B1%2F</url>
      <content type="text"><![CDATA[三月花二月的小城沾酒的夜色有些隐晦，暖冬的天气有些燥热，燥动的不安是二月的酒气。 盘着白雾的悬梁木板，是二月老人家的烟火，干烈的柴火是温暖的老宅。 二月的小城，我的家，几处青青，三月的花。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[android笔记-Android文件下载]]></title>
      <url>%2F2017%2F02%2F09%2Fandroid%E7%AC%94%E8%AE%B0-Android%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%2F</url>
      <content type="text"><![CDATA[android笔记-Android文件下载单线程下载效果展示： 主要过程：1.新建DownloadLinstener接口2.新建DoadloadTask继承AsycnTak3.新建DownloadService 继承service4.UI和Mainactivity实现 代码 DownloadLinstener接口实现* 1234567891011121314public interface DownloadListener &#123; void onProgress(int progress); void onSuccess(); void onFailed(); void onPaused(); void onCanceled();&#125; DownloadTask实现 * 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176package com.lvc.downloaddemo;import android.os.AsyncTask;import android.os.Environment;import java.io.File;import java.io.IOException;import java.io.InputStream;import java.io.RandomAccessFile;import okhttp3.OkHttpClient;import okhttp3.Request;import okhttp3.Response;/** * Created by lvc on 2017/2/9. */public class DownloadTask extends AsyncTask&lt;String ,Integer ,Integer&gt; &#123; // 下载常量 标识状态 public static final int TYPE_SUCCESS = 0; public static final int TYPE_FAILED = 1; public static final int TYPE_PAUSED = 2; public static final int TYPE_CANCELED = 3; private DownloadListener listener; private Boolean isPaused =false; private Boolean isCanceled = false; private int lastProgress; public DownloadTask(DownloadListener listener) &#123; this.listener = listener; &#125; // 后台执行的下载逻辑 @Override protected Integer doInBackground(String... params) &#123; InputStream in = null; RandomAccessFile savedFile = null; File file = null; try &#123; long downloadLength = 0; String downloadUrl = params[0]; String fileName = downloadUrl.substring(downloadUrl.lastIndexOf(&quot;/&quot;)); String directory = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS).getPath(); file = new File(directory+fileName); if (file.exists())&#123; downloadLength = file.length(); &#125; long contentLength = getContentLength(downloadUrl); if (contentLength == 0)&#123; return TYPE_FAILED; &#125;else if (contentLength == downloadLength)&#123; return TYPE_SUCCESS; &#125; OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder() //断点下载 .addHeader(&quot;RANGE&quot;, &quot;bytes=&quot; + downloadLength + &quot;-&quot;) .url(downloadUrl) .build(); Response response = client.newCall(request).execute(); if (response != null)&#123; in = response.body().byteStream(); savedFile = new RandomAccessFile(file,&quot;rw&quot;); savedFile.seek(downloadLength); byte[] b = new byte[1024]; int total =0; int len ; while ((len = in.read(b)) != -1)&#123; if (isCanceled)&#123; return TYPE_CANCELED; &#125; else if(isPaused)&#123; return TYPE_PAUSED; &#125; else&#123; total += len; savedFile.write(b,0,len); // 计算下载的百分比 int progress = (int)((total+downloadLength)*100 / contentLength); publishProgress(progress); &#125; &#125; response.body().close(); return TYPE_SUCCESS; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; if(in != null)&#123; try &#123; in.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; if(savedFile != null)&#123; try &#123; savedFile.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (isCanceled &amp;&amp; file != null)&#123; file.delete(); &#125; return TYPE_FAILED; &#125; // 更新 下载进度 @Override protected void onProgressUpdate(Integer... values) &#123; int progress = values[0]; if(progress &gt; lastProgress)&#123; listener.onProgress(progress); lastProgress = progress; &#125; &#125; //最终下载的结果 @Override protected void onPostExecute(Integer status) &#123; //super.onPostExecute(status); switch (status) &#123; case TYPE_SUCCESS: listener.onSuccess(); break; case TYPE_FAILED: listener.onFailed(); break; case TYPE_PAUSED: listener.onPaused(); break; case TYPE_CANCELED: listener.onCanceled(); default: break; &#125; &#125; private long getContentLength(String downloadUrl) throws IOException &#123; OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder() .url(downloadUrl) .build(); Response response = client.newCall(request).execute(); if (response != null &amp;&amp; response.isSuccessful())&#123; long contentlength = response.body().contentLength(); response.close(); return contentlength; &#125; return 0; &#125; public void pausedDownload()&#123; isPaused = true; &#125; public void canceledDownlod()&#123; isCanceled = true; &#125;&#125; DwonloadService实现* 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143package com.lvc.downloaddemo;import android.app.Notification;import android.app.NotificationManager;import android.app.PendingIntent;import android.app.Service;import android.content.Intent;import android.graphics.BitmapFactory;import android.os.Binder;import android.os.Environment;import android.os.IBinder;import android.support.v4.app.NotificationCompat;import android.util.Log;import android.widget.Toast;import java.io.File;public class DownloadService extends Service &#123; private DownloadTask downloadTask ; private String downloadUrl = null; int i = 0; private DownloadListener listener = new DownloadListener() &#123; @Override public void onProgress(int progress) &#123; getNotificationManager().notify(1,getNotification(&quot;正在下载...&quot;,progress)); &#125; @Override public void onSuccess() &#123; downloadTask = null; // 下载成功时将前台服务通知关闭，并创建一个下载成功的通知 stopForeground(true); getNotificationManager().notify(1, getNotification(&quot;Download Success&quot;, -1)); Toast.makeText(DownloadService.this, &quot;Download Success&quot;, Toast.LENGTH_SHORT).show(); &#125; @Override public void onFailed() &#123; downloadTask = null; // 下载失败时将前台服务通知关闭，并创建一个下载失败的通知 stopForeground(true); getNotificationManager().notify(1, getNotification(&quot;Download Failed&quot;, -1)); Toast.makeText(DownloadService.this, &quot;Download Failed&quot;, Toast.LENGTH_SHORT).show(); &#125; @Override public void onPaused() &#123; downloadTask = null; Toast.makeText(DownloadService.this, &quot;Paused&quot;, Toast.LENGTH_SHORT).show(); &#125; @Override public void onCanceled() &#123; downloadTask = null; stopForeground(true); Toast.makeText(DownloadService.this, &quot;Canceled&quot;, Toast.LENGTH_SHORT).show(); &#125; &#125; ; private DownloadBinder mBinder =new DownloadBinder(); /* public DownloadService() &#123; &#125;*/ @Override public IBinder onBind(Intent intent) &#123; return mBinder; &#125; class DownloadBinder extends Binder&#123; public void startDownload(String url)&#123; if(downloadUrl == null)&#123; downloadUrl =url; downloadTask = new DownloadTask(listener); downloadTask.execute(downloadUrl); startForeground(1,getNotification(&quot;正在下载...&quot;,0)); Log.i(&quot;判断点击次数&quot;, &quot;startDownload: &quot;+i); i++; Toast.makeText(DownloadService.this, &quot;正在下载...&quot;, Toast.LENGTH_SHORT).show(); &#125; &#125; public void pauseDownload()&#123; if(downloadTask !=null)&#123; downloadTask.pausedDownload(); &#125; &#125; public void cancelDownload()&#123; if(downloadTask != null)&#123; downloadTask.canceledDownlod(); &#125;else&#123; if(downloadUrl != null)&#123; //取消下载时需要将文件删除，并通知关闭 String fileName = downloadUrl.substring(downloadUrl.lastIndexOf(&quot;/&quot;)); String directory = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS).getPath(); File file = new File(directory + fileName); if(file.exists())&#123; file.delete(); &#125; getNotificationManager().cancel(1); stopForeground(true); Toast.makeText(DownloadService.this, &quot;Canceled&quot;, Toast.LENGTH_SHORT).show(); &#125; &#125; &#125; &#125; // 获取通知管理器 private NotificationManager getNotificationManager()&#123; return (NotificationManager) getSystemService(NOTIFICATION_SERVICE); &#125; //通知详情 private Notification getNotification(String title,int progress)&#123; // Intent intent = new Intent(this,MainActivity.class); // PendingIntent pi = PendingIntent.getActivities(this,0,new Intent[]&#123;intent&#125;,0); Intent intent = new Intent(this, MainActivity.class); PendingIntent pi = PendingIntent.getActivity(this, 0, intent, 0); NotificationCompat.Builder builder = new NotificationCompat.Builder(this); builder.setSmallIcon(R.mipmap.ic_launcher); builder.setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher)); builder.setContentIntent(pi); builder.setContentTitle(title); if(progress &gt;= 0)&#123; builder.setContentText(progress + &quot;%&quot;); builder.setProgress(100,progress,false); &#125; return builder.build(); &#125;&#125; Mainactivity实现 UI布局简单就不贴了* 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394package com.lvc.downloaddemo;import android.Manifest;import android.content.ComponentName;import android.content.Intent;import android.content.ServiceConnection;import android.content.pm.PackageManager;import android.os.IBinder;import android.support.annotation.NonNull;import android.support.v4.app.ActivityCompat;import android.support.v4.content.ContextCompat;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.Toast;public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; private DownloadService.DownloadBinder downloadBinder; private ServiceConnection connection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName componentName, IBinder iBinder) &#123; downloadBinder = (DownloadService.DownloadBinder) iBinder; &#125; @Override public void onServiceDisconnected(ComponentName componentName) &#123; &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button startDownload = (Button) findViewById(R.id.btn_start); Button pauseDownload = (Button) findViewById(R.id.btn_paused); Button cancelDownload = (Button) findViewById(R.id.btn_cancel); startDownload.setOnClickListener(this); pauseDownload.setOnClickListener(this); cancelDownload.setOnClickListener(this); Intent intent = new Intent(this,DownloadService.class); startService(intent); bindService(intent,connection,BIND_AUTO_CREATE); if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) &#123; ActivityCompat.requestPermissions(MainActivity.this, new String[]&#123; Manifest.permission. WRITE_EXTERNAL_STORAGE &#125;, 1); &#125; &#125; @Override public void onClick(View view) &#123; if (downloadBinder == null) &#123; return; &#125; switch (view.getId()) &#123; case R.id.btn_start: String url = &quot;http://www.runoob.com/wp-content/uploads/2015/09/DownLoadDemo1.zip&quot;; downloadBinder.startDownload(url); break; case R.id.btn_paused: downloadBinder.pauseDownload(); break; case R.id.btn_cancel: downloadBinder.cancelDownload(); break; default: break; &#125; &#125; @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; switch (requestCode) &#123; case 1: if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] != PackageManager.PERMISSION_GRANTED) &#123; Toast.makeText(this, &quot;拒绝权限将无法使用程序&quot;, Toast.LENGTH_SHORT).show(); finish(); &#125; break; default: &#125; &#125; @Override protected void onDestroy() &#123; super.onDestroy(); unbindService(connection); &#125;&#125; 多线程下载 多线程的下载流程 获取网络连接 本地磁盘创建相同大小的空文件 计算每条线程需从文件哪个部分开始下载，结束 依次创建，启动多条线程来下载网络资源的指定部分 核心代码：12]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[android笔记-HttpURLConnection]]></title>
      <url>%2F2017%2F02%2F07%2Fandroid%E7%AC%94%E8%AE%B0-HttpURLConnection%2F</url>
      <content type="text"><![CDATA[android笔记-HttpURLConnection报错 调用InputStream in = connection.getErrorStream(); 报错 主要代码 使用okhttp直接上代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788package com.lvc.nnetworktest.util;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.net.HttpURLConnection;import java.net.URL;import okhttp3.OkHttpClient;import okhttp3.Request;import okhttp3.Response;/** * Created by lvc on 2017/2/7. * 网络请求util * 封装了 httpURLConnection &amp; okhttp3 */public class HtppUtil &#123; public static void sendHttpRequest(final String address,final HttpCallbackListener listener)&#123; new Thread(new Runnable() &#123; @Override public void run() &#123; HttpURLConnection connection = null; //InputStream in =null; try &#123; URL url = new URL(address); connection = (HttpURLConnection) url.openConnection(); connection.setRequestMethod(&quot;GET&quot;); connection.setConnectTimeout(8000); connection.setReadTimeout(8000); connection.setDoInput(true); connection.setDoOutput(true); InputStream in = connection.getErrorStream(); BufferedReader reader = new BufferedReader(new InputStreamReader(in)); StringBuilder response = new StringBuilder(); String line; while((line =reader.readLine())!=null)&#123; response.append(line); &#125; if(listener != null)&#123; listener.onFinish(response.toString()); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); if(listener != null)&#123; listener.onError(e); &#125; &#125;finally &#123; if(connection != null)&#123; connection.disconnect(); &#125; /* if (in != null)&#123; try &#123; in.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;*/ &#125; &#125; &#125;).start(); &#125; public interface HttpCallbackListener&#123; void onFinish(String response); void onError(Exception e); &#125; /** * okhttp3 */ public static void sendOkhttpRequest(String address , okhttp3.Callback callback)&#123; OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder() .url(address) .build(); client.newCall(request).enqueue(callback); //调用回调 &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[闲言碎语-西游降魔篇]]></title>
      <url>%2F2017%2F02%2F06%2F%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD-%E8%A5%BF%E6%B8%B8%E9%99%8D%E9%AD%94%E7%AF%87%2F</url>
      <content type="text"><![CDATA[西游真的是那个西游吗许久不见，或许是一种情怀！可这又有什么关系呢？佛是什么？你又是什么？我又是什么？西游真的是西游吗？22部天竺真经真的能普度众生吗？度的人，应该是他自己吧。 一生所爱 是被用坏了的情怀吗？终究你我将不复存在关于执念你我懂多少不同的人有不同世界一生真的能爱个够吗陈先生历经千辛万苦只寻普度众生的良药可是大爱小爱说不清道不明在制服猪刚鬣的之时孙先生出了一个法子在月圆之夜，绝山之巅段小姐翩然起舞，宛若谪仙，人间不应有一生所爱的歌声，纵然是情怀作祟。 我的西游我希望寻找自己的西游之路，不为普度众生只为度我自己。西游终究是被烙印在骨子里，流淌的血液在轰轰的燃烧着，可是红尘真的有 真 善 美 ？愿意相信的谎言，我愿意，那就有。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[android笔记-调用摄像头相册]]></title>
      <url>%2F2017%2F02%2F06%2Fandroid%E7%AC%94%E8%AE%B0-%E8%B0%83%E7%94%A8%E6%91%84%E5%83%8F%E5%A4%B4%E7%9B%B8%E5%86%8C%2F</url>
      <content type="text"><![CDATA[调用摄像头调用摄像头拍照获取图片 Demo：效果展示 重要代码123456789101112131415161718192021//创建File 对象，用于存储拍照后的图片File outputImage = new File(getExternalCacheDir(),&quot;output_image.jsp&quot;);try &#123; if(outputImage.exists())&#123; outputImage.delete(); &#125; outputImage.createNewFile();&#125;catch (IOException e)&#123; e.printStackTrace();&#125;if(Build.VERSION.SDK_INT&gt;=24)&#123; imageUri = FileProvider.getUriForFile(MainActivity.this,&quot;com.example.cramea.fileprovider&quot;, outputImage);&#125;else&#123; imageUri = Uri.fromFile(outputImage);&#125;//启动相机程序Intent intent = new Intent(&quot;android.media.action.IMAGE_CAPTURE&quot;);intent.putExtra(MediaStore.EXTRA_OUTPUT,imageUri);startActivityForResult(intent,TAKE_PHOTO); 从相册中选择图片全部代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208package com.lvc.cameraalbumtest;import android.Manifest;import android.annotation.TargetApi;import android.app.Activity;import android.content.ContentUris;import android.content.Intent;import android.content.pm.PackageManager;import android.database.Cursor;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.net.Uri;import android.os.Build;import android.provider.DocumentsContract;import android.provider.MediaStore;import android.support.annotation.NonNull;import android.support.v4.app.ActivityCompat;import android.support.v4.content.ContextCompat;import android.support.v4.content.FileProvider;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.ImageView;import android.widget.Toast;import java.io.File;import java.io.FileNotFoundException;import java.io.IOException;public class MainActivity extends AppCompatActivity &#123; public static final int TAKE_PHOTO = 1; public static final int CHOOSE_PHOTO = 2; private Button takephoto ; private Button choosephoto ; private ImageView pictrue ; private Uri imageUri ; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); /** * 1.获取实例 * 2.绑定监听事件 * */ takephoto = (Button) findViewById(R.id.take_photo); choosephoto = (Button) findViewById(R.id.choose_from_album); pictrue = (ImageView) findViewById(R.id.picture); takephoto.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; //创建File 对象，用于存储拍照后的图片 File outputImage = new File(getExternalCacheDir(),&quot;output_image.jsp&quot;); try &#123; if(outputImage.exists())&#123; outputImage.delete(); &#125; outputImage.createNewFile(); &#125;catch (IOException e)&#123; e.printStackTrace(); &#125; if(Build.VERSION.SDK_INT&gt;=24)&#123; imageUri = FileProvider.getUriForFile(MainActivity.this,&quot;com.example.cramea.fileprovider&quot;, outputImage); &#125;else&#123; imageUri = Uri.fromFile(outputImage); &#125; //启动相机程序 Intent intent = new Intent(&quot;android.media.action.IMAGE_CAPTURE&quot;); intent.putExtra(MediaStore.EXTRA_OUTPUT,imageUri); startActivityForResult(intent,TAKE_PHOTO); &#125; &#125;); choosephoto.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; if(ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED)&#123; ActivityCompat.requestPermissions(MainActivity.this,new String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;,1); &#125;else&#123; openAlbum(); &#125; &#125; &#125;); &#125; /** * */ private void openAlbum()&#123; Intent intent =new Intent(&quot;android.intent.action.GET_CONTENT&quot;); intent.setType(&quot;image/*&quot;); startActivityForResult(intent,CHOOSE_PHOTO); &#125; @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; // super.onActivityResult(requestCode, resultCode, data); switch (requestCode)&#123; case TAKE_PHOTO: try &#123; Bitmap bitmap = BitmapFactory.decodeStream(getContentResolver() .openInputStream(imageUri)); pictrue.setImageBitmap(bitmap); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; break; case CHOOSE_PHOTO: if(resultCode == RESULT_OK )&#123; //判断手机系统版本号 if(Build.VERSION.SDK_INT&gt;=19)&#123; //4.4及以上版本使用这个方法处理图片 handleImageOnKiKat(data); &#125;else&#123; //4.4以下版本使用这个方法处理图片 handleImageBeforeKiKat(data); &#125; &#125; break; default: break; &#125; &#125; private void handleImageBeforeKiKat(Intent data) &#123; Uri uri = data.getData(); String imagepath = getImagePath(uri,null); displayImage(imagepath); &#125; @TargetApi(19) private void handleImageOnKiKat(Intent data) &#123; String imagePath= null; Uri uri = data.getData(); if(DocumentsContract.isDocumentUri(this,uri))&#123; String docId = DocumentsContract.getDocumentId(uri); if(&quot;com.android.providers.media.documents&quot;.equals(uri.getAuthority()))&#123; String id = docId.split(&quot;:&quot;)[1]; String selection = MediaStore.Images.Media._ID+&quot;=&quot;+id; imagePath = getImagePath(MediaStore.Images.Media.EXTERNAL_CONTENT_URI,selection); &#125;else if(&quot;com.android.providers.downloads.documents&quot;.equals(uri.getAuthority()))&#123; Uri contentUri = ContentUris.withAppendedId(Uri.parse(&quot;content://downloads/public_downloads&quot;),Long.valueOf(docId)); imagePath = getImagePath(contentUri,null); &#125; &#125;else if(&quot;content&quot;.equalsIgnoreCase(uri.getScheme()))&#123; imagePath = getImagePath(uri,null); &#125;else if(&quot;file&quot;.equalsIgnoreCase(uri.getScheme()))&#123; imagePath = uri.getPath(); &#125; displayImage(imagePath); &#125; @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; //super.onRequestPermissionsResult(requestCode, permissions, grantResults); switch (requestCode)&#123; case 1: if(grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED )&#123; openAlbum(); &#125;else&#123; Toast.makeText(this,&quot;you denied the permisson&quot;,Toast.LENGTH_SHORT).show(); // openAlbum(); &#125; break; default: break; &#125; &#125; private String getImagePath(Uri uri,String selection)&#123; String path =null; //通过Uri和 selection 来获取真实的图片路径 Cursor cursor = getContentResolver().query(uri,null,selection,null,null); if(cursor != null)&#123; if (cursor.moveToNext())&#123; path = cursor.getString(cursor.getColumnIndex(MediaStore.Images.Media.DATA)); &#125; cursor.close(); &#125; return path; &#125; private void displayImage(String imagePath)&#123; if (imagePath !=null)&#123; Bitmap bitmap = BitmapFactory.decodeFile(imagePath); pictrue.setImageBitmap(bitmap); &#125;else&#123; Toast.makeText(this,&quot;Failed to get image&quot;,Toast.LENGTH_SHORT).show(); &#125; &#125;&#125; 总结 博客真难写想做个记录发现不知道怎么去记汗颜啊]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[android笔记-使用通知]]></title>
      <url>%2F2017%2F02%2F05%2Fandroid%E7%AC%94%E8%AE%B0-%E4%BD%BF%E7%94%A8%E9%80%9A%E7%9F%A5%2F</url>
      <content type="text"><![CDATA[Android笔记-使用通知通知的基本用法 代码 123456789NotificationManager notificationManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE); Notification notification = new NotificationCompat.Builder(this) .setContentTitle(&quot;通知&quot;) .setContentText(&quot;这是一个通知！&quot;) .setWhen(System.currentTimeMillis()) .setSmallIcon(R.mipmap.ic_launcher) .setLargeIcon(BitmapFactory.decodeResource(getResources(),R.mipmap.ic_launcher)) .build(); notificationManager.notify(1,notification); PendingIntent可以简单的理解为延迟执行的Intent pendingIntent 用法1.获取PendingIntent实例： getActivity() getBroadcast() getService() &gt; 以上方法参数相同： * 1 context * 2 0 通常传入0 * 3 Intent对象 * 4 用于确定PendingIntent的行为 有4个值：FLAG_ONE_SHOT FLAG_ON_CREATE FLAG_CANEL_CURRENT FLAG_UPDATE_CURRENT 给通知添加响应 代码12345678910111213Intent intent = new Intent(this,NotificationActivity.class); Intent[] intents = &#123;intent&#125;; PendingIntent pi = PendingIntent.getActivities(this,0,intents,0); NotificationManager notificationManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE); Notification notification = new NotificationCompat.Builder(this) .setContentTitle(&quot;通知&quot;) .setContentText(&quot;这是一个通知！&quot;) .setWhen(System.currentTimeMillis()) .setSmallIcon(R.mipmap.ic_launcher) .setLargeIcon(BitmapFactory.decodeResource(getResources(),R.mipmap.ic_launcher)) .setContentIntent(pi) .build(); notificationManager.notify(1,notification); 取消通知栏上的通知`.setAutoCancel(true)` 在响应的Activity中 添加 1.NotificationManager notificationManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE); 2.notificationManager.cancel(1);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[我的第一篇博客]]></title>
      <url>%2F2017%2F02%2F03%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
      <content type="text"><![CDATA[没有正式文章，仅作为当前内容的测试！ 做个简单的小结昨天在慕课网手记中看到 hexo + github pages 搭建个人博客 经过长时间的学习，再一次觉得开源的伟大! 用了不到一天的时间，杂七杂八的也就成这个样子了 实践才是检验真理的唯一标准 坚持每天学点东西吧。这也算还了我一个小愿望！2017 任重而道远! 下一步，开发一个APP！ ——Lvc]]></content>
    </entry>

    
  
  
</search>
