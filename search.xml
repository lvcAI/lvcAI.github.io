<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[javaee上课笔记：文件的上传与下载]]></title>
      <url>%2F2017%2F03%2F08%2Fjavaee%E4%B8%8A%E8%AF%BE%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD%2F</url>
      <content type="text"><![CDATA[文件的上传步骤： 创建DiskFileItemFactory 设置文件缓存路径 创建fileupload 组件 解析request 遍历 FileItem 集合 判断 fileItem 的类型 普通字段 获取字段名 和 值 上传文件 获得文件上传的路径 截取文件名 文件名唯一 设置 文件保存路径 创建文件 获得上传文件流 获得写入文件流 流的对拷 关闭流 删除临时文件 代码实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687package com.lvc.chapter6;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.io.PrintWriter;import java.util.List;import java.util.UUID;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.apache.commons.fileupload.FileItem;import org.apache.commons.fileupload.FileUploadException;import org.apache.commons.fileupload.disk.DiskFileItemFactory;import org.apache.commons.fileupload.servlet.ServletFileUpload;public class UpLoadServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType(&quot;text/html;charset=utf-8&quot;); this.doPost(request, response); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType(&quot;text/html;charset=utf-8&quot;); try &#123; //创建工厂 DiskFileItemFactory factory = new DiskFileItemFactory(); File f = new File(&quot;e:/Target&quot;); if(!f.exists())&#123; f.mkdirs(); &#125; //设置文件缓存路径 factory.setRepository(f); //创建fileUpload 组件 ServletFileUpload fileUpload = new ServletFileUpload(factory); fileUpload.setHeaderEncoding(&quot;gbk&quot;); //解析request List&lt;FileItem&gt; fileItems = fileUpload.parseRequest(request); PrintWriter writer = response.getWriter(); //遍历集合 for (FileItem fileItem : fileItems )&#123; if (fileItem.isFormField())&#123; String name = fileItem.getFieldName(); String value = fileItem.getString(&quot;gbk&quot;); writer.print(&quot;上传者：&quot;+value+&quot;&lt;br/&gt;&quot;); &#125;else&#123; String fileName = fileItem.getName(); writer.println(&quot;文件来源:&quot;+fileName+&quot;&lt;br/&gt;&quot;); //fileName=fileName.substring(fileName.lastIndexOf(&quot;\\&quot;)); writer.println(&quot;成功上传的文件:&quot;+fileName); fileName=UUID.randomUUID().toString()+&quot;_&quot;+fileName; String webPath = &quot;/upload/&quot;; String filePath = getServletContext().getRealPath(webPath+fileName); File file = new File(&quot;E:/V/&quot;+fileName); file.getParentFile().mkdirs(); file.createNewFile(); InputStream in = fileItem.getInputStream(); OutputStream out = new FileOutputStream(file); byte[] buffer = new byte[1024]; int len; while((len=in.read(buffer))&gt;0)&#123; out.write(buffer, 0, len); &#125; in.close(); out.close(); fileItem.delete(); &#125; &#125; &#125; catch (FileUploadException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; 文件的下载步骤 获得下载文件路径，取得文件对象 设置响应头 通知浏览器文件的使用方式 获取输入流 获取输出流 代码实例123456789101112131415161718192021222324252627282930313233343536373839404142package com.lvc.chapter6;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * * @author lvc *该类设置索要下载文件及文件在浏览器中的 打开方式 */public class DownLoadServlet extends HttpServlet&#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType(&quot;text/html;charset=utf-8&quot;); this.doPost(request, response); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType(&quot;text/html;charset=utf-8&quot;); response.addHeader(&quot;Content-Type&quot;, &quot;application/octet-stream&quot;); response.addHeader(&quot;Content-Disposition&quot;, &quot;attachment;filename=login.jsp&quot;); InputStream in = getServletContext().getResourceAsStream(&quot;login.jsp&quot;); OutputStream out = response.getOutputStream(); byte[] buffer = new byte[1024]; int len; while((len=in.read(buffer))!=-1)&#123; out.write(buffer, 0, len); &#125; &#125;&#125; 小知识点${pageContext.request.contextPath} JSP取得绝对路径 一．问题 JSP中究竟采用绝对路径还是采用相对路径随着所采用技术的越来越复杂，这个问题也变得越来越难以解决。１）采用相对路径遇到的问题 相对路径固然比较灵活，但如果想复制页面内的代码却变得比较困难，因为不同的页面具有不同的相对路径，复制后必须修改每一个连接的路径。如果页面被多于一个的页面所包含，那么被包含页面中的相对路径将是不正确的。如果采用Struts的Action返回页面，那么由于页面路径与Action路径不同，使得浏览器无法正确解释页面中的路径，如页面为/pages/cust/cust.jsp，图片所有目录为/images/title.gif，这时在/pages/cust/cust.jsp中的所用的路径为”http://images.cnblogs.com/title.gif”，但是如果某一个Action的Forward指向这个JSP文件，而这个Action的路径为/cust/manage.do，那么页面内容中”http://images.cnblogs.com/title.gif”就不再指向正确的路径了。解决以上问题似乎只有使用绝对路径了。 ２）采用绝对路径遇到的问题 随着不同的Web应用发布方式，绝对路径的值也不同。如Web应用发布为MyApp，则路径”/MyApp/images/title.gif”是正确的，但发布为另一应用时如MyApp2，这个路径就不对了，也许这个情况比较少，但以default方式发布Web应用时以上绝对路径也不同：”/images/title.gif”。 二．解决方案１）采用绝对路径，但为了解决不同部署方式的差别，在所有非struts标签的路径前加${pageContext.request.contextPath}，如原路径为：”/images/title.gif”，改为“${pageContext.request.contextPath}/images/title.gif”。代码” ${pageContext.request.contextPath}”的作用是取出部署的应用程序名，这样不管如何部署，所用路径都是正确的。 缺点：操作不便，其他工具无法正确解释${pageContext.request.contextPath} ２） 采用相对路径，在每个JSP文件中加入base标签，如： 这样所有的路径都可以使用相对路径。 缺点：对于被包含的文件依然无效。 真正使用时需要灵活应用１）和２），写出更加健壮的代码。 在使用的时候可以使用${pageContext.request.contextPath}，也同时可以使用&lt;%=request.getContextPath()%&gt;达到同样的效果，同时，也可以将${pageContext.request.contextPath}，放入一个JSP文件中，&gt; 将用C：set放入一个变量中，然后在用的时候用EL表达式取出来。 如： &lt;c:set var=&quot;ctx&quot; value=&quot;${pageContext.request.contextPath}&quot; /&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[学习方法：黑马高薪学习方法]]></title>
      <url>%2F2017%2F03%2F05%2F%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%EF%BC%9A%E9%BB%91%E9%A9%AC%E9%AB%98%E8%96%AA%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[学习方法：黑马高薪学习方法原文地址 此文章是黑马老学员给新学员的学习建议，一个来自高薪学员的心声，望仔细耐心看完，这将是你在黑马学习的重要指南。 四个半月的时光转瞬而逝，我如愿以偿地拿到了让自己满意的offer，这都必须归功于黑马辛苦教学的老师以及身边勤奋学习的同学们对我不断地鼓励和支持。在黑马学习期间，我享受到了以前从未有过的充实生活，并且这段人生经历激发了我对技术难以磨灭的热情，这份热情即使在我就职之后依然持续地灼烧着。因此，怀着感恩的心情，我认为自己必须为黑马做点什么，所以才有了这篇关于学习方法的总结。希望学弟学妹们能从这里汲取到有利于自己的学习思路，从而让自己能够用更短的时间学习到更多的知识，利用黑马这优质的平台，让自己在技术的道路上走得更快，更远。 记得入学后不久，我们就进行了第一次测验。然后，同学们学习效率的差距惊人地暴露出来了。令人诧异的是，很多同学学习很辛苦，甚至经常熬夜，但是学习效果并没有预想的那么好。反之，很多同学学习时间很短，但是效果却非常地惊人。于是，我就开始思考是什么原因导致了这种差异？通过与很多同学的沟通和交流，我终于明白学习方法起到了至关重要的作用。那么好的学习方法应该注意哪些方面呢？我认为只要你能够经常问自己下面八个问题，你就可以确定自己是不是走在正轨上。 Question 1：明天会上哪些内容的课程呢？ 如果可以的话，你可以拷贝到往届学长学姐们的笔记，每天利用5分钟的时间大致浏览第二天的课程，从而能够从全局把握课程结构，从而使自己在第二天老师6个小时的狂轰滥炸中不至于处于被动，然后不知道自己所处何处。反之，你就可以化被动为主动，从而可以将6个小时的课程切割成对应于各个知识点的小模块。通过这种方式，你就可以极大地提升自己的听课质量。 Question 2：今天的课程我完全听懂了吗？ 听课质量的高低对学习效果可以说起到了中流砥柱的作用。试想一下，如果你的听课效率质量很高，那么晚上敲代码、复习的时间就可以大大地减少。因为，你不会再对着老师分发的代码和资料问自己一些愚蠢的问题。例如：这段代码是干什么的来着？这个知识点好像完全没听懂。这些令人抓狂的问题会严重挫伤你学习的积极性。因此，如果上课有任何内容没有听懂，那么不要忽略掉，应该把自己想问的问题记录下来，下课之后，立刻通过与同学和老师的讨论解决掉。 Question 3：今天我对哪些问题有疑问呢？ 如果你是抱着积极的学习态度在听课，那么你一定会在上课期间产生各种各样的idea。你可能在想一种代码效果有没有另外一种实现方式，或者另外一种配置方式会有什么效果。这时候，一定要迅速记录下来这些问题，不要占用上课时间跟同学讨论或者自己纠结于此。因为，一旦你这样做，后面的课程你就完全不会在用心听了，这就降低了听课的质量。 Question 4：有疑问的问题自己可以通过网络或者写一些例子得到结果吗？ 产生任何问题之后，不要急于问老师和同学，而是要培养自己独立学习和解决问题的能力。你可以通过网络或者API文档查询到结果，又或者自己写一个例子程序得到答案。如果实在有困难，再向学生和老师求助。这样，可以培养你独立解决问题的能力。毕竟，在公司里，是没有太多人给你全方位的指导和帮助的，不是吗？ Question 5：今天的代码我有敲完吗？ 很多同学有时候会进入一个误区，那就是他认为上课的时候代码已经完全理解了，下课就没有必要再敲这些代码了，这就走向了一个极端。另外一个极端则是认为代码必须自己从头到尾一个字母不漏的敲出来才算掌握了。实际上，代码最重要的是写出思路，然后通过查询API文档完成代码。当然，第一次敲代码的时候最好可以临摹老师的代码，然后再自己独立完成。否则，由于难度太大，可能会打消学习的积极性并且浪费时间在回忆代码上。另外一个需要指出的点是，千万不要给自己拖延的理由，今天的代码今天必须要完成，即使奋战到凌晨2点也在所不惜。如果你拖延到明天，那么再加上第二天的代码量，你会倾向于放弃昨天的代码，甚至对今天的代码也感到厌烦。毕竟学习的时间是有限的，利用一天的时间承担两天的任务量，没有压力才怪呢！ Question 6：我可以对这些代码进行封装或者优化吗？我可以做一些小应用吗？ 任何的知识想要活学活用都必须要经过自我优化并且不断应用从而达到熟能生巧的过程。如果仅仅局限于老师的例子代码，你将会发现自己解决问题的能力并不强，还只是处于粘贴拷贝的码农阶段。但是如果你能够思考这些代码怎么去封装和优化，并且自己试图做一些应用，那么恭喜你，你就在朝着架构师以及高级软件工程师的方向发展了。 Question 7：今天我的任务完成了吗？ “今日事，今日毕”。古人的这句话说明了执行力的重要性。所以，千万不要给自己任何拖延的理由。不要说，今天几个玩的很好的哥们邀我玩dota，今天的任务明天我一定做！如果这样的话，你会发现，第二天你已经生疏了第一天的知识。因为你没有复习也没有敲代码。你会感到更大的阻力去重新学习昨天的课程。这时候厌倦的情绪会大大的降低你的学习效果。所以，不要让任何事情阻碍你去完成你今天的任务。你需要明白，拖延不是选项，你甚至根本不要去考虑它。 Question 8：我有明确而有效的复习计划吗？ 孔子有句话，“温故而知新，可以为师矣”。见名知意，就是经常温习就可以学到新的东西，也就是熟能生巧。很多同学在学习后面知识的时候经常会抱怨以前的知识已经遗忘了。因而，当他们学习后面的知识时，就会感觉到非常的有压力，甚至产生了放弃学习的念头。这种心态会严重扼杀一个人的自信心并且学习效率极低。等到就业找工作的时候，这些同学会变得极度不自信。因为，他认为所有的知识在他心中越来越模糊。那么，好的措施就是制定明确有效的学习计划，定期复习将会使你保持对知识的熟悉程度。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[春雏集-流动的思绪]]></title>
      <url>%2F2017%2F03%2F05%2F%E6%98%A5%E9%9B%8F%E9%9B%86-%E6%B5%81%E5%8A%A8%E7%9A%84%E6%80%9D%E7%BB%AA%2F</url>
      <content type="text"><![CDATA[&nbsp; &nbsp; &nbsp; &nbsp;所有的思绪被一场大雨冲刷的一干二净，窗花外的朦胧又梦幻般的世界，炫耀了莫名的姿色，五颜六色霓虹如五味杂陈般又塞满了整个空间。 &nbsp; &nbsp; &nbsp; &nbsp;车如流水马如龙，身如浮萍，难定踪迹。安静的车厢，闪烁的车灯，荧屏映衬着冷漠的脸，扶手也冷冷的释放着冷意，窗外的雨越发的朦胧，翻起的水雾遮拢了这个小城。 &nbsp; &nbsp; &nbsp; &nbsp;从繁华到落幕，笔直的大道，到底掩含了多少如流水般如你我般在相似而又落寞的世界里禹禹独行。追寻着光明，却曾未被照耀。但还是，在黑夜中坚持的前进着，心中一直坚定的信念，曾未如此光明过，不断的放大放大，直到思绪飘离了这里，在苍穹之上，默默的俯视着光怪陆离的世界。我看到了街边行乞的流浪人，祈求着每一个路人，只为了一顿三餐；我看到了在公园里哭泣的小女孩，眼中充满的渴望和泪水，只是想得到关爱；我看到了吵架的情侣，相互指责着对方，可是他倆又是那么的相爱；我看到了，我看到了世界，我看到了平常未曾感知到的色彩，生活如此。 &nbsp; &nbsp; &nbsp; &nbsp;“我的心愿的是世界和平！”一句会被嘲笑的话，此刻却是那么有力，那么渴望。相互扮演着让着这个世界运行下去的角色，有时你会生出挫败的无力感，此刻些许能明白些所谓的“看破红尘，遁入空门”这般话语。追心而去，逐念而去，坚守本心。 &nbsp; &nbsp; &nbsp;&nbsp;谁的思绪飞越了尽头，如流水般一去不返。 &nbsp; &nbsp; &nbsp; &nbsp;昨日而去，今日而追。心若有念，不曾有晚。 &nbsp; &nbsp; &nbsp; &nbsp;流动的思绪，翻腾的水雾，220照样在行驶，霓虹照样五味杂陈。每一次行程，如洗礼般，净化污浊，保持自我的纯真和最初的信念。 &nbsp; &nbsp; &nbsp; &nbsp;飘飞的思绪，随着耸动的人流下了车。我在窗外，看了看脚下的流水，却没了在窗内的思绪，笃定了思绪，默默前行。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[javaee上课笔记-Servlet事件监听器]]></title>
      <url>%2F2017%2F03%2F03%2Fjavaee%E4%B8%8A%E8%AF%BE%E7%AC%94%E8%AE%B0-Servlet%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E5%99%A8%2F</url>
      <content type="text"><![CDATA[学习目标 掌握监听器的相关API 掌握监听器域对象中的属性变更 掌握感知被HttpSession绑定的事件监听器 Servlet事件监听器概述 监听器组成：1.事件（Event）：用户的一个操作，如单机一个按钮、调用一个方法、创建一个对象吗等2.事件源：产生事件的对象3.事件监听器（Listener）：负责监听发生在事件源上的事件。4.事件处理器：监听器的成员方法，当事件发生的时候会触发的处理器（成员方法） 事件监听器工作步骤1.将监听器绑定到事件源，也就是注册监听器。2.事件发生时会触发监听器的的成员方法，即事件的处理器，传递事件对象。3.事件处理器通过事件 对象获得事件源，并对事件源进行处理。 Servlet事件监听器根据监听事件的不同分为三类1.用于监听域对象的创建和销毁的事件监听器（ServletContextListener 接口、HttpSessionListener 接口、ServletRequestListener 接口）。2.用于监听域对象属性增加和删除的事件监听器（ServletContextAttributeListener 接口、HttpSessionAttributeListener 接口、ServletRequestAttributeListener 接口）3.用于监听绑定到HttpSession域中某个对象状态的事件监听器（HttpSessionBindingListener接口、HttpsessionActivationListener 接口） 监听域对象的生命周期ServletContextListener 接口 方法： contextInitalized（）方法public void contextInitalized(ServletContextEvent sce)当ServletContext 对象被创建时，web容器会调用该方法，传入ServletContextEvent类型参数，在方法内容通过该参数来获取 创建的ServletContext对象 contextDestroyed（）方法public vid contextDestroyed(ServletContextEvent sce)内容描述差不多，就不写了HttpSessionListener 接口 sessionCreated()方法public vid sessionCreated（httpsessionEvent se） sessionDestroyed（）方法public vid sessionDestroyed（）方法 se）ServletRequestListener 接口 requestInitalized（）方法public void requestInitalized(ServletRequestEvent sre) requestDestroyed方法public void requestDestroyed(ServletRequestEvent sre) 案例-监听域对象的生命周期对Servlet域对象的生命周期进行监听，首先要实现域对象相应的接口 123456789101112131415161718192021222324package party.pjc.chapter05.listener;import javax.servlet.*;import javax.servlet.http.*;public class MyListener implements ServletContextListener, HttpSessionListener, ServletRequestListener &#123; public void contextInitialized(ServletContextEvent arg0) &#123; System.out.println(&quot;ServletContext对象被创建了&quot;); &#125; public void contextDestroyed(ServletContextEvent arg0) &#123; System.out.println(&quot;ServletContext对象被销毁了&quot;); &#125; public void requestInitialized(ServletRequestEvent arg0) &#123; System.out.println(&quot;ServletRequest对象被创建了&quot;); &#125; public void requestDestroyed(ServletRequestEvent arg0) &#123; System.out.println(&quot;ServletRequest对象被销毁了&quot;); &#125; public void sessionCreated(HttpSessionEvent arg0) &#123; System.out.println(&quot;HttpSession对象被创建了&quot;); &#125; public void sessionDestroyed(HttpSessionEvent arg0) &#123; System.out.println(&quot;HttpSession对象被销毁了&quot;); &#125;&#125; 配置文件，部署Mylistener监听器 12345&lt;listener&gt; &lt;listener-class&gt; packagePath &lt;/listener-class&gt;&lt;/listener&gt; 统计在线人数 贴上核心代码： 123456789101112131415161718package party.pjc.chapter05.listener;import javax.servlet.*;import javax.servlet.http.*;public class CountListener implements HttpSessionListener &#123; private int count = 0;// 用于统计在线人数 public void sessionCreated(HttpSessionEvent hse) &#123; count++;// session对象创建时count变量加1 ServletContext context = hse.getSession().getServletContext(); context.setAttribute(&quot;count&quot;, new Integer(count)); &#125; public void sessionDestroyed(HttpSessionEvent hse) &#123; count--;// session对象销毁时count变量减1 ServletContext context = hse.getSession().getServletContext(); context.setAttribute(&quot;count&quot;, new Integer(count)); &#125;&#125; 监听域对象中的属性变更监听对象属性变更的接口 attributeAdded（）方法public void attributeAdded(ServletContextAttributeEvent scab)public void attributeAdded(HttpSessionOnBindingEvent se)public void attributeAdded(ServletRequestAttributeEvent srae) attributeRemove()方法public void attributeRemove(ServletContextAttributeEvent scab)public void attributeRemove(HttpSessionOnBindingEvent se)public void attributeRemove(ServletRequestAttributeEvent srae)案例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package party.pjc.chapter05.listener;import javax.servlet.*;import javax.servlet.http.*;public class MyAttributeListener implementsServletContextAttributeListener,HttpSessionAttributeListener, ServletRequestAttributeListener &#123; public void attributeAdded(ServletContextAttributeEvent sae) &#123; String name = sae.getName(); System.out.println(&quot;ServletContext添加属性：&quot; + name + &quot;=&quot; + sae.getServletContext().getAttribute(name)); &#125; public void attributeRemoved(ServletContextAttributeEvent sae) &#123; String name = sae.getName(); System.out.println(&quot;ServletContext移除属性: &quot; + name); &#125; public void attributeReplaced(ServletContextAttributeEvent sae) &#123; String name = sae.getName(); System.out.println(&quot;ServletContext替换属性：&quot; + name + &quot;=&quot; + sae.getServletContext().getAttribute(name)); &#125; public void attributeAdded(HttpSessionBindingEvent hbe) &#123; String name = hbe.getName(); System.out.println(&quot;HttpSession添加属性：&quot; + name + &quot;=&quot; + hbe.getSession().getAttribute(name)); &#125; public void attributeRemoved(HttpSessionBindingEvent hbe) &#123; String name = hbe.getName(); System.out.println(&quot;HttpSession移除属性: &quot; + name); &#125; public void attributeReplaced(HttpSessionBindingEvent hbe) &#123; String name = hbe.getName(); System.out.println(&quot;HttpSession替换属性：&quot; + name + &quot;=&quot; + hbe.getSession().getAttribute(name)); &#125; public void attributeAdded(ServletRequestAttributeEvent sra) &#123; String name = sra.getName(); System.out.println(&quot;ServletRequest添加属性：&quot; + name + &quot;=&quot; + sra.getServletRequest().getAttribute(name)); &#125; public void attributeRemoved(ServletRequestAttributeEvent sra) &#123; String name = sra.getName(); System.out.println(&quot;ServletRequest移除属性: &quot; + name); &#125; public void attributeReplaced(ServletRequestAttributeEvent sra) &#123; String name = sra.getName(); System.out.println(&quot;ServletRequest替换属性：&quot; + name + &quot;=&quot; + sra.getServletRequest().getAttribute(name)); &#125;&#125; 别忘了在web.xml下配置 感知被HttpSession绑定的事件监听器HttpSessionBindingListener 接口 valueBound（）方法public void valueBound(HttpSessionBindingEvent event) valueUnBound()方法public void valueUnbound(HttpSessionBindingEvent event) 统计登录用户]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[春雏集：看见花落也凋零]]></title>
      <url>%2F2017%2F03%2F01%2F%E6%98%A5%E9%9B%8F%E9%9B%86%EF%BC%9A%E7%9C%8B%E8%A7%81%E8%8A%B1%E8%90%BD%E4%B9%9F%E5%87%8B%E9%9B%B6%2F</url>
      <content type="text"><![CDATA[春雏集：看见花落也凋零 看见花落也凋零。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[javaee上课笔记:DBUtils工具]]></title>
      <url>%2F2017%2F03%2F01%2Fjavaee%E4%B8%8A%E8%AF%BE%E7%AC%94%E8%AE%B0-DBUtils%E5%B7%A5%E5%85%B7%2F</url>
      <content type="text"><![CDATA[javaee上课笔记:DBUtils工具学习目标 了解DBUtils工具中的api 学会使用DBUtils工具对数据库进行增删改查的操作 学会使用DBUtils工具处理事务点我下载DBUtils API介绍核心类 &amp; 接口 类 org.apache.commons.dbutils.DbUtils org.apache.commons.dbutils.QueryRunner 接口 org.apache.commons.dbutils.ResultSetHandler DBUtils 类 DBUtils类 主要为如何关闭，装载JDBC驱动程序之类的常规工作提供方法，它提供的方法都是静态方法， 1.close() 方法关闭数据库连接 2.closeQuietly(Connection con,Statement stmt,ResultSet rs) 方法该方法用来关闭Connection，Statement和ResultSet对象。还会隐藏一些在程序中抛出的sql异常 3.commitAndCloseQuiely(Connection con)该方法用来提交连接，然后关闭连接， 且在关闭时不抛出sql异常 4.LoadDrive（java.lang.String driverClassName）该方法用于装载jdbc驱动程序，如果成功返回true。使用时，不需要捕捉ClassNotFoundException异常 QueryRunner 类该类简化了执行sql语句的代码，它与ResultSetHandler 组合在一起，能完成大部分的数据库操作，大大减少编码量。提供了两个构造方法：1.默认的构造方法2.需要javax.sql.DataSource 作为参数 1.query(Connection conn,String sql,ResultSetHandler rsh,Object[] params) 方法该方法用于执行查询操作参数params表示一个对象数组，该数组中每个元素都被用来作为查询语句的置换参数注意：该方法会自动处理PrepareSatement 和 ResultSet的创建和关闭 2.query(String sql,ResultSetHandler rsh,Object[] params)方法该方法用于执行查询操作，与第一个方法相比它不需要传递Connection对象给方法，它可以从提供给构造方法的数据源DateSource或使用setDateSource()中获得连接。 3.query(Connection conn，String sql,ResultSetHandler rsh)方法该方法用于执一个不需要置换参数的查询操作 4.update(Connection conn，String sql,Object[] params)方法该方法用来执行插入、更新或者删除操作，其中，参数params 表示SQL语句中的置换参数。 5.update(Connection conn,String sql) 方法该方法用于执行插入、更新或者删操作，它需要置换参数操作。 ## ResultSetHandler 接口 该接口用于处理ResultSet结果集，它可以将结果集中的数据转化为不同的形式。根据结果集中数据类型的不同，ResultHandler提供了不同的实现类。如下： 1.AbstractKeyedHandler:该类为抽象类，能够把结果集里面的数据转换为用Map存储。 2.AbstractListHandler：该类为抽象类，—如上—-转换为用List存储。 3.ArrayHandler：把结果集中的第一行数据转成数据对象数组 4.ArrayListHandler：把结果集中的每一行数据转成一个对象数组，再将数组存放到List中。 5.BaseResultSetHandler：把结果集转换成其他对象的扩展。 6.BeanHandler :将结果集中的第一行数据封到一个对应的JavaBean实例中。 7.BeanListHandler：将结果集中的每一行数据都封装到一个对应的 JavaBean实例中，存放到list中 8.BeanMapHandler：结果集中的每一行数据都封装到一个对应的 JavaBean实例中，然后在根据指定的key把每个JavaBean在存放到一个Map里 9.ColumnListHandler：将结果集中某一列的数据存放到List中 10.将结果集中的每一行数据封装到一个map里，然后在根据指定的key把每个MAp在存放到一个map里。 11.MapHandler：将结集中的每一行数据封装到一个map里。可以是列名，value是对应的值。 12.MapListHandler：将结果集中的每一行数据封装到一个Map中，然后在存放到list中 13.ScalarHandler：将结果集中的某一条记录的其中某一列的数据存储成Object对象 另外，在ResultSetHandler接口中，提供了一个单独的方法handle（java.sql.ResultSet rs）,如果上述实现类没有提供想要的功能，可以通过自定义一个实现ResultSetHandler接口的类，然后重写handel()方法，实现结果集的处理。 代码实现ArrayHandler 和 ArrayListHandler 12345678public static void testArrayHandler() throws SQLException&#123; BaseDao beseDao = new BaseDao(); String sql = &quot;select * from NEWSINFO where nid=?&quot;; Object[] arr = (Object[]) BaseDao.query(sql, new ArrayHandler(), new Object[]&#123;50&#125;); for(int i=0;i&lt;arr.length;i++)&#123; System.out.println(arr[i]+&quot;,&quot;); &#125; 实现步骤 1.创建QueryRunner对象 （配置了C3p0数据池，参数获取数据源） QueryRunner runner = new QueryRunner（C3p0Utils.getDateSource（）） 2.编写Sql语句 String sql = &quot;&quot; 3.调用QueryRunner中的方法 runner.query() runner.update() 参数参考上面 DBUtils 处理事务 创建JDBCUtils,该类封装了创建连接，开启事务，关闭事务等方法 需要注意的是，请求中的一个事务涉及到了多个数据库操作，如果这些Connection是 从连接池中获取的，两个DAO操作就用到了两个Connection，这样是没办法完成一个事务的， 所以，需要借助ThreadLoacl类。 ThreadLoacl类的作用是在一个线程里记录变量。可以生成一个连接放在这个线程中， 只要是这个线程中的任何对象都可以共享这个连接，当线程结束后就删除这个连接，这样， 就保证了一个事务，一个连接。直接上代码:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package party.lvc.jdbc.utils;import java.sql.Connection;import java.sql.SQLException;import javax.sql.DataSource;import com.mchange.v2.c3p0.ComboPooledDataSource;public class JDBCUtils &#123; // 创建一个ThreadLocal 对象，以当前线程作为key private static ThreadLocal&lt;Connection&gt; threadLocal = new ThreadLocal&lt;Connection&gt;(); // 从c3p0-config.xml配置文件中读取默认的数据库配置，生成c3p0数据源 private static DataSource ds = new ComboPooledDataSource(); // 返回数据源对象 public static DataSource getDataSource() &#123; return ds; &#125; // 获取c3p0数据库连接池中的连接对象 public static Connection getConnection() throws SQLException &#123; Connection conn = threadLocal.get(); if (conn == null) &#123; conn = ds.getConnection(); threadLocal.set(conn); &#125; return conn; &#125; // 开启事务 public static void startTransaction() &#123; try &#123; // 获得链接 Connection conn = getConnection(); // 开启事务 conn.setAutoCommit(false); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; // 提交事务 public static void commit() &#123; try &#123; // 获得链接 Connection conn = threadLocal.get(); // 提交事务 if (conn != null) conn.commit(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; // 回滚事务 public static void rollback() &#123; try &#123; // 获得链接 Connection conn = threadLocal.get(); // 回滚事务 if (conn != null) conn.rollback(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; // 关闭数据库连接，释放资源 public static void close() &#123; // 获得链接 Connection conn = threadLocal.get(); // 关闭事务 if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; // 从集合中移除当前绑定的连接 threadLocal.remove(); conn = null; &#125; &#125; &#125;&#125; 事务的实现。通过银行转账业务，来举个栗子。创建Business，该类包括了转账过程的逻辑方法。1234567891011121314151617181920212223242526272829303132333435363738394041package party.lvc.example;import java.sql.SQLException;import cn.itcast.jdbc.example.dao.AccountDao;import cn.itcast.jdbc.example.domain.Account;import cn.itcast.jdbc.utils.JDBCUtils;public class Business &#123; public static void transfer(String sourceAccountName, String toAccountName, float money) &#123; try &#123; // 开启事务 JDBCUtils.startTransaction(); // 根据用户名查询数据并存入实体类对象中 AccountDao dao = new AccountDao(); Account accountfrom = dao.find(sourceAccountName); Account accountto = dao.find(toAccountName); // 完成转账操作 if(money&lt;accountfrom.getMoney())&#123; accountfrom.setMoney(accountfrom.getMoney()-money); &#125;else&#123; System.out.println(&quot;转出账户余额不足&quot;); &#125; accountto.setMoney(accountto.getMoney()+money); dao.update(accountfrom); dao.update(accountto); // 提交事务 JDBCUtils.commit(); System.out.println(&quot;提交成功&quot;); &#125; catch (SQLException e) &#123; System.out.println(&quot;提交失败&quot;); JDBCUtils.rollback(); e.printStackTrace(); &#125; finally &#123; // 关闭事务 JDBCUtils.close(); &#125; &#125; public static void main(String[] args) throws SQLException &#123; // 调用方法，实现a向b转账200元操作 transfer(&quot;a&quot;, &quot;b&quot;, 200); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android上课笔记-快速入门]]></title>
      <url>%2F2017%2F02%2F25%2FAndroid%E4%B8%8A%E8%AF%BE%E7%AC%94%E8%AE%B0-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%2F</url>
      <content type="text"><![CDATA[Android项目的目录结构 Activity：应用被打开时显示的界面 src：项目代码 R.java：项目中所有资源文件的资源id Android.jar：Android的jar包，导入此包方可使用Android的api libs：导入第三方jar包 assets：存放资源文件，比方说mp3、视频文件 bin：存放编译打包后的文件 res：存放资源文件，存放在此文件夹下的所有资源文件都会生成资源id drawable：存放图片资源 layout：存放布局文件，把布局文件通过资源id指定给activity，界面就会显示出该布局文件定义的布局 menu：定义菜单的样式 Strings.xml：存放字符串资源，每个资源都会有一个资源id Android的配置文件（清单文件） 指定应用的包名 package=”com.itheima.helloworld”data/data/com.itheima.helloworld(上面代码指定的包名)应用生成的文件都会存放在此路径下 Android的四大组件在使用前全部需要在清单文件中配置 的配置对整个应用生效 的配置对该activity生效DDMS Dalvik debug monitor service Dalvik调试监控服务 常用的adb指令Android debug bridge：安卓调试桥 adb start-server:启动adb进程 adb kill-server：杀死adb进程 adb devices：查看当前与开发环境连接的设备，此命令也可以启动adb进程 adb install XXX.apk：往模拟器安装apk adb uninstall 包名：删除模拟器中的应用 adb shell:进入linux命令行 ps：查看运行进程 ls：查看当前目录下的文件结构 netstat -ano：查看占用端口的进程电话拨号器 功能：用户输入一个号码，点击拨打按钮，启动系统打电话的应用把号码拨打出去 1. 定义布局 组件必须设置宽高，否则不能通过编译 12android:layout_width=&quot;wrap_content&quot;android:layout_height=&quot;wrap_content&quot; 如果要在java代码中操作某个组件，则组件需要设置id，这样才能在代码中通过id拿到这个组件 android:id=&quot;@+id/et_phone&quot; 2. 给按钮设置点击侦听 给按钮设置侦听1234 //通过id拿到按钮对象Button bt_call = (Button) findViewById(R.id.bt_call);//给按钮设置点击bt_call.setOnClickListener(new MyListener()); 3. 得到用户输入的号码123//得到用户输入的号码，先拿到输入框组件EditText et_phone = (EditText) findViewById(R.id.et_phone);String phone = et_phone.getText().toString(); 4. 把号码打出去 Android系统中基于动作机制，来调用系统的应用，你告诉系统你想做什么动作，系统就会把能做这个动作的应用给你，如果没有这个应用，会抛异常 设置动作，通过意图告知系统12345678//把号码打出去 //先创建一个意图对象 Intent intent = new Intent(); //设置动作，打电话 intent.setAction(Intent.ACTION_CALL); intent.setData(Uri.parse(&quot;tel:&quot; + phone)); //把意图告诉系统 startActivity(intent); 添加权限 &lt;uses-permission android:name=&quot;android.permission.CALL_PHONE&quot;/&gt; 点击事件的四种写法第一种 定义一个MyListener实现onClickListener接口 12Button bt1 = (Button) findViewById(R.id.bt1);bt1.setOnClickListener(new MyListener()); 第二种 定义一个匿名内部类实现onClickListener接口 123456789Button bt2 = (Button) findViewById(R.id.bt2);bt2.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; System.out.println(&quot;第二种&quot;); &#125;&#125;); 第三种 让当前activity实现onClickListener接口 12Button bt3 = (Button) findViewById(R.id.bt3);bt3.setOnClickListener(this); 第四种 给Button节点设置onClick属性， android:onClick=&quot;click&quot; 然后在activity中定义跟该属性值同名的方法 123public void click(View v)&#123; System.out.println(&quot;第四种&quot;);&#125; 短信发送器 功能：用户输入号码和短信内容，点击发送按钮，调用短信api把短信发送给指定号码 1. 定义布局 输入框的提示android:hint=&quot;请输入号码&quot; 2. 完成点击事件 先给Button组件设置onClick属性onClick=&quot;send&quot; 在Activity中定义此方法public void send(View v){} 3. 获取到用户输入的号码和内容1234EditText et_phone = (EditText) findViewById(R.id.et_phone);EditText et_content = (EditText) findViewById(R.id.et_content);String phone = et_phone.getText().toString();String content = et_content.getText().toString(); 4. 调用发送短信的api12345//调用发送短信的apiSmsManager sm = SmsManager.getDefault();//发送短信sm.sendTextMessage(phone, null, content, null, null); 添加权限 1&lt;uses-permission android:name=&quot;android.permission.SEND_SMS&quot;/&gt; 如果短信过长，需要拆分List&lt;String&gt; smss = sm.divideMessage(content);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[android笔记-Drawable]]></title>
      <url>%2F2017%2F02%2F24%2Fandroid%E7%AC%94%E8%AE%B0-Drawable%2F</url>
      <content type="text"><![CDATA[Android 的 Drawable Drawable 表示的是一中可以在Canvas上进行绘制的抽象概念，它的种类很多，最常见的颜色和 图片度可以是一个Drawable。 Drawable一般都是通过XML定义的，也可以使用代码来创建。 Drawable的分类BitmapDrawable 几乎是是最简单的Drawable，它就是表示一张图片。 xml文件， 属性123456789android:antialias 抗锯齿 android:dither 抖动效果 android:filter 过滤效果android:gravity 对图片进行定位，当图片小于容器时。android:mipMap android:src android:tileMode 平铺模式 disabled 、clamp、reapt 、mirrorandroid:tileModeXandroid:tileModeY ShapeDrawable 形状的Drawable咯,定义基本的几何图形,如(矩形,圆形,线条等),根元素是 节点比较多，相关的节点如下： ① shape: ~ visible:设置是否可见 ~ shape:形状,可选:rectangle(矩形,包括正方形),oval(椭圆,包括圆),line(线段),ring(环形) ~ innerRadiusRatio:当shape为ring才有效,表示环内半径所占半径的比率,如果设置了innerRadius, 他会被忽略 ~ innerRadius:当shape为ring才有效,表示环的内半径的尺寸 ~ thicknessRatio:当shape为ring才有效,表环厚度占半径的比率 ~ thickness:当shape为ring才有效,表示环的厚度,即外半径与内半径的差 ~ useLevel:当shape为ring才有效,表示是否允许根据level来显示环的一部分 ② size ~ width:图形形状宽度 ~ height:图形形状高度 ③ &lt;gradient 》 后面GradientDrawable再讲~ ④ solid ~ color:背景填充色,设置solid后会覆盖gradient设置的所有效果!!!!!! ⑤ stroke ~ width:边框的宽度 ~ color:边框的颜色 ~ dashWidth:边框虚线段的长度 ~ dashGap:边框的虚线段的间距 ⑥ conner ~ radius:圆角半径,适用于上下左右四个角 ~ topLeftRadius,topRightRadius,BottomLeftRadius,tBottomRightRadius: 依次是左上,右上,左下,右下的圆角值,按自己需要设置! ⑦ padding left,top,right,bottm:依次是左上右下方向上的边距! LayerDrawableStateListDrawable属性： drawable:引用的Drawable位图,我们可以把他放到最前面,就表示组件的正常状态~ state_focused:是否获得焦点 state_window_focused:是否获得窗口焦点 state_enabled:控件是否可用 state_checkable:控件可否被勾选,eg:checkbox state_checked:控件是否被勾选 state_selected:控件是否被选择,针对有滚轮的情况 state_pressed:控件是否被按下 state_active:控件是否处于活动状态,eg:slidingTab state_single:控件包含多个子控件时,确定是否只显示一个子控件 state_first:控件包含多个子控件时,确定第一个子控件是否处于显示状态 state_middle:控件包含多个子控件时,确定中间一个子控件是否处于显示状态 state_last:控件包含多个子控件时,确定最后一个子控件是否处于显示状态 LeveListDrawableTransitionDrawablwInsetDrawableScaleDrawableclipDrawable自定义Drawable]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[春雏集:优雅的活着]]></title>
      <url>%2F2017%2F02%2F22%2F%E6%98%A5%E9%9B%8F%E9%9B%86-%E4%BC%98%E9%9B%85%E7%9A%84%E6%B4%BB%E7%9D%80%2F</url>
      <content type="text"><![CDATA[春雏集:优雅的活着 我和丽丽有相同的观点就是，优雅的活着 每天一句早安，每天一句晚安，相逢总是思念。 她想优雅的活着，我想优雅的陪她，陪伴每个366天，多一天都是值得。 那一天，在回寝室的路上，抬头看落叶的飘零，不知为何，又想起了优雅的活着，优雅的生活，心中的那个念头，牵扯了感触。 今天给她分享了，李宗盛的《山丘》，她说，看不懂。其实很简单，我想，越过每一个山丘，然后陪你。 越发想念的越是醉人的，迷蒙的夜色神游的我俩。 晚安，亲爱的丽丽!我想陪你，过优雅的日子。 我希望有个如你一般的人如山间清爽的风如古城温暖的光从清晨到夜晚由山野到书房只要最后是你就好 ——张嘉佳 《从你的全世界路过》]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android上课笔记-第一课]]></title>
      <url>%2F2017%2F02%2F20%2FAndroid%E4%B8%8A%E8%AF%BE%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E8%AF%BE%2F</url>
      <content type="text"><![CDATA[Android 简介 通信技术 Android 起源 Android 体系架构 Dalvik 虚拟机Dalvik 包含了一整套的Android运行环境虚拟机，每个app都会分配Dalvik虚拟机来保证相互之间不收干扰，并不保持独立。它的特点是在运行时编译。 ART采用的是安装时就进行编译。 克服瓶颈期的最好办好就是六个字–总结 、归纳、演绎。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[javaweb实战：网上书城]]></title>
      <url>%2F2017%2F02%2F20%2Fjavaweb%E5%AE%9E%E6%88%98%EF%BC%9A%E7%BD%91%E4%B8%8A%E4%B9%A6%E5%9F%8E%2F</url>
      <content type="text"><![CDATA[javawe实战：网上书城 前台项目概述需求分析 1.统一友好的操作界面，具有良好的用户体验。 2.商品分类详尽，可按不同类别查看商品信息。 3.公告栏，本周热卖。 4.网站首页轮播图满足图书广告的需要。 5.用户信息的注册和验证。 6.通过图书名模糊搜索相关商品。 7.通过购物车一次购买多件商品。 8.提供简单的安全模型，用户必须登录后购买商品。 9.用户选择商品后可以在线提交订单。 10.用户可以查看自己的订单信息。 11.设计网站后台，管理网站的各项基本数据. 12.系统运行安全稳定且响应及时。 功能结构 项目预览数据库设计E-R图设计创建数据库和数据表项目前期准备 1.新建一个动态的web项目，名称为BooKStore 2.确定项目运行的环境版本 网上书城项目使用数据库MYSQL5.7版本，Java开发包为1.8 ，开发IDE MyEclipse 2016 3.将本项目所需jar包导入项目的lib文件下。 a.本项目使用c3p0数据源链接数据库，需要c3p0的jar包。 b.项目的jsp页面使用了JSTL标签库，需要jstl.jar和 standard.jar包。 c.项目中使用DBUtils工具处理数据的持久化操作，需要导入BeanUtils工具包。 d.由于在注册时系统还会给注册用户填写的邮箱发送一封激活码，需要导入mail.jar包。 本项目所需jar包如图所示： 4.配置c3p0-config.xml。 在项目Src根目录下创建该文件夹 配置如图所示： 5.编写filter过滤器 a.防止项目请求和响应时出现的乱码情况，需要编写一个过滤器 EcondingFilter.java 来统一全站编码， b.由于本项目分为前后台，只有超级用户才能登陆后台管理系统，所以在用户登录时需要 一个能够判断当前用户是否具有权限登录后台的过滤器，AdminPrivilegeFilter.java 编写工具类DataSourceUtils该类用于获取数据源和数据库的链接 用户注册和登录模块用户注册用户登录购物车模块模块描述实现购物车的基本功能实现订单的相关功能图书信息查询模块商品分类导航栏搜索功能公告板和本周热卖前台小结javawe实战：网上书城 后端管理后台管理系统概述商品管理模块商品管理模块简介实现查询商品列表功能实现添加商品信息功能实现编辑商品信息功能实现删除商品信息功能销售榜单模块订单管理模块订单管理模块简介实现查询订单列表功能实现查看订单详情功能实现删除订单功能后台小结]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[开学笔记]]></title>
      <url>%2F2017%2F02%2F20%2F%E5%BC%80%E5%AD%A6%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[语录 javaEE开学第一课 学习项目开发 项目框架非常的熟 业务走向，业务开发能力 学习要达到精通水平，是为了就业 学习三大框架ssh，只是学习了 编程的魅力，今天你学习了这个知识，过一段时间回过头来，一定会有全新的体验，不同的理解总结：温故而知新 荒唐的背后是什么 看小说，收到小说的的毒害。打架之后面的东西，是勇气。 总结：什么都懂一点，但是不深奥。寻求本质！ 基于MVC开发模式 课程计划–javaweb程序开发进阶 传智播客 jsp进阶 为期 10周 过滤器 监听器 EL表达式 JSP标签库 数据池 文件上传与下载 收现金开发一个 学习的本质，just with youself 新打算 以后将在此记录上课笔记，仅当记录那些年我们学过的 Hello World！ lvc唯爱]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[春雏集-三月花]]></title>
      <url>%2F2017%2F02%2F10%2F%E6%98%A5%E9%9B%8F%E9%9B%86-%E4%B8%89%E6%9C%88%E8%8A%B1%2F</url>
      <content type="text"><![CDATA[三月花二月的小城沾酒的夜色有些隐晦，暖冬的天气有些燥热，燥动的不安是二月的酒气。 盘着白雾的悬梁木板，是二月老人家的烟火，干烈的柴火是温暖的老宅。 二月的小城，我的家，几处青青，三月的花。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[android笔记-Android文件下载]]></title>
      <url>%2F2017%2F02%2F09%2Fandroid%E7%AC%94%E8%AE%B0-Android%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%2F</url>
      <content type="text"><![CDATA[android笔记-Android文件下载单线程下载效果展示： 主要过程：1.新建DownloadLinstener接口2.新建DoadloadTask继承AsycnTak3.新建DownloadService 继承service4.UI和Mainactivity实现 代码 DownloadLinstener接口实现* 1234567891011121314public interface DownloadListener &#123; void onProgress(int progress); void onSuccess(); void onFailed(); void onPaused(); void onCanceled();&#125; DownloadTask实现 * 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176package com.lvc.downloaddemo;import android.os.AsyncTask;import android.os.Environment;import java.io.File;import java.io.IOException;import java.io.InputStream;import java.io.RandomAccessFile;import okhttp3.OkHttpClient;import okhttp3.Request;import okhttp3.Response;/** * Created by lvc on 2017/2/9. */public class DownloadTask extends AsyncTask&lt;String ,Integer ,Integer&gt; &#123; // 下载常量 标识状态 public static final int TYPE_SUCCESS = 0; public static final int TYPE_FAILED = 1; public static final int TYPE_PAUSED = 2; public static final int TYPE_CANCELED = 3; private DownloadListener listener; private Boolean isPaused =false; private Boolean isCanceled = false; private int lastProgress; public DownloadTask(DownloadListener listener) &#123; this.listener = listener; &#125; // 后台执行的下载逻辑 @Override protected Integer doInBackground(String... params) &#123; InputStream in = null; RandomAccessFile savedFile = null; File file = null; try &#123; long downloadLength = 0; String downloadUrl = params[0]; String fileName = downloadUrl.substring(downloadUrl.lastIndexOf(&quot;/&quot;)); String directory = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS).getPath(); file = new File(directory+fileName); if (file.exists())&#123; downloadLength = file.length(); &#125; long contentLength = getContentLength(downloadUrl); if (contentLength == 0)&#123; return TYPE_FAILED; &#125;else if (contentLength == downloadLength)&#123; return TYPE_SUCCESS; &#125; OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder() //断点下载 .addHeader(&quot;RANGE&quot;, &quot;bytes=&quot; + downloadLength + &quot;-&quot;) .url(downloadUrl) .build(); Response response = client.newCall(request).execute(); if (response != null)&#123; in = response.body().byteStream(); savedFile = new RandomAccessFile(file,&quot;rw&quot;); savedFile.seek(downloadLength); byte[] b = new byte[1024]; int total =0; int len ; while ((len = in.read(b)) != -1)&#123; if (isCanceled)&#123; return TYPE_CANCELED; &#125; else if(isPaused)&#123; return TYPE_PAUSED; &#125; else&#123; total += len; savedFile.write(b,0,len); // 计算下载的百分比 int progress = (int)((total+downloadLength)*100 / contentLength); publishProgress(progress); &#125; &#125; response.body().close(); return TYPE_SUCCESS; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; if(in != null)&#123; try &#123; in.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; if(savedFile != null)&#123; try &#123; savedFile.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (isCanceled &amp;&amp; file != null)&#123; file.delete(); &#125; return TYPE_FAILED; &#125; // 更新 下载进度 @Override protected void onProgressUpdate(Integer... values) &#123; int progress = values[0]; if(progress &gt; lastProgress)&#123; listener.onProgress(progress); lastProgress = progress; &#125; &#125; //最终下载的结果 @Override protected void onPostExecute(Integer status) &#123; //super.onPostExecute(status); switch (status) &#123; case TYPE_SUCCESS: listener.onSuccess(); break; case TYPE_FAILED: listener.onFailed(); break; case TYPE_PAUSED: listener.onPaused(); break; case TYPE_CANCELED: listener.onCanceled(); default: break; &#125; &#125; private long getContentLength(String downloadUrl) throws IOException &#123; OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder() .url(downloadUrl) .build(); Response response = client.newCall(request).execute(); if (response != null &amp;&amp; response.isSuccessful())&#123; long contentlength = response.body().contentLength(); response.close(); return contentlength; &#125; return 0; &#125; public void pausedDownload()&#123; isPaused = true; &#125; public void canceledDownlod()&#123; isCanceled = true; &#125;&#125; DwonloadService实现* 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143package com.lvc.downloaddemo;import android.app.Notification;import android.app.NotificationManager;import android.app.PendingIntent;import android.app.Service;import android.content.Intent;import android.graphics.BitmapFactory;import android.os.Binder;import android.os.Environment;import android.os.IBinder;import android.support.v4.app.NotificationCompat;import android.util.Log;import android.widget.Toast;import java.io.File;public class DownloadService extends Service &#123; private DownloadTask downloadTask ; private String downloadUrl = null; int i = 0; private DownloadListener listener = new DownloadListener() &#123; @Override public void onProgress(int progress) &#123; getNotificationManager().notify(1,getNotification(&quot;正在下载...&quot;,progress)); &#125; @Override public void onSuccess() &#123; downloadTask = null; // 下载成功时将前台服务通知关闭，并创建一个下载成功的通知 stopForeground(true); getNotificationManager().notify(1, getNotification(&quot;Download Success&quot;, -1)); Toast.makeText(DownloadService.this, &quot;Download Success&quot;, Toast.LENGTH_SHORT).show(); &#125; @Override public void onFailed() &#123; downloadTask = null; // 下载失败时将前台服务通知关闭，并创建一个下载失败的通知 stopForeground(true); getNotificationManager().notify(1, getNotification(&quot;Download Failed&quot;, -1)); Toast.makeText(DownloadService.this, &quot;Download Failed&quot;, Toast.LENGTH_SHORT).show(); &#125; @Override public void onPaused() &#123; downloadTask = null; Toast.makeText(DownloadService.this, &quot;Paused&quot;, Toast.LENGTH_SHORT).show(); &#125; @Override public void onCanceled() &#123; downloadTask = null; stopForeground(true); Toast.makeText(DownloadService.this, &quot;Canceled&quot;, Toast.LENGTH_SHORT).show(); &#125; &#125; ; private DownloadBinder mBinder =new DownloadBinder(); /* public DownloadService() &#123; &#125;*/ @Override public IBinder onBind(Intent intent) &#123; return mBinder; &#125; class DownloadBinder extends Binder&#123; public void startDownload(String url)&#123; if(downloadUrl == null)&#123; downloadUrl =url; downloadTask = new DownloadTask(listener); downloadTask.execute(downloadUrl); startForeground(1,getNotification(&quot;正在下载...&quot;,0)); Log.i(&quot;判断点击次数&quot;, &quot;startDownload: &quot;+i); i++; Toast.makeText(DownloadService.this, &quot;正在下载...&quot;, Toast.LENGTH_SHORT).show(); &#125; &#125; public void pauseDownload()&#123; if(downloadTask !=null)&#123; downloadTask.pausedDownload(); &#125; &#125; public void cancelDownload()&#123; if(downloadTask != null)&#123; downloadTask.canceledDownlod(); &#125;else&#123; if(downloadUrl != null)&#123; //取消下载时需要将文件删除，并通知关闭 String fileName = downloadUrl.substring(downloadUrl.lastIndexOf(&quot;/&quot;)); String directory = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS).getPath(); File file = new File(directory + fileName); if(file.exists())&#123; file.delete(); &#125; getNotificationManager().cancel(1); stopForeground(true); Toast.makeText(DownloadService.this, &quot;Canceled&quot;, Toast.LENGTH_SHORT).show(); &#125; &#125; &#125; &#125; // 获取通知管理器 private NotificationManager getNotificationManager()&#123; return (NotificationManager) getSystemService(NOTIFICATION_SERVICE); &#125; //通知详情 private Notification getNotification(String title,int progress)&#123; // Intent intent = new Intent(this,MainActivity.class); // PendingIntent pi = PendingIntent.getActivities(this,0,new Intent[]&#123;intent&#125;,0); Intent intent = new Intent(this, MainActivity.class); PendingIntent pi = PendingIntent.getActivity(this, 0, intent, 0); NotificationCompat.Builder builder = new NotificationCompat.Builder(this); builder.setSmallIcon(R.mipmap.ic_launcher); builder.setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher)); builder.setContentIntent(pi); builder.setContentTitle(title); if(progress &gt;= 0)&#123; builder.setContentText(progress + &quot;%&quot;); builder.setProgress(100,progress,false); &#125; return builder.build(); &#125;&#125; Mainactivity实现 UI布局简单就不贴了* 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394package com.lvc.downloaddemo;import android.Manifest;import android.content.ComponentName;import android.content.Intent;import android.content.ServiceConnection;import android.content.pm.PackageManager;import android.os.IBinder;import android.support.annotation.NonNull;import android.support.v4.app.ActivityCompat;import android.support.v4.content.ContextCompat;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.Toast;public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; private DownloadService.DownloadBinder downloadBinder; private ServiceConnection connection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName componentName, IBinder iBinder) &#123; downloadBinder = (DownloadService.DownloadBinder) iBinder; &#125; @Override public void onServiceDisconnected(ComponentName componentName) &#123; &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button startDownload = (Button) findViewById(R.id.btn_start); Button pauseDownload = (Button) findViewById(R.id.btn_paused); Button cancelDownload = (Button) findViewById(R.id.btn_cancel); startDownload.setOnClickListener(this); pauseDownload.setOnClickListener(this); cancelDownload.setOnClickListener(this); Intent intent = new Intent(this,DownloadService.class); startService(intent); bindService(intent,connection,BIND_AUTO_CREATE); if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) &#123; ActivityCompat.requestPermissions(MainActivity.this, new String[]&#123; Manifest.permission. WRITE_EXTERNAL_STORAGE &#125;, 1); &#125; &#125; @Override public void onClick(View view) &#123; if (downloadBinder == null) &#123; return; &#125; switch (view.getId()) &#123; case R.id.btn_start: String url = &quot;http://www.runoob.com/wp-content/uploads/2015/09/DownLoadDemo1.zip&quot;; downloadBinder.startDownload(url); break; case R.id.btn_paused: downloadBinder.pauseDownload(); break; case R.id.btn_cancel: downloadBinder.cancelDownload(); break; default: break; &#125; &#125; @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; switch (requestCode) &#123; case 1: if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] != PackageManager.PERMISSION_GRANTED) &#123; Toast.makeText(this, &quot;拒绝权限将无法使用程序&quot;, Toast.LENGTH_SHORT).show(); finish(); &#125; break; default: &#125; &#125; @Override protected void onDestroy() &#123; super.onDestroy(); unbindService(connection); &#125;&#125; 多线程下载 多线程的下载流程 获取网络连接 本地磁盘创建相同大小的空文件 计算每条线程需从文件哪个部分开始下载，结束 依次创建，启动多条线程来下载网络资源的指定部分 核心代码：12]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[android笔记-HttpURLConnection]]></title>
      <url>%2F2017%2F02%2F07%2Fandroid%E7%AC%94%E8%AE%B0-HttpURLConnection%2F</url>
      <content type="text"><![CDATA[android笔记-HttpURLConnection报错 调用InputStream in = connection.getErrorStream(); 报错 主要代码 使用okhttp直接上代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788package com.lvc.nnetworktest.util;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.net.HttpURLConnection;import java.net.URL;import okhttp3.OkHttpClient;import okhttp3.Request;import okhttp3.Response;/** * Created by lvc on 2017/2/7. * 网络请求util * 封装了 httpURLConnection &amp; okhttp3 */public class HtppUtil &#123; public static void sendHttpRequest(final String address,final HttpCallbackListener listener)&#123; new Thread(new Runnable() &#123; @Override public void run() &#123; HttpURLConnection connection = null; //InputStream in =null; try &#123; URL url = new URL(address); connection = (HttpURLConnection) url.openConnection(); connection.setRequestMethod(&quot;GET&quot;); connection.setConnectTimeout(8000); connection.setReadTimeout(8000); connection.setDoInput(true); connection.setDoOutput(true); InputStream in = connection.getErrorStream(); BufferedReader reader = new BufferedReader(new InputStreamReader(in)); StringBuilder response = new StringBuilder(); String line; while((line =reader.readLine())!=null)&#123; response.append(line); &#125; if(listener != null)&#123; listener.onFinish(response.toString()); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); if(listener != null)&#123; listener.onError(e); &#125; &#125;finally &#123; if(connection != null)&#123; connection.disconnect(); &#125; /* if (in != null)&#123; try &#123; in.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;*/ &#125; &#125; &#125;).start(); &#125; public interface HttpCallbackListener&#123; void onFinish(String response); void onError(Exception e); &#125; /** * okhttp3 */ public static void sendOkhttpRequest(String address , okhttp3.Callback callback)&#123; OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder() .url(address) .build(); client.newCall(request).enqueue(callback); //调用回调 &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[闲言碎语-西游降魔篇]]></title>
      <url>%2F2017%2F02%2F06%2F%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD-%E8%A5%BF%E6%B8%B8%E9%99%8D%E9%AD%94%E7%AF%87%2F</url>
      <content type="text"><![CDATA[西游真的是那个西游吗许久不见，或许是一种情怀！可这又有什么关系呢？佛是什么？你又是什么？我又是什么？西游真的是西游吗？22部天竺真经真的能普度众生吗？度的人，应该是他自己吧。 一生所爱 是被用坏了的情怀吗？终究你我将不复存在关于执念你我懂多少不同的人有不同世界一生真的能爱个够吗陈先生历经千辛万苦只寻普度众生的良药可是大爱小爱说不清道不明在制服猪刚鬣的之时孙先生出了一个法子在月圆之夜，绝山之巅段小姐翩然起舞，宛若谪仙，人间不应有一生所爱的歌声，纵然是情怀作祟。 我的西游我希望寻找自己的西游之路，不为普度众生只为度我自己。西游终究是被烙印在骨子里，流淌的血液在轰轰的燃烧着，可是红尘真的有 真 善 美 ？愿意相信的谎言，我愿意，那就有。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[android笔记-调用摄像头相册]]></title>
      <url>%2F2017%2F02%2F06%2Fandroid%E7%AC%94%E8%AE%B0-%E8%B0%83%E7%94%A8%E6%91%84%E5%83%8F%E5%A4%B4%E7%9B%B8%E5%86%8C%2F</url>
      <content type="text"><![CDATA[调用摄像头调用摄像头拍照获取图片 Demo：效果展示 重要代码123456789101112131415161718192021//创建File 对象，用于存储拍照后的图片File outputImage = new File(getExternalCacheDir(),&quot;output_image.jsp&quot;);try &#123; if(outputImage.exists())&#123; outputImage.delete(); &#125; outputImage.createNewFile();&#125;catch (IOException e)&#123; e.printStackTrace();&#125;if(Build.VERSION.SDK_INT&gt;=24)&#123; imageUri = FileProvider.getUriForFile(MainActivity.this,&quot;com.example.cramea.fileprovider&quot;, outputImage);&#125;else&#123; imageUri = Uri.fromFile(outputImage);&#125;//启动相机程序Intent intent = new Intent(&quot;android.media.action.IMAGE_CAPTURE&quot;);intent.putExtra(MediaStore.EXTRA_OUTPUT,imageUri);startActivityForResult(intent,TAKE_PHOTO); 从相册中选择图片全部代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208package com.lvc.cameraalbumtest;import android.Manifest;import android.annotation.TargetApi;import android.app.Activity;import android.content.ContentUris;import android.content.Intent;import android.content.pm.PackageManager;import android.database.Cursor;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.net.Uri;import android.os.Build;import android.provider.DocumentsContract;import android.provider.MediaStore;import android.support.annotation.NonNull;import android.support.v4.app.ActivityCompat;import android.support.v4.content.ContextCompat;import android.support.v4.content.FileProvider;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.ImageView;import android.widget.Toast;import java.io.File;import java.io.FileNotFoundException;import java.io.IOException;public class MainActivity extends AppCompatActivity &#123; public static final int TAKE_PHOTO = 1; public static final int CHOOSE_PHOTO = 2; private Button takephoto ; private Button choosephoto ; private ImageView pictrue ; private Uri imageUri ; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); /** * 1.获取实例 * 2.绑定监听事件 * */ takephoto = (Button) findViewById(R.id.take_photo); choosephoto = (Button) findViewById(R.id.choose_from_album); pictrue = (ImageView) findViewById(R.id.picture); takephoto.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; //创建File 对象，用于存储拍照后的图片 File outputImage = new File(getExternalCacheDir(),&quot;output_image.jsp&quot;); try &#123; if(outputImage.exists())&#123; outputImage.delete(); &#125; outputImage.createNewFile(); &#125;catch (IOException e)&#123; e.printStackTrace(); &#125; if(Build.VERSION.SDK_INT&gt;=24)&#123; imageUri = FileProvider.getUriForFile(MainActivity.this,&quot;com.example.cramea.fileprovider&quot;, outputImage); &#125;else&#123; imageUri = Uri.fromFile(outputImage); &#125; //启动相机程序 Intent intent = new Intent(&quot;android.media.action.IMAGE_CAPTURE&quot;); intent.putExtra(MediaStore.EXTRA_OUTPUT,imageUri); startActivityForResult(intent,TAKE_PHOTO); &#125; &#125;); choosephoto.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; if(ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED)&#123; ActivityCompat.requestPermissions(MainActivity.this,new String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;,1); &#125;else&#123; openAlbum(); &#125; &#125; &#125;); &#125; /** * */ private void openAlbum()&#123; Intent intent =new Intent(&quot;android.intent.action.GET_CONTENT&quot;); intent.setType(&quot;image/*&quot;); startActivityForResult(intent,CHOOSE_PHOTO); &#125; @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; // super.onActivityResult(requestCode, resultCode, data); switch (requestCode)&#123; case TAKE_PHOTO: try &#123; Bitmap bitmap = BitmapFactory.decodeStream(getContentResolver() .openInputStream(imageUri)); pictrue.setImageBitmap(bitmap); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; break; case CHOOSE_PHOTO: if(resultCode == RESULT_OK )&#123; //判断手机系统版本号 if(Build.VERSION.SDK_INT&gt;=19)&#123; //4.4及以上版本使用这个方法处理图片 handleImageOnKiKat(data); &#125;else&#123; //4.4以下版本使用这个方法处理图片 handleImageBeforeKiKat(data); &#125; &#125; break; default: break; &#125; &#125; private void handleImageBeforeKiKat(Intent data) &#123; Uri uri = data.getData(); String imagepath = getImagePath(uri,null); displayImage(imagepath); &#125; @TargetApi(19) private void handleImageOnKiKat(Intent data) &#123; String imagePath= null; Uri uri = data.getData(); if(DocumentsContract.isDocumentUri(this,uri))&#123; String docId = DocumentsContract.getDocumentId(uri); if(&quot;com.android.providers.media.documents&quot;.equals(uri.getAuthority()))&#123; String id = docId.split(&quot;:&quot;)[1]; String selection = MediaStore.Images.Media._ID+&quot;=&quot;+id; imagePath = getImagePath(MediaStore.Images.Media.EXTERNAL_CONTENT_URI,selection); &#125;else if(&quot;com.android.providers.downloads.documents&quot;.equals(uri.getAuthority()))&#123; Uri contentUri = ContentUris.withAppendedId(Uri.parse(&quot;content://downloads/public_downloads&quot;),Long.valueOf(docId)); imagePath = getImagePath(contentUri,null); &#125; &#125;else if(&quot;content&quot;.equalsIgnoreCase(uri.getScheme()))&#123; imagePath = getImagePath(uri,null); &#125;else if(&quot;file&quot;.equalsIgnoreCase(uri.getScheme()))&#123; imagePath = uri.getPath(); &#125; displayImage(imagePath); &#125; @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; //super.onRequestPermissionsResult(requestCode, permissions, grantResults); switch (requestCode)&#123; case 1: if(grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED )&#123; openAlbum(); &#125;else&#123; Toast.makeText(this,&quot;you denied the permisson&quot;,Toast.LENGTH_SHORT).show(); // openAlbum(); &#125; break; default: break; &#125; &#125; private String getImagePath(Uri uri,String selection)&#123; String path =null; //通过Uri和 selection 来获取真实的图片路径 Cursor cursor = getContentResolver().query(uri,null,selection,null,null); if(cursor != null)&#123; if (cursor.moveToNext())&#123; path = cursor.getString(cursor.getColumnIndex(MediaStore.Images.Media.DATA)); &#125; cursor.close(); &#125; return path; &#125; private void displayImage(String imagePath)&#123; if (imagePath !=null)&#123; Bitmap bitmap = BitmapFactory.decodeFile(imagePath); pictrue.setImageBitmap(bitmap); &#125;else&#123; Toast.makeText(this,&quot;Failed to get image&quot;,Toast.LENGTH_SHORT).show(); &#125; &#125;&#125; 总结 博客真难写想做个记录发现不知道怎么去记汗颜啊]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[android笔记-使用通知]]></title>
      <url>%2F2017%2F02%2F05%2Fandroid%E7%AC%94%E8%AE%B0-%E4%BD%BF%E7%94%A8%E9%80%9A%E7%9F%A5%2F</url>
      <content type="text"><![CDATA[Android笔记-使用通知通知的基本用法 代码 123456789NotificationManager notificationManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE); Notification notification = new NotificationCompat.Builder(this) .setContentTitle(&quot;通知&quot;) .setContentText(&quot;这是一个通知！&quot;) .setWhen(System.currentTimeMillis()) .setSmallIcon(R.mipmap.ic_launcher) .setLargeIcon(BitmapFactory.decodeResource(getResources(),R.mipmap.ic_launcher)) .build(); notificationManager.notify(1,notification); PendingIntent可以简单的理解为延迟执行的Intent pendingIntent 用法1.获取PendingIntent实例： getActivity() getBroadcast() getService() &gt; 以上方法参数相同： * 1 context * 2 0 通常传入0 * 3 Intent对象 * 4 用于确定PendingIntent的行为 有4个值：FLAG_ONE_SHOT FLAG_ON_CREATE FLAG_CANEL_CURRENT FLAG_UPDATE_CURRENT 给通知添加响应 代码12345678910111213Intent intent = new Intent(this,NotificationActivity.class); Intent[] intents = &#123;intent&#125;; PendingIntent pi = PendingIntent.getActivities(this,0,intents,0); NotificationManager notificationManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE); Notification notification = new NotificationCompat.Builder(this) .setContentTitle(&quot;通知&quot;) .setContentText(&quot;这是一个通知！&quot;) .setWhen(System.currentTimeMillis()) .setSmallIcon(R.mipmap.ic_launcher) .setLargeIcon(BitmapFactory.decodeResource(getResources(),R.mipmap.ic_launcher)) .setContentIntent(pi) .build(); notificationManager.notify(1,notification); 取消通知栏上的通知`.setAutoCancel(true)` 在响应的Activity中 添加 1.NotificationManager notificationManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE); 2.notificationManager.cancel(1);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[我的第一篇博客]]></title>
      <url>%2F2017%2F02%2F03%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
      <content type="text"><![CDATA[没有正式文章，仅作为当前内容的测试！ 做个简单的小结昨天在慕课网手记中看到 hexo + github pages 搭建个人博客 经过长时间的学习，再一次觉得开源的伟大! 用了不到一天的时间，杂七杂八的也就成这个样子了 实践才是检验真理的唯一标准 坚持每天学点东西吧。这也算还了我一个小愿望！2017 任重而道远! 下一步，开发一个APP！ ——Lvc]]></content>
    </entry>

    
  
  
</search>
