<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[CET-4:88day 最后的 A 老大]]></title>
      <url>%2F2017%2F03%2F21%2FCET-4-87day-%E6%9C%80%E5%90%8E%E7%9A%84-A-%E8%80%81%E5%A4%A7%2F</url>
      <content type="text"><![CDATA[YOU ARE MAN！你知道凌晨两点钟的南昌吗？下着雨和噼里啪啦的键盘声，此刻，和窗外的雨更配哦。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071architect 建筑师，设计师；缔造者architeture 建筑学；建筑式样，建筑风格argueargument arise 出现；由···引起；起身,起床arithmetic 算术，四则运算arouse 引起；唤起，唤醒arrange 安排，筹备，整理arrangementarrest 逮捕arrival 到达，到来；到达者，到达物arrowartificial 人工的，人为的；矫揉造作的；模拟的artistic 艺术的，艺术家的；富有艺术性的，精美的；精彩的ash 灰，灰末；骨灰ashamedasideaspect 方面；（建筑物的）朝向，方向；样子，外表assemble 集合，召集；装配 (强调为特定目标而聚集)aaccumulate 累积，积聚 (通过有规律的增加而聚集)gather (指把分散的事物聚集在一起)collect (指有计划地为一定目的而有选择的收集)pile 推起，堆叠assembly 立法机构；议会；集合；集会的人们；装配，组装assess 对（财产等）估价；评论，评价asset 资产，财产；有价值的特性或技能，优点assign 指派，分配，布置（作业）；指定（时间，地点等）assignment 任务，指定的作业；分配，指派assist 援助，帮助，协助assistanceassistant 助手，助理，助教；助理的，辅助的associate (在思想上)把···联系在一起；使联合；结合；交往；伙伴，同事；副的association 协会，团体；联合，交往assum 假定，假设，臆断；承担，担任；呈现assumptionassure 使确定；确保，向···保证astonish 使惊讶，使吃惊athlete 运动员，体育家atmosphere 大气，空气；气氛，环境atomic 原子的，原子能的，原子武器的attach 缚，系，贴；附加；使依恋，使喜爱；使嘱咐；认为有（重要，责任等）attackattain 达到，获得，努力attitude 态度，看法；姿势attorney 律师；（业务或法律事务上的）代理人attract 吸引，引起···注意attractionattractiveattribute 把···归因于；属性audienceaudioauthorauthority 官方；权利；当权者。行政管理机构；权威，专家auto 汽车automatic 自动的，机械的；不假思索的，无意识的；必然的，自然的；自动手枪automobile 汽车，机动车auxiliary 辅助的，附属的；后背的available 现成可使用的，通用的；可取的；联系的；可得到的ready 准备就绪的approachable 可靠近的，可接近的probable 很可能的，大概的acceptable 可接受的advisable 可取的；适当的，贤明的avenue 林荫道，道路，大街average 平均数，平均；平均的，平常的avoid 避免，躲开，撤销awaitaward 奖，奖品，判定；授予，给予；判给，裁定awful 令人不愉快的，（感到）难过的 ；非常的，极大的awkward 笨拙的，尴尬的；难操纵的，使用不便的；不灵活的ax 斧子 每天一点语法 代名词1.人称代词 人称代名词的人称及 格（表现） it 的用法 it 可表示天候，时间，地点···等等 It a it 可表示某一状况，多半是说话的人和听的人都能了解知道的特定状况 it 可当假主词 ==&gt; 代替一件事 It is difficult to learn Spanish.(不定词) It’s important that you should tell the truth.（连词）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Struts2框架:项目实战-简单的新闻发布系统]]></title>
      <url>%2F2017%2F03%2F21%2FStruts2%E6%A1%86%E6%9E%B6-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98-%E7%AE%80%E5%8D%95%E7%9A%84%E6%96%B0%E9%97%BB%E5%8F%91%E5%B8%83%E7%B3%BB%E7%BB%9F%2F</url>
      <content type="text"><![CDATA[项目分析技术的可行性本项目采用MVC模式，利用Struts2框架实现MVC。 首先要说的是，mvc是一种架构模式，它是一种思想，而不是一种框架，但是struts2是一种框架，它运用的是mvc思想。。以下是struts2和mvc的一一对应关系：核心控制器：FilterDispatcher FilterDispatcher是Struts2框架的核心控制器，该控制器作为一个Filter运行在Web应用中，它负责拦截所有用户请求，当用户请求到达时，该Filter会过滤用户请求。如果用户请求以.action结尾，该请求将被转入Struts2框架处理。业务控制器组件：用户Action业务控制器组件就是用户实现Action类的实例，Action类里通常包含了一个execute方法，该方法返回一个字符串–该字符串就是一个逻辑视图名，每个字符串对应一个视图名。每个Action都要处理一个用户请求，而用户请求总是包含了指定URL。当FilterDispatcher拦截到用户请求后，根据请求的URL和Action处理URL之间的对应关系来处理转发。模型组件 模型组件已经超出了MVC框架的覆盖范围。对于Struts2框架而言，通常没有为模型组件的实现提供太多的帮助。 J2EE应用里的模型组件，通常指系统的业务逻辑组件以及隐藏其下的DAO、领域对象等组件。通常，MVC框架里的业务控制器会调用模型组件的方法来处理用户请求。也就是说，业务逻辑控制器不会对用户请求进行任何实际处理，用户请求最终由模型组件负责处理。业务控制器只是是间负责调度的调试器，这也是称Action为控制器的原因。视图组件 Struts2允许使用其他的模板技术，如FreeMarker、Velocity作为视图技术。当Struts2的控制器返回逻辑视图名时，逻辑视图并未与任何的视图技术关联，仅仅是返回一个字符串，该字符器作为逻辑视图名。 当在struts.xml文件中配置Action时，不仅需要指定Action的name属性和class属性，还要为Action元素指定系列result了元素，每个result子元素定义一个逻辑视图和物理视图之间的映射。当没有在result子元素中指定type属性时，默认使用JSP作为视图资源引用自：Struts2与Mvc的关系 简单的项目需求草图 效果展示]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CET-4:88day 这样不行啊]]></title>
      <url>%2F2017%2F03%2F20%2FCET-4-88day-%E8%BF%99%E6%A0%B7%E4%B8%8D%E8%A1%8C%E5%95%8A%2F</url>
      <content type="text"><![CDATA[思考一个问题 A你大爷这样子背，非我所愿，非我所意so，应该改变策略恩，先眼熟它，一回生二回熟。我们还是好朋友，我是为了国家为了人民才学英语的！ 12345678910111213141516171819202122232425262728293031323334353637angleangel 天使ankle n. 踝，踝关节anniversaryannoyannualannoymous adj. 匿名的；无名的；无特色的anticipate vt. 预料，期望，预望；提前使用；先于···行动antique 古董；过时的anxiety 焦虑，忧虑；渴望，热望anxious 忧虑的anyhowanywayapartapartment 公寓apologizeapology 道歉，认错，谢罪apparent 表面上的，明显的appeal 上诉，呼吁，申诉；感染力，吸引力appearance 出现，来到；外观appetite 食欲，胃口；欲望applause appliance 用具，器具，机械；家电applicant 申请人applicable 能应用的；合适的，适当的application 申请，申请书；施用，涂抹；应用，实施；实用性apply appoint 任命，委任；约定，指定（时间，地点）appointment appreciate 重视，赏识。领会，体会；感谢；增长approach 向···靠近；靠近appropriate 恰当的，适当的approval 赞成，同意，批准approveapproximate 近似的；近似；估计arbitrary 随心所欲，专断的astrophysics 天体物理学 每天一点语法 be 动词 · 一般动词的过去式be 动词的过去式： was 和 were 现在式 过去式 be动词 am was be动词 is was be动词 are were “ 要看语句的时态: 如果是一般过去时,就用was/were 如果是一般现在时,就用am/is/are 如果是一般将来时,就用will be 然后看主语的人称及复数形式: 一般过去时： 第一人称和第三人称的单数形式，则用was 第一人称和第二人称、第三人称的复数，则用were 一般现在时： 第一人称单数形式，用am 第三人称单数形式，用is 第一人称复数、第二人称、第三人称的复数形式，则用are 一般将来时： will be 口诀：一般时态有关be动词的口诀 我用am，你用are，is连着他她它，单数主语用is，复数主语全用are“]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CET-4:89day 还是 A 系列]]></title>
      <url>%2F2017%2F03%2F20%2FCET-4-89day-%E8%BF%98%E6%98%AF-A-%E7%B3%BB%E5%88%97%2F</url>
      <content type="text"><![CDATA[还是 A 系列A 系列 高频词汇，3个 Word List尼玛 差不多300 个单词长这么大，还没有看过这么多单词 1234567891011121314151617181920212223242526272829303132333435363738394041agent 代理人aggressive 侵略agricultureaidaircraftairlineairportalarmalcoholalertalikeallianceallocateallowallowance 津贴，补贴；零用钱ally 联合，结盟alongsidealphabet 字母表alteralternativealtitude 海拔，高度，高处aluminium 铝iron 铁gold 金silver 银lead 铅tin 锡copper 铜amateum 业余爱好者amazeambassadorambition 雄心，抱负ambulanceamid amongst 在····之中amuse 逗···乐，给···娱乐analyse 分析，分解；解析analysisancestor 祖宗，祖先；原型；先驱anchor 锚；固定，扎根；抛锚；把···系住ancient 古代的，古老的；年老的 打完下来，有点力不从心了革命尚未成功，同志仍需努力！ 恩，竟然还看了be动词 am/is/aredo/dosehava/has第三人称 ，这么奇怪，总是叫它变来变去，中文极好咧。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CET-4:90day 单词你大爷]]></title>
      <url>%2F2017%2F03%2F19%2FCET-4-90day-%E5%8D%95%E8%AF%8D%E4%BD%A0%E5%A4%A7%E7%88%B7%2F</url>
      <content type="text"><![CDATA[单词你大爷 A系列 高频词汇背单词效率太低，一个小时不见得能被得了几个终于完成了 Word List 1but，我连中学词汇都不知道啊 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647accountance 会计工作；会计学accountant 会计人员；会计师accumulate accurancy 准确，精准accurateaccursation 谴责，指控accuseaccustomed 惯常的，习惯的echeachievementacidacknowledgeacquaint 使认识，使了解acquaintance 认识，了解；熟人acquireacquisitionacreactionactiveactivityacuteadaptaddtionaddtionaladequate 足够的，可以胜任的adjustadministrationadmireadmitionadmitadoptadoptive 收养关系的adultadvancedadvantage 优点，优势，好处adventureadvartise 为···做广告，宣传；公告，登广告advertisement 广告advisable 明智的，可取的advocate 拥护，提倡，主张earoplaneeffecteffection 情感，爱，爱慕afford 担负得起；提供affterwordagency 经办，代理；代理处；专门行政部门agenda 议事日程]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CET-4:92day 战起烽火不连天]]></title>
      <url>%2F2017%2F03%2F17%2FCET-4-92day-%E6%88%98%E8%B5%B7%E7%83%BD%E7%81%AB%E4%B8%8D%E8%BF%9E%E5%A4%A9%2F</url>
      <content type="text"><![CDATA[战起青春的热血沸腾，在岁月的成长中消磨殆尽。在渐去渐少的日子里，思考着人生的意义，以及几个月后的告别大学生活，越发越重的生活鸭梨。 英语基础(将从考试大纲的能力要求，个人分十级)：1.词汇：0-12.语法：0-13.阅读能力：0-14.听的能力：0-15.说的能力：0-16.写的能力：0-17.翻译能力：0-1能力要求，参见我做的英语四级脑图 资料准备0.计划1.词汇 《新东方四级词汇 词根+联想 记忆法》2.语法 互联网3.试卷：真题 12345678910111213141516171819202122232425262728单词：abandonabilityaboardabroadabcenceabcentabsoluteabsorbabstractabundantabuseaccademicaccademyaccelerateaccentacceptanceaccessaccidentaccidentalaccommodationaccompanyacceplishaccordaccordanceaccordingaccordinglyaccount]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Struts2框架-拦截器(Interceptor)]]></title>
      <url>%2F2017%2F03%2F16%2FStruts2%E6%A1%86%E6%9E%B6-%E6%8B%A6%E6%88%AA%E5%99%A8-Interceptor%2F</url>
      <content type="text"><![CDATA[学习目标 理解拦截器的工作原理 掌握拦截器的配置和使用 学会自定义拦截器 拦截器概述拦截器（Interceptor）是Struts2的核心组成部分。 它可以动态拦截Action调用的对象，类似Servlet中的过滤器。 Struts2中拦截器是AOP（Aspect-Object—Programming，面向切面编程）的一种实现策略， 是可以“插拔”，需要就插入，不需要就拔出。 拦截器的工作原理通常情况下，拦截器都是以代理方式调用的，它在一个Action 执行前后进行拦截，围绕着Action和Result的执行而执行。 对真正要执行的方法（execute()）进行拦截。首先执行ACtion配置的拦截器，在Action和Result执行之后，拦截器在再次执行（与先前的调用的顺序相反）,在次链式执行的过程中，每一个拦截器在执行execute（）方法前都可以直接返回。 &lt;!-- more --&gt; 拦截器的配置自定义拦截器 1.实现 com.opensymphoy.xwork2.interceptor.Interceptor 123void destroy(); void init(); String intercept(ActionInvocation invocation) throws Exception; 继承 com.opensymphony.xwork2.interceptor.AbstractInterceptor1public String intercept(ActionInvocation invocation) throws Exception 配置拦截器拦截器 1234&lt;interceptors&gt; &lt;interceptor name=&quot;myInterceptor&quot; class=&quot;com.java1234.interceptor.MyInterceptor&quot;&gt;&lt;/interceptor&gt; &lt;interceptor name=&quot;privilege&quot; class=&quot;com.java1234.interceptor.PrivilegeInterceptor&quot;&gt;&lt;/interceptor&gt; &lt;/interceptors&gt; 拦截器栈默认拦截器案例–使用拦截器实现权限控制]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Struts2框架入门]]></title>
      <url>%2F2017%2F03%2F15%2FStruts2%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8%2F</url>
      <content type="text"><![CDATA[Struts2框架系列（一）—— Struts2框架入门Struts2简介什么是Struts2？参见百度百科：Struts2Struts2是一个基于MVC设计模式的Web应用框架，它本质上相当于一个servlet，在MVC设计模式中，Struts2作为控制器(Controller)来建立模型与视图的数据交互。Struts 2是Struts的下一代产品，是在 struts 1和WebWork的技术基础上进行了合并的全新的Struts 2框架。其全新的Struts 2的体系结构与Struts 1的体系结构差别巨大。Struts 2以WebWork为核心，采用拦截器的机制来处理用户的请求，这样的设计也使得业务逻辑控制器能够与ServletAPI完全脱离开，所以Struts 2可以理解为WebWork的更新产品。虽然从Struts 1到Struts 2有着太大的变化，但是相对于WebWork，Struts 2的变化很小。 工作原理Struts2的工作原理图 Struts2de 下载和使用下载Struts 官方网站 http://struts.apache.org/ 使用将下载后的 文件解压 入门案例–Struts2： Hello World！ 1.创建web项目 LvcStruts2 2.添加Struts2的依赖基础jar包 3.在src 根目录下新建 struts.xml 12345678 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE struts PUBLIC &quot;-//Apache Software Foundation//DTD Struts Configuration 2.0//EN&quot; &quot;http://struts.apache.org/dtds/struts-2.0.dtd&quot;&gt;&lt;struts&gt;&lt;/struts&gt; 4.配置web.xml文件 添加 struts2 核心过滤器 12345678910 &lt;filter&gt; &lt;filter-name&gt;Struts2&lt;/filter-name&gt; &lt;filter-class&gt; org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter &lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;Struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 5.新建HelloWorldAction.java 实现 ActionSupport 类 123456789101112 package party.pjc.action;import com.opensymphony.xwork2.ActionSupport;public class HelloWorldAction extends ActionSupport &#123; @Override public String execute() throws Exception &#123; // TODO Auto-generated method stub return SUCCESS; &#125;&#125; 6.配置Struts.xml 文件 123456789101112131415 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE struts PUBLIC &quot;-//Apache Software Foundation//DTD Struts Configuration 2.0//EN&quot; &quot;http://struts.apache.org/dtds/struts-2.0.dtd&quot;&gt;&lt;struts&gt; &lt;package name=&quot;helloWorld&quot; extends=&quot;struts-default&quot;&gt; &lt;action name=&quot;hello&quot; class=&quot;party.pjc.action.HelloWorldAction&quot;&gt; &lt;result name=&quot;success&quot;&gt;helloworld.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 7.新建helloworld.jsp ` &lt;body&gt; Strust2 Hello world! &lt;/body&gt; ` 8.效果]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[自定义 EL 函数]]></title>
      <url>%2F2017%2F03%2F15%2F%E8%87%AA%E5%AE%9A%E4%B9%89-EL-%E5%87%BD%E6%95%B0%2F</url>
      <content type="text"><![CDATA[EL表达式-自定义函数 表达式语言除了可以使用基本的运运算符之外，还可以使用自定义的函数。 通过使用自定义函数，加强了表达式语言功能。 EL表达式函数，主要空能是完成对数据的修改，统一格式化。 使用步骤 1.开发函数处理类，处理类就是普通的 java类；每个函数对应类中的一个静态方法。 2.建立TLD文件，定义表达式函数。 3.在WEB.xml文件中配置（可省略） 4.在jsp 页面引入及使用 案例——自定义 EL 函数防止 HTML 注入 1.开发函数处理类 12345678910111213141516171819202122232425262728293031 package com.lvc.chapter7.utils;public class HTMLFilter &#123; public static String filter(String message) &#123; if (message == null)&#123; return (null); &#125; char content[] = new char[message.length()]; message.getChars(0, message.length(), content, 0); StringBuffer result = new StringBuffer(content.length + 50); for (int i = 0; i &lt; content.length; i++) &#123; switch (content[i]) &#123; case &apos;&lt;&apos;: result.append(&quot;&amp;lt;&quot;); break; case &apos;&gt;&apos;: result.append(&quot;&amp;gt;&quot;); break; case &apos;&amp;&apos;: result.append(&quot;&amp;amp;&quot;); break; case &apos;&quot;&apos;: result.append(&quot;&amp;quot;&quot;); break; default: result.append(content[i]); &#125; &#125; return (result.toString()); &#125;&#125; 2.建立TLD文件 12345678910111213141516171819 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;taglib xmlns=&quot;http://java.sun.com/xml/ns/j2ee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd&quot; version=&quot;2.0&quot;&gt; &lt;tlib-version&gt;1.0&lt;/tlib-version&gt; &lt;short-name&gt;function&lt;/short-name&gt; &lt;uri&gt;/WEB-INF/ElTag.tld&lt;/uri&gt; &lt;function&gt; &lt;name&gt;filter&lt;/name&gt; &lt;function-class&gt; com.lvc.chapter7.utils.HTMLFilter &lt;/function-class&gt; &lt;function-signature&gt; java.lang.String filter(java.lang.String) &lt;/function-signature&gt; &lt;/function&gt;&lt;/taglib&gt; 3.在web.xml下配置 1234567891011121314151617 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;web-app version=&quot;2.5&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;&gt; &lt;jsp-config&gt; &lt;taglib&gt; &lt;!-- 配置标签的引用地址 JSP页面中引用时使用--&gt; &lt;taglib-uri&gt;/WEB-INF/ElTag.tld&lt;/taglib-uri&gt; &lt;!-- 配置标签的TLD文件地址 --&gt; &lt;taglib-location&gt;/WEB-INF/ElTag.tld&lt;/taglib-location&gt; &lt;/taglib&gt; &lt;/jsp-config&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;/web-app&gt; 4.在jsp页面中引入和使用 123456789101112 &lt;%@ page language=&quot;java&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;%@ taglib prefix=&quot;lvc&quot; uri=&quot;/WEB-INF/mytaglib.tld&quot; %&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 用户名:$&#123;name&#125;&lt;br /&gt; 留言:$&#123;message&#125;&lt;br/&gt; 过滤后的留言：$&#123;lvc:filter(message)&#125;&lt;/body&gt;&lt;/html&gt; 显示效果]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[js页面跳转]]></title>
      <url>%2F2017%2F03%2F13%2Fjs%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC%2F</url>
      <content type="text"><![CDATA[js 页面跳转参考资料: &lt; http://www.w3cschool.com.cn &gt; 当前页面 跳转window.location.self=&quot;url&quot;;‘ ‘ 新建窗口 跳转window.open(&quot;URL&quot;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[闲言碎语-心灵访客]]></title>
      <url>%2F2017%2F03%2F11%2F%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD-%E5%BF%83%E7%81%B5%E8%AE%BF%E5%AE%A2%2F</url>
      <content type="text"><![CDATA[《心灵访客》]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[android：卫星式菜单]]></title>
      <url>%2F2017%2F03%2F11%2Fandroid%EF%BC%9A%E5%8D%AB%E6%98%9F%E5%BC%8F%E8%8F%9C%E5%8D%95%2F</url>
      <content type="text"><![CDATA[Android自定义控件实现步骤： * 一、动画 * 二、自定义属性]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[深入理解Android中的自定义属性]]></title>
      <url>%2F2017%2F03%2F11%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Android%E4%B8%AD%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%2F</url>
      <content type="text"><![CDATA[转载请标明出处：http://blog.csdn.net/lmj623565791/article/details/45022631 本文出自:【张鸿洋的博客】 1.引言对于自定义属性，大家肯定都不陌生，遵循以下几步，就可以实现： 自定义一个CustomView(extends View )类 编写values/attrs.xml，在其中编写styleable和item等标签元素 在布局文件中CustomView使用自定义的属性（注意namespace） 在CustomView的构造方法中通过TypedArray获取]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[学习方法：黑马高薪学习方法]]></title>
      <url>%2F2017%2F03%2F05%2F%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%EF%BC%9A%E9%BB%91%E9%A9%AC%E9%AB%98%E8%96%AA%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[学习方法：黑马高薪学习方法原文地址 此文章是黑马老学员给新学员的学习建议，一个来自高薪学员的心声，望仔细耐心看完，这将是你在黑马学习的重要指南。 四个半月的时光转瞬而逝，我如愿以偿地拿到了让自己满意的offer，这都必须归功于黑马辛苦教学的老师以及身边勤奋学习的同学们对我不断地鼓励和支持。在黑马学习期间，我享受到了以前从未有过的充实生活，并且这段人生经历激发了我对技术难以磨灭的热情，这份热情即使在我就职之后依然持续地灼烧着。因此，怀着感恩的心情，我认为自己必须为黑马做点什么，所以才有了这篇关于学习方法的总结。希望学弟学妹们能从这里汲取到有利于自己的学习思路，从而让自己能够用更短的时间学习到更多的知识，利用黑马这优质的平台，让自己在技术的道路上走得更快，更远。 记得入学后不久，我们就进行了第一次测验。然后，同学们学习效率的差距惊人地暴露出来了。令人诧异的是，很多同学学习很辛苦，甚至经常熬夜，但是学习效果并没有预想的那么好。反之，很多同学学习时间很短，但是效果却非常地惊人。于是，我就开始思考是什么原因导致了这种差异？通过与很多同学的沟通和交流，我终于明白学习方法起到了至关重要的作用。那么好的学习方法应该注意哪些方面呢？我认为只要你能够经常问自己下面八个问题，你就可以确定自己是不是走在正轨上。 Question 1：明天会上哪些内容的课程呢？ 如果可以的话，你可以拷贝到往届学长学姐们的笔记，每天利用5分钟的时间大致浏览第二天的课程，从而能够从全局把握课程结构，从而使自己在第二天老师6个小时的狂轰滥炸中不至于处于被动，然后不知道自己所处何处。反之，你就可以化被动为主动，从而可以将6个小时的课程切割成对应于各个知识点的小模块。通过这种方式，你就可以极大地提升自己的听课质量。 Question 2：今天的课程我完全听懂了吗？ 听课质量的高低对学习效果可以说起到了中流砥柱的作用。试想一下，如果你的听课效率质量很高，那么晚上敲代码、复习的时间就可以大大地减少。因为，你不会再对着老师分发的代码和资料问自己一些愚蠢的问题。例如：这段代码是干什么的来着？这个知识点好像完全没听懂。这些令人抓狂的问题会严重挫伤你学习的积极性。因此，如果上课有任何内容没有听懂，那么不要忽略掉，应该把自己想问的问题记录下来，下课之后，立刻通过与同学和老师的讨论解决掉。 Question 3：今天我对哪些问题有疑问呢？ 如果你是抱着积极的学习态度在听课，那么你一定会在上课期间产生各种各样的idea。你可能在想一种代码效果有没有另外一种实现方式，或者另外一种配置方式会有什么效果。这时候，一定要迅速记录下来这些问题，不要占用上课时间跟同学讨论或者自己纠结于此。因为，一旦你这样做，后面的课程你就完全不会在用心听了，这就降低了听课的质量。 Question 4：有疑问的问题自己可以通过网络或者写一些例子得到结果吗？ 产生任何问题之后，不要急于问老师和同学，而是要培养自己独立学习和解决问题的能力。你可以通过网络或者API文档查询到结果，又或者自己写一个例子程序得到答案。如果实在有困难，再向学生和老师求助。这样，可以培养你独立解决问题的能力。毕竟，在公司里，是没有太多人给你全方位的指导和帮助的，不是吗？ Question 5：今天的代码我有敲完吗？ 很多同学有时候会进入一个误区，那就是他认为上课的时候代码已经完全理解了，下课就没有必要再敲这些代码了，这就走向了一个极端。另外一个极端则是认为代码必须自己从头到尾一个字母不漏的敲出来才算掌握了。实际上，代码最重要的是写出思路，然后通过查询API文档完成代码。当然，第一次敲代码的时候最好可以临摹老师的代码，然后再自己独立完成。否则，由于难度太大，可能会打消学习的积极性并且浪费时间在回忆代码上。另外一个需要指出的点是，千万不要给自己拖延的理由，今天的代码今天必须要完成，即使奋战到凌晨2点也在所不惜。如果你拖延到明天，那么再加上第二天的代码量，你会倾向于放弃昨天的代码，甚至对今天的代码也感到厌烦。毕竟学习的时间是有限的，利用一天的时间承担两天的任务量，没有压力才怪呢！ Question 6：我可以对这些代码进行封装或者优化吗？我可以做一些小应用吗？ 任何的知识想要活学活用都必须要经过自我优化并且不断应用从而达到熟能生巧的过程。如果仅仅局限于老师的例子代码，你将会发现自己解决问题的能力并不强，还只是处于粘贴拷贝的码农阶段。但是如果你能够思考这些代码怎么去封装和优化，并且自己试图做一些应用，那么恭喜你，你就在朝着架构师以及高级软件工程师的方向发展了。 Question 7：今天我的任务完成了吗？ “今日事，今日毕”。古人的这句话说明了执行力的重要性。所以，千万不要给自己任何拖延的理由。不要说，今天几个玩的很好的哥们邀我玩dota，今天的任务明天我一定做！如果这样的话，你会发现，第二天你已经生疏了第一天的知识。因为你没有复习也没有敲代码。你会感到更大的阻力去重新学习昨天的课程。这时候厌倦的情绪会大大的降低你的学习效果。所以，不要让任何事情阻碍你去完成你今天的任务。你需要明白，拖延不是选项，你甚至根本不要去考虑它。 Question 8：我有明确而有效的复习计划吗？ 孔子有句话，“温故而知新，可以为师矣”。见名知意，就是经常温习就可以学到新的东西，也就是熟能生巧。很多同学在学习后面知识的时候经常会抱怨以前的知识已经遗忘了。因而，当他们学习后面的知识时，就会感觉到非常的有压力，甚至产生了放弃学习的念头。这种心态会严重扼杀一个人的自信心并且学习效率极低。等到就业找工作的时候，这些同学会变得极度不自信。因为，他认为所有的知识在他心中越来越模糊。那么，好的措施就是制定明确有效的学习计划，定期复习将会使你保持对知识的熟悉程度。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[春雏集-流动的思绪]]></title>
      <url>%2F2017%2F03%2F05%2F%E6%98%A5%E9%9B%8F%E9%9B%86-%E6%B5%81%E5%8A%A8%E7%9A%84%E6%80%9D%E7%BB%AA%2F</url>
      <content type="text"><![CDATA[&nbsp; &nbsp; &nbsp; &nbsp;所有的思绪被一场大雨冲刷的一干二净，窗花外的朦胧又梦幻般的世界，炫耀了莫名的姿色，五颜六色霓虹如五味杂陈般又塞满了整个空间。 &nbsp; &nbsp; &nbsp; &nbsp;车如流水马如龙，身如浮萍，难定踪迹。安静的车厢，闪烁的车灯，荧屏映衬着冷漠的脸，扶手也冷冷的释放着冷意，窗外的雨越发的朦胧，翻起的水雾遮拢了这个小城。 &nbsp; &nbsp; &nbsp; &nbsp;从繁华到落幕，笔直的大道，到底掩含了多少如流水般如你我般在相似而又落寞的世界里禹禹独行。追寻着光明，却曾未被照耀。但还是，在黑夜中坚持的前进着，心中一直坚定的信念，曾未如此光明过，不断的放大放大，直到思绪飘离了这里，在苍穹之上，默默的俯视着光怪陆离的世界。我看到了街边行乞的流浪人，祈求着每一个路人，只为了一顿三餐；我看到了在公园里哭泣的小女孩，眼中充满的渴望和泪水，只是想得到关爱；我看到了吵架的情侣，相互指责着对方，可是他倆又是那么的相爱；我看到了，我看到了世界，我看到了平常未曾感知到的色彩，生活如此。 &nbsp; &nbsp; &nbsp; &nbsp;“我的心愿的是世界和平！”一句会被嘲笑的话，此刻却是那么有力，那么渴望。相互扮演着让着这个世界运行下去的角色，有时你会生出挫败的无力感，此刻些许能明白些所谓的“看破红尘，遁入空门”这般话语。追心而去，逐念而去，坚守本心。 &nbsp; &nbsp; &nbsp;&nbsp;谁的思绪飞越了尽头，如流水般一去不返。 &nbsp; &nbsp; &nbsp; &nbsp;昨日而去，今日而追。心若有念，不曾有晚。 &nbsp; &nbsp; &nbsp; &nbsp;流动的思绪，翻腾的水雾，220照样在行驶，霓虹照样五味杂陈。每一次行程，如洗礼般，净化污浊，保持自我的纯真和最初的信念。 &nbsp; &nbsp; &nbsp; &nbsp;飘飞的思绪，随着耸动的人流下了车。我在窗外，看了看脚下的流水，却没了在窗内的思绪，笃定了思绪，默默前行。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[javaee上课笔记-Servlet事件监听器]]></title>
      <url>%2F2017%2F03%2F03%2Fjavaee%E4%B8%8A%E8%AF%BE%E7%AC%94%E8%AE%B0-Servlet%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E5%99%A8%2F</url>
      <content type="text"><![CDATA[学习目标 掌握监听器的相关API 掌握监听器域对象中的属性变更 掌握感知被HttpSession绑定的事件监听器 Servlet事件监听器概述 监听器组成：1.事件（Event）：用户的一个操作，如单机一个按钮、调用一个方法、创建一个对象吗等2.事件源：产生事件的对象3.事件监听器（Listener）：负责监听发生在事件源上的事件。4.事件处理器：监听器的成员方法，当事件发生的时候会触发的处理器（成员方法） 事件监听器工作步骤1.将监听器绑定到事件源，也就是注册监听器。2.事件发生时会触发监听器的的成员方法，即事件的处理器，传递事件对象。3.事件处理器通过事件 对象获得事件源，并对事件源进行处理。 Servlet事件监听器根据监听事件的不同分为三类1.用于监听域对象的创建和销毁的事件监听器（ServletContextListener 接口、HttpSessionListener 接口、ServletRequestListener 接口）。2.用于监听域对象属性增加和删除的事件监听器（ServletContextAttributeListener 接口、HttpSessionAttributeListener 接口、ServletRequestAttributeListener 接口）3.用于监听绑定到HttpSession域中某个对象状态的事件监听器（HttpSessionBindingListener接口、HttpsessionActivationListener 接口） 监听域对象的生命周期ServletContextListener 接口 方法： contextInitalized（）方法public void contextInitalized(ServletContextEvent sce)当ServletContext 对象被创建时，web容器会调用该方法，传入ServletContextEvent类型参数，在方法内容通过该参数来获取 创建的ServletContext对象 contextDestroyed（）方法public vid contextDestroyed(ServletContextEvent sce)内容描述差不多，就不写了HttpSessionListener 接口 sessionCreated()方法public vid sessionCreated（httpsessionEvent se） sessionDestroyed（）方法public vid sessionDestroyed（）方法 se）ServletRequestListener 接口 requestInitalized（）方法public void requestInitalized(ServletRequestEvent sre) requestDestroyed方法public void requestDestroyed(ServletRequestEvent sre) 案例-监听域对象的生命周期对Servlet域对象的生命周期进行监听，首先要实现域对象相应的接口 123456789101112131415161718192021222324package party.pjc.chapter05.listener;import javax.servlet.*;import javax.servlet.http.*;public class MyListener implements ServletContextListener, HttpSessionListener, ServletRequestListener &#123; public void contextInitialized(ServletContextEvent arg0) &#123; System.out.println(&quot;ServletContext对象被创建了&quot;); &#125; public void contextDestroyed(ServletContextEvent arg0) &#123; System.out.println(&quot;ServletContext对象被销毁了&quot;); &#125; public void requestInitialized(ServletRequestEvent arg0) &#123; System.out.println(&quot;ServletRequest对象被创建了&quot;); &#125; public void requestDestroyed(ServletRequestEvent arg0) &#123; System.out.println(&quot;ServletRequest对象被销毁了&quot;); &#125; public void sessionCreated(HttpSessionEvent arg0) &#123; System.out.println(&quot;HttpSession对象被创建了&quot;); &#125; public void sessionDestroyed(HttpSessionEvent arg0) &#123; System.out.println(&quot;HttpSession对象被销毁了&quot;); &#125;&#125; 配置文件，部署Mylistener监听器 12345&lt;listener&gt; &lt;listener-class&gt; packagePath &lt;/listener-class&gt;&lt;/listener&gt; 统计在线人数 贴上核心代码： 123456789101112131415161718package party.pjc.chapter05.listener;import javax.servlet.*;import javax.servlet.http.*;public class CountListener implements HttpSessionListener &#123; private int count = 0;// 用于统计在线人数 public void sessionCreated(HttpSessionEvent hse) &#123; count++;// session对象创建时count变量加1 ServletContext context = hse.getSession().getServletContext(); context.setAttribute(&quot;count&quot;, new Integer(count)); &#125; public void sessionDestroyed(HttpSessionEvent hse) &#123; count--;// session对象销毁时count变量减1 ServletContext context = hse.getSession().getServletContext(); context.setAttribute(&quot;count&quot;, new Integer(count)); &#125;&#125; 监听域对象中的属性变更监听对象属性变更的接口 attributeAdded（）方法public void attributeAdded(ServletContextAttributeEvent scab)public void attributeAdded(HttpSessionOnBindingEvent se)public void attributeAdded(ServletRequestAttributeEvent srae) attributeRemove()方法public void attributeRemove(ServletContextAttributeEvent scab)public void attributeRemove(HttpSessionOnBindingEvent se)public void attributeRemove(ServletRequestAttributeEvent srae)案例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package party.pjc.chapter05.listener;import javax.servlet.*;import javax.servlet.http.*;public class MyAttributeListener implementsServletContextAttributeListener,HttpSessionAttributeListener, ServletRequestAttributeListener &#123; public void attributeAdded(ServletContextAttributeEvent sae) &#123; String name = sae.getName(); System.out.println(&quot;ServletContext添加属性：&quot; + name + &quot;=&quot; + sae.getServletContext().getAttribute(name)); &#125; public void attributeRemoved(ServletContextAttributeEvent sae) &#123; String name = sae.getName(); System.out.println(&quot;ServletContext移除属性: &quot; + name); &#125; public void attributeReplaced(ServletContextAttributeEvent sae) &#123; String name = sae.getName(); System.out.println(&quot;ServletContext替换属性：&quot; + name + &quot;=&quot; + sae.getServletContext().getAttribute(name)); &#125; public void attributeAdded(HttpSessionBindingEvent hbe) &#123; String name = hbe.getName(); System.out.println(&quot;HttpSession添加属性：&quot; + name + &quot;=&quot; + hbe.getSession().getAttribute(name)); &#125; public void attributeRemoved(HttpSessionBindingEvent hbe) &#123; String name = hbe.getName(); System.out.println(&quot;HttpSession移除属性: &quot; + name); &#125; public void attributeReplaced(HttpSessionBindingEvent hbe) &#123; String name = hbe.getName(); System.out.println(&quot;HttpSession替换属性：&quot; + name + &quot;=&quot; + hbe.getSession().getAttribute(name)); &#125; public void attributeAdded(ServletRequestAttributeEvent sra) &#123; String name = sra.getName(); System.out.println(&quot;ServletRequest添加属性：&quot; + name + &quot;=&quot; + sra.getServletRequest().getAttribute(name)); &#125; public void attributeRemoved(ServletRequestAttributeEvent sra) &#123; String name = sra.getName(); System.out.println(&quot;ServletRequest移除属性: &quot; + name); &#125; public void attributeReplaced(ServletRequestAttributeEvent sra) &#123; String name = sra.getName(); System.out.println(&quot;ServletRequest替换属性：&quot; + name + &quot;=&quot; + sra.getServletRequest().getAttribute(name)); &#125;&#125; 别忘了在web.xml下配置 感知被HttpSession绑定的事件监听器HttpSessionBindingListener 接口 valueBound（）方法public void valueBound(HttpSessionBindingEvent event) valueUnBound()方法public void valueUnbound(HttpSessionBindingEvent event) 统计登录用户]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[春雏集：看见花落也凋零]]></title>
      <url>%2F2017%2F03%2F01%2F%E6%98%A5%E9%9B%8F%E9%9B%86%EF%BC%9A%E7%9C%8B%E8%A7%81%E8%8A%B1%E8%90%BD%E4%B9%9F%E5%87%8B%E9%9B%B6%2F</url>
      <content type="text"><![CDATA[春雏集：看见花落也凋零 看见花落也凋零。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[javaee上课笔记:DBUtils工具]]></title>
      <url>%2F2017%2F03%2F01%2Fjavaee%E4%B8%8A%E8%AF%BE%E7%AC%94%E8%AE%B0-DBUtils%E5%B7%A5%E5%85%B7%2F</url>
      <content type="text"><![CDATA[javaee上课笔记:DBUtils工具学习目标 了解DBUtils工具中的api 学会使用DBUtils工具对数据库进行增删改查的操作 学会使用DBUtils工具处理事务点我下载DBUtils API介绍核心类 &amp; 接口 类 org.apache.commons.dbutils.DbUtils org.apache.commons.dbutils.QueryRunner 接口 org.apache.commons.dbutils.ResultSetHandler DBUtils 类 DBUtils类 主要为如何关闭，装载JDBC驱动程序之类的常规工作提供方法，它提供的方法都是静态方法， 1.close() 方法关闭数据库连接 2.closeQuietly(Connection con,Statement stmt,ResultSet rs) 方法该方法用来关闭Connection，Statement和ResultSet对象。还会隐藏一些在程序中抛出的sql异常 3.commitAndCloseQuiely(Connection con)该方法用来提交连接，然后关闭连接， 且在关闭时不抛出sql异常 4.LoadDrive（java.lang.String driverClassName）该方法用于装载jdbc驱动程序，如果成功返回true。使用时，不需要捕捉ClassNotFoundException异常 QueryRunner 类该类简化了执行sql语句的代码，它与ResultSetHandler 组合在一起，能完成大部分的数据库操作，大大减少编码量。提供了两个构造方法：1.默认的构造方法2.需要javax.sql.DataSource 作为参数 1.query(Connection conn,String sql,ResultSetHandler rsh,Object[] params) 方法该方法用于执行查询操作参数params表示一个对象数组，该数组中每个元素都被用来作为查询语句的置换参数注意：该方法会自动处理PrepareSatement 和 ResultSet的创建和关闭 2.query(String sql,ResultSetHandler rsh,Object[] params)方法该方法用于执行查询操作，与第一个方法相比它不需要传递Connection对象给方法，它可以从提供给构造方法的数据源DateSource或使用setDateSource()中获得连接。 3.query(Connection conn，String sql,ResultSetHandler rsh)方法该方法用于执一个不需要置换参数的查询操作 4.update(Connection conn，String sql,Object[] params)方法该方法用来执行插入、更新或者删除操作，其中，参数params 表示SQL语句中的置换参数。 5.update(Connection conn,String sql) 方法该方法用于执行插入、更新或者删操作，它需要置换参数操作。 ## ResultSetHandler 接口 该接口用于处理ResultSet结果集，它可以将结果集中的数据转化为不同的形式。根据结果集中数据类型的不同，ResultHandler提供了不同的实现类。如下： 1.AbstractKeyedHandler:该类为抽象类，能够把结果集里面的数据转换为用Map存储。 2.AbstractListHandler：该类为抽象类，—如上—-转换为用List存储。 3.ArrayHandler：把结果集中的第一行数据转成数据对象数组 4.ArrayListHandler：把结果集中的每一行数据转成一个对象数组，再将数组存放到List中。 5.BaseResultSetHandler：把结果集转换成其他对象的扩展。 6.BeanHandler :将结果集中的第一行数据封到一个对应的JavaBean实例中。 7.BeanListHandler：将结果集中的每一行数据都封装到一个对应的 JavaBean实例中，存放到list中 8.BeanMapHandler：结果集中的每一行数据都封装到一个对应的 JavaBean实例中，然后在根据指定的key把每个JavaBean在存放到一个Map里 9.ColumnListHandler：将结果集中某一列的数据存放到List中 10.将结果集中的每一行数据封装到一个map里，然后在根据指定的key把每个MAp在存放到一个map里。 11.MapHandler：将结集中的每一行数据封装到一个map里。可以是列名，value是对应的值。 12.MapListHandler：将结果集中的每一行数据封装到一个Map中，然后在存放到list中 13.ScalarHandler：将结果集中的某一条记录的其中某一列的数据存储成Object对象 另外，在ResultSetHandler接口中，提供了一个单独的方法handle（java.sql.ResultSet rs）,如果上述实现类没有提供想要的功能，可以通过自定义一个实现ResultSetHandler接口的类，然后重写handel()方法，实现结果集的处理。 代码实现ArrayHandler 和 ArrayListHandler 12345678public static void testArrayHandler() throws SQLException&#123; BaseDao beseDao = new BaseDao(); String sql = &quot;select * from NEWSINFO where nid=?&quot;; Object[] arr = (Object[]) BaseDao.query(sql, new ArrayHandler(), new Object[]&#123;50&#125;); for(int i=0;i&lt;arr.length;i++)&#123; System.out.println(arr[i]+&quot;,&quot;); &#125; 实现步骤 1.创建QueryRunner对象 （配置了C3p0数据池，参数获取数据源） QueryRunner runner = new QueryRunner（C3p0Utils.getDateSource（）） 2.编写Sql语句 String sql = &quot;&quot; 3.调用QueryRunner中的方法 runner.query() runner.update() 参数参考上面 DBUtils 处理事务 创建JDBCUtils,该类封装了创建连接，开启事务，关闭事务等方法 需要注意的是，请求中的一个事务涉及到了多个数据库操作，如果这些Connection是 从连接池中获取的，两个DAO操作就用到了两个Connection，这样是没办法完成一个事务的， 所以，需要借助ThreadLoacl类。 ThreadLoacl类的作用是在一个线程里记录变量。可以生成一个连接放在这个线程中， 只要是这个线程中的任何对象都可以共享这个连接，当线程结束后就删除这个连接，这样， 就保证了一个事务，一个连接。直接上代码:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package party.lvc.jdbc.utils;import java.sql.Connection;import java.sql.SQLException;import javax.sql.DataSource;import com.mchange.v2.c3p0.ComboPooledDataSource;public class JDBCUtils &#123; // 创建一个ThreadLocal 对象，以当前线程作为key private static ThreadLocal&lt;Connection&gt; threadLocal = new ThreadLocal&lt;Connection&gt;(); // 从c3p0-config.xml配置文件中读取默认的数据库配置，生成c3p0数据源 private static DataSource ds = new ComboPooledDataSource(); // 返回数据源对象 public static DataSource getDataSource() &#123; return ds; &#125; // 获取c3p0数据库连接池中的连接对象 public static Connection getConnection() throws SQLException &#123; Connection conn = threadLocal.get(); if (conn == null) &#123; conn = ds.getConnection(); threadLocal.set(conn); &#125; return conn; &#125; // 开启事务 public static void startTransaction() &#123; try &#123; // 获得链接 Connection conn = getConnection(); // 开启事务 conn.setAutoCommit(false); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; // 提交事务 public static void commit() &#123; try &#123; // 获得链接 Connection conn = threadLocal.get(); // 提交事务 if (conn != null) conn.commit(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; // 回滚事务 public static void rollback() &#123; try &#123; // 获得链接 Connection conn = threadLocal.get(); // 回滚事务 if (conn != null) conn.rollback(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; // 关闭数据库连接，释放资源 public static void close() &#123; // 获得链接 Connection conn = threadLocal.get(); // 关闭事务 if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; // 从集合中移除当前绑定的连接 threadLocal.remove(); conn = null; &#125; &#125; &#125;&#125; 事务的实现。通过银行转账业务，来举个栗子。创建Business，该类包括了转账过程的逻辑方法。1234567891011121314151617181920212223242526272829303132333435363738394041package party.lvc.example;import java.sql.SQLException;import cn.itcast.jdbc.example.dao.AccountDao;import cn.itcast.jdbc.example.domain.Account;import cn.itcast.jdbc.utils.JDBCUtils;public class Business &#123; public static void transfer(String sourceAccountName, String toAccountName, float money) &#123; try &#123; // 开启事务 JDBCUtils.startTransaction(); // 根据用户名查询数据并存入实体类对象中 AccountDao dao = new AccountDao(); Account accountfrom = dao.find(sourceAccountName); Account accountto = dao.find(toAccountName); // 完成转账操作 if(money&lt;accountfrom.getMoney())&#123; accountfrom.setMoney(accountfrom.getMoney()-money); &#125;else&#123; System.out.println(&quot;转出账户余额不足&quot;); &#125; accountto.setMoney(accountto.getMoney()+money); dao.update(accountfrom); dao.update(accountto); // 提交事务 JDBCUtils.commit(); System.out.println(&quot;提交成功&quot;); &#125; catch (SQLException e) &#123; System.out.println(&quot;提交失败&quot;); JDBCUtils.rollback(); e.printStackTrace(); &#125; finally &#123; // 关闭事务 JDBCUtils.close(); &#125; &#125; public static void main(String[] args) throws SQLException &#123; // 调用方法，实现a向b转账200元操作 transfer(&quot;a&quot;, &quot;b&quot;, 200); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android上课笔记-快速入门]]></title>
      <url>%2F2017%2F02%2F25%2FAndroid%E4%B8%8A%E8%AF%BE%E7%AC%94%E8%AE%B0-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%2F</url>
      <content type="text"><![CDATA[Android项目的目录结构 Activity：应用被打开时显示的界面 src：项目代码 R.java：项目中所有资源文件的资源id Android.jar：Android的jar包，导入此包方可使用Android的api libs：导入第三方jar包 assets：存放资源文件，比方说mp3、视频文件 bin：存放编译打包后的文件 res：存放资源文件，存放在此文件夹下的所有资源文件都会生成资源id drawable：存放图片资源 layout：存放布局文件，把布局文件通过资源id指定给activity，界面就会显示出该布局文件定义的布局 menu：定义菜单的样式 Strings.xml：存放字符串资源，每个资源都会有一个资源id Android的配置文件（清单文件） 指定应用的包名 package=”com.itheima.helloworld”data/data/com.itheima.helloworld(上面代码指定的包名)应用生成的文件都会存放在此路径下 Android的四大组件在使用前全部需要在清单文件中配置 的配置对整个应用生效 的配置对该activity生效DDMS Dalvik debug monitor service Dalvik调试监控服务 常用的adb指令Android debug bridge：安卓调试桥 adb start-server:启动adb进程 adb kill-server：杀死adb进程 adb devices：查看当前与开发环境连接的设备，此命令也可以启动adb进程 adb install XXX.apk：往模拟器安装apk adb uninstall 包名：删除模拟器中的应用 adb shell:进入linux命令行 ps：查看运行进程 ls：查看当前目录下的文件结构 netstat -ano：查看占用端口的进程电话拨号器 功能：用户输入一个号码，点击拨打按钮，启动系统打电话的应用把号码拨打出去 1. 定义布局 组件必须设置宽高，否则不能通过编译 12android:layout_width=&quot;wrap_content&quot;android:layout_height=&quot;wrap_content&quot; 如果要在java代码中操作某个组件，则组件需要设置id，这样才能在代码中通过id拿到这个组件 android:id=&quot;@+id/et_phone&quot; 2. 给按钮设置点击侦听 给按钮设置侦听1234 //通过id拿到按钮对象Button bt_call = (Button) findViewById(R.id.bt_call);//给按钮设置点击bt_call.setOnClickListener(new MyListener()); 3. 得到用户输入的号码123//得到用户输入的号码，先拿到输入框组件EditText et_phone = (EditText) findViewById(R.id.et_phone);String phone = et_phone.getText().toString(); 4. 把号码打出去 Android系统中基于动作机制，来调用系统的应用，你告诉系统你想做什么动作，系统就会把能做这个动作的应用给你，如果没有这个应用，会抛异常 设置动作，通过意图告知系统12345678//把号码打出去 //先创建一个意图对象 Intent intent = new Intent(); //设置动作，打电话 intent.setAction(Intent.ACTION_CALL); intent.setData(Uri.parse(&quot;tel:&quot; + phone)); //把意图告诉系统 startActivity(intent); 添加权限 &lt;uses-permission android:name=&quot;android.permission.CALL_PHONE&quot;/&gt; 点击事件的四种写法第一种 定义一个MyListener实现onClickListener接口 12Button bt1 = (Button) findViewById(R.id.bt1);bt1.setOnClickListener(new MyListener()); 第二种 定义一个匿名内部类实现onClickListener接口 123456789Button bt2 = (Button) findViewById(R.id.bt2);bt2.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; System.out.println(&quot;第二种&quot;); &#125;&#125;); 第三种 让当前activity实现onClickListener接口 12Button bt3 = (Button) findViewById(R.id.bt3);bt3.setOnClickListener(this); 第四种 给Button节点设置onClick属性， android:onClick=&quot;click&quot; 然后在activity中定义跟该属性值同名的方法 123public void click(View v)&#123; System.out.println(&quot;第四种&quot;);&#125; 短信发送器 功能：用户输入号码和短信内容，点击发送按钮，调用短信api把短信发送给指定号码 1. 定义布局 输入框的提示android:hint=&quot;请输入号码&quot; 2. 完成点击事件 先给Button组件设置onClick属性onClick=&quot;send&quot; 在Activity中定义此方法public void send(View v){} 3. 获取到用户输入的号码和内容1234EditText et_phone = (EditText) findViewById(R.id.et_phone);EditText et_content = (EditText) findViewById(R.id.et_content);String phone = et_phone.getText().toString();String content = et_content.getText().toString(); 4. 调用发送短信的api12345//调用发送短信的apiSmsManager sm = SmsManager.getDefault();//发送短信sm.sendTextMessage(phone, null, content, null, null); 添加权限 1&lt;uses-permission android:name=&quot;android.permission.SEND_SMS&quot;/&gt; 如果短信过长，需要拆分List&lt;String&gt; smss = sm.divideMessage(content);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[android笔记-Drawable]]></title>
      <url>%2F2017%2F02%2F24%2Fandroid%E7%AC%94%E8%AE%B0-Drawable%2F</url>
      <content type="text"><![CDATA[Android 的 Drawable Drawable 表示的是一中可以在Canvas上进行绘制的抽象概念，它的种类很多，最常见的颜色和 图片度可以是一个Drawable。 Drawable一般都是通过XML定义的，也可以使用代码来创建。 Drawable的分类BitmapDrawable 几乎是是最简单的Drawable，它就是表示一张图片。 xml文件， 属性123456789android:antialias 抗锯齿 android:dither 抖动效果 android:filter 过滤效果android:gravity 对图片进行定位，当图片小于容器时。android:mipMap android:src android:tileMode 平铺模式 disabled 、clamp、reapt 、mirrorandroid:tileModeXandroid:tileModeY ShapeDrawable 形状的Drawable咯,定义基本的几何图形,如(矩形,圆形,线条等),根元素是 节点比较多，相关的节点如下： ① shape: ~ visible:设置是否可见 ~ shape:形状,可选:rectangle(矩形,包括正方形),oval(椭圆,包括圆),line(线段),ring(环形) ~ innerRadiusRatio:当shape为ring才有效,表示环内半径所占半径的比率,如果设置了innerRadius, 他会被忽略 ~ innerRadius:当shape为ring才有效,表示环的内半径的尺寸 ~ thicknessRatio:当shape为ring才有效,表环厚度占半径的比率 ~ thickness:当shape为ring才有效,表示环的厚度,即外半径与内半径的差 ~ useLevel:当shape为ring才有效,表示是否允许根据level来显示环的一部分 ② size ~ width:图形形状宽度 ~ height:图形形状高度 ③ &lt;gradient 》 后面GradientDrawable再讲~ ④ solid ~ color:背景填充色,设置solid后会覆盖gradient设置的所有效果!!!!!! ⑤ stroke ~ width:边框的宽度 ~ color:边框的颜色 ~ dashWidth:边框虚线段的长度 ~ dashGap:边框的虚线段的间距 ⑥ conner ~ radius:圆角半径,适用于上下左右四个角 ~ topLeftRadius,topRightRadius,BottomLeftRadius,tBottomRightRadius: 依次是左上,右上,左下,右下的圆角值,按自己需要设置! ⑦ padding left,top,right,bottm:依次是左上右下方向上的边距! LayerDrawableStateListDrawable属性： drawable:引用的Drawable位图,我们可以把他放到最前面,就表示组件的正常状态~ state_focused:是否获得焦点 state_window_focused:是否获得窗口焦点 state_enabled:控件是否可用 state_checkable:控件可否被勾选,eg:checkbox state_checked:控件是否被勾选 state_selected:控件是否被选择,针对有滚轮的情况 state_pressed:控件是否被按下 state_active:控件是否处于活动状态,eg:slidingTab state_single:控件包含多个子控件时,确定是否只显示一个子控件 state_first:控件包含多个子控件时,确定第一个子控件是否处于显示状态 state_middle:控件包含多个子控件时,确定中间一个子控件是否处于显示状态 state_last:控件包含多个子控件时,确定最后一个子控件是否处于显示状态 LeveListDrawableTransitionDrawablwInsetDrawableScaleDrawableclipDrawable自定义Drawable]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[春雏集:优雅的活着]]></title>
      <url>%2F2017%2F02%2F22%2F%E6%98%A5%E9%9B%8F%E9%9B%86-%E4%BC%98%E9%9B%85%E7%9A%84%E6%B4%BB%E7%9D%80%2F</url>
      <content type="text"><![CDATA[春雏集:优雅的活着 我和丽丽有相同的观点就是，优雅的活着 每天一句早安，每天一句晚安，相逢总是思念。 她想优雅的活着，我想优雅的陪她，陪伴每个366天，多一天都是值得。 那一天，在回寝室的路上，抬头看落叶的飘零，不知为何，又想起了优雅的活着，优雅的生活，心中的那个念头，牵扯了感触。 今天给她分享了，李宗盛的《山丘》，她说，看不懂。其实很简单，我想，越过每一个山丘，然后陪你。 越发想念的越是醉人的，迷蒙的夜色神游的我俩。 晚安，亲爱的丽丽!我想陪你，过优雅的日子。 我希望有个如你一般的人如山间清爽的风如古城温暖的光从清晨到夜晚由山野到书房只要最后是你就好 ——张嘉佳 《从你的全世界路过》]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android笔记-第一课]]></title>
      <url>%2F2017%2F02%2F20%2FAndroid%E4%B8%8A%E8%AF%BE%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E8%AF%BE%2F</url>
      <content type="text"><![CDATA[Android 简介 通信技术 Android 起源 Android 体系架构 Dalvik 虚拟机Dalvik 包含了一整套的Android运行环境虚拟机，每个app都会分配Dalvik虚拟机来保证相互之间不收干扰，并不保持独立。它的特点是在运行时编译。 ART采用的是安装时就进行编译。 克服瓶颈期的最好办好就是六个字–总结 、归纳、演绎。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[javaweb实战：网上书城]]></title>
      <url>%2F2017%2F02%2F20%2Fjavaweb%E5%AE%9E%E6%88%98%EF%BC%9A%E7%BD%91%E4%B8%8A%E4%B9%A6%E5%9F%8E%2F</url>
      <content type="text"><![CDATA[javawe实战：网上书城 前台项目概述需求分析 1.统一友好的操作界面，具有良好的用户体验。 2.商品分类详尽，可按不同类别查看商品信息。 3.公告栏，本周热卖。 4.网站首页轮播图满足图书广告的需要。 5.用户信息的注册和验证。 6.通过图书名模糊搜索相关商品。 7.通过购物车一次购买多件商品。 8.提供简单的安全模型，用户必须登录后购买商品。 9.用户选择商品后可以在线提交订单。 10.用户可以查看自己的订单信息。 11.设计网站后台，管理网站的各项基本数据. 12.系统运行安全稳定且响应及时。 功能结构 项目预览数据库设计E-R图设计创建数据库和数据表项目前期准备 1.新建一个动态的web项目，名称为BooKStore 2.确定项目运行的环境版本 网上书城项目使用数据库MYSQL5.7版本，Java开发包为1.8 ，开发IDE MyEclipse 2016 3.将本项目所需jar包导入项目的lib文件下。 a.本项目使用c3p0数据源链接数据库，需要c3p0的jar包。 b.项目的jsp页面使用了JSTL标签库，需要jstl.jar和 standard.jar包。 c.项目中使用DBUtils工具处理数据的持久化操作，需要导入BeanUtils工具包。 d.由于在注册时系统还会给注册用户填写的邮箱发送一封激活码，需要导入mail.jar包。 本项目所需jar包如图所示： 4.配置c3p0-config.xml。 在项目Src根目录下创建该文件夹 配置如图所示： 5.编写filter过滤器 a.防止项目请求和响应时出现的乱码情况，需要编写一个过滤器 EcondingFilter.java 来统一全站编码， b.由于本项目分为前后台，只有超级用户才能登陆后台管理系统，所以在用户登录时需要 一个能够判断当前用户是否具有权限登录后台的过滤器，AdminPrivilegeFilter.java 编写工具类DataSourceUtils该类用于获取数据源和数据库的链接 用户注册和登录模块用户注册用户登录购物车模块模块描述实现购物车的基本功能实现订单的相关功能图书信息查询模块商品分类导航栏搜索功能公告板和本周热卖前台小结javawe实战：网上书城 后端管理后台管理系统概述商品管理模块商品管理模块简介实现查询商品列表功能实现添加商品信息功能实现编辑商品信息功能实现删除商品信息功能销售榜单模块订单管理模块订单管理模块简介实现查询订单列表功能实现查看订单详情功能实现删除订单功能后台小结]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[开学笔记]]></title>
      <url>%2F2017%2F02%2F20%2F%E5%BC%80%E5%AD%A6%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[语录 javaEE开学第一课 学习项目开发 项目框架非常的熟 业务走向，业务开发能力 学习要达到精通水平，是为了就业 学习三大框架ssh，只是学习了 编程的魅力，今天你学习了这个知识，过一段时间回过头来，一定会有全新的体验，不同的理解总结：温故而知新 荒唐的背后是什么 看小说，收到小说的的毒害。打架之后面的东西，是勇气。 总结：什么都懂一点，但是不深奥。寻求本质！ 基于MVC开发模式 课程计划–javaweb程序开发进阶 传智播客 jsp进阶 为期 10周 过滤器 监听器 EL表达式 JSP标签库 数据池 文件上传与下载 收现金开发一个 学习的本质，just with youself 新打算 以后将在此记录上课笔记，仅当记录那些年我们学过的 Hello World！ lvc唯爱]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[春雏集-三月花]]></title>
      <url>%2F2017%2F02%2F10%2F%E6%98%A5%E9%9B%8F%E9%9B%86-%E4%B8%89%E6%9C%88%E8%8A%B1%2F</url>
      <content type="text"><![CDATA[三月花二月的小城沾酒的夜色有些隐晦，暖冬的天气有些燥热，燥动的不安是二月的酒气。 盘着白雾的悬梁木板，是二月老人家的烟火，干烈的柴火是温暖的老宅。 二月的小城，我的家，几处青青，三月的花。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[android笔记-Android文件下载]]></title>
      <url>%2F2017%2F02%2F09%2Fandroid%E7%AC%94%E8%AE%B0-Android%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%2F</url>
      <content type="text"><![CDATA[android笔记-Android文件下载单线程下载效果展示： 主要过程：1.新建DownloadLinstener接口2.新建DoadloadTask继承AsycnTak3.新建DownloadService 继承service4.UI和Mainactivity实现 代码 DownloadLinstener接口实现* 1234567891011121314public interface DownloadListener &#123; void onProgress(int progress); void onSuccess(); void onFailed(); void onPaused(); void onCanceled();&#125; DownloadTask实现 * 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176package com.lvc.downloaddemo;import android.os.AsyncTask;import android.os.Environment;import java.io.File;import java.io.IOException;import java.io.InputStream;import java.io.RandomAccessFile;import okhttp3.OkHttpClient;import okhttp3.Request;import okhttp3.Response;/** * Created by lvc on 2017/2/9. */public class DownloadTask extends AsyncTask&lt;String ,Integer ,Integer&gt; &#123; // 下载常量 标识状态 public static final int TYPE_SUCCESS = 0; public static final int TYPE_FAILED = 1; public static final int TYPE_PAUSED = 2; public static final int TYPE_CANCELED = 3; private DownloadListener listener; private Boolean isPaused =false; private Boolean isCanceled = false; private int lastProgress; public DownloadTask(DownloadListener listener) &#123; this.listener = listener; &#125; // 后台执行的下载逻辑 @Override protected Integer doInBackground(String... params) &#123; InputStream in = null; RandomAccessFile savedFile = null; File file = null; try &#123; long downloadLength = 0; String downloadUrl = params[0]; String fileName = downloadUrl.substring(downloadUrl.lastIndexOf(&quot;/&quot;)); String directory = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS).getPath(); file = new File(directory+fileName); if (file.exists())&#123; downloadLength = file.length(); &#125; long contentLength = getContentLength(downloadUrl); if (contentLength == 0)&#123; return TYPE_FAILED; &#125;else if (contentLength == downloadLength)&#123; return TYPE_SUCCESS; &#125; OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder() //断点下载 .addHeader(&quot;RANGE&quot;, &quot;bytes=&quot; + downloadLength + &quot;-&quot;) .url(downloadUrl) .build(); Response response = client.newCall(request).execute(); if (response != null)&#123; in = response.body().byteStream(); savedFile = new RandomAccessFile(file,&quot;rw&quot;); savedFile.seek(downloadLength); byte[] b = new byte[1024]; int total =0; int len ; while ((len = in.read(b)) != -1)&#123; if (isCanceled)&#123; return TYPE_CANCELED; &#125; else if(isPaused)&#123; return TYPE_PAUSED; &#125; else&#123; total += len; savedFile.write(b,0,len); // 计算下载的百分比 int progress = (int)((total+downloadLength)*100 / contentLength); publishProgress(progress); &#125; &#125; response.body().close(); return TYPE_SUCCESS; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; if(in != null)&#123; try &#123; in.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; if(savedFile != null)&#123; try &#123; savedFile.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (isCanceled &amp;&amp; file != null)&#123; file.delete(); &#125; return TYPE_FAILED; &#125; // 更新 下载进度 @Override protected void onProgressUpdate(Integer... values) &#123; int progress = values[0]; if(progress &gt; lastProgress)&#123; listener.onProgress(progress); lastProgress = progress; &#125; &#125; //最终下载的结果 @Override protected void onPostExecute(Integer status) &#123; //super.onPostExecute(status); switch (status) &#123; case TYPE_SUCCESS: listener.onSuccess(); break; case TYPE_FAILED: listener.onFailed(); break; case TYPE_PAUSED: listener.onPaused(); break; case TYPE_CANCELED: listener.onCanceled(); default: break; &#125; &#125; private long getContentLength(String downloadUrl) throws IOException &#123; OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder() .url(downloadUrl) .build(); Response response = client.newCall(request).execute(); if (response != null &amp;&amp; response.isSuccessful())&#123; long contentlength = response.body().contentLength(); response.close(); return contentlength; &#125; return 0; &#125; public void pausedDownload()&#123; isPaused = true; &#125; public void canceledDownlod()&#123; isCanceled = true; &#125;&#125; DwonloadService实现* 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143package com.lvc.downloaddemo;import android.app.Notification;import android.app.NotificationManager;import android.app.PendingIntent;import android.app.Service;import android.content.Intent;import android.graphics.BitmapFactory;import android.os.Binder;import android.os.Environment;import android.os.IBinder;import android.support.v4.app.NotificationCompat;import android.util.Log;import android.widget.Toast;import java.io.File;public class DownloadService extends Service &#123; private DownloadTask downloadTask ; private String downloadUrl = null; int i = 0; private DownloadListener listener = new DownloadListener() &#123; @Override public void onProgress(int progress) &#123; getNotificationManager().notify(1,getNotification(&quot;正在下载...&quot;,progress)); &#125; @Override public void onSuccess() &#123; downloadTask = null; // 下载成功时将前台服务通知关闭，并创建一个下载成功的通知 stopForeground(true); getNotificationManager().notify(1, getNotification(&quot;Download Success&quot;, -1)); Toast.makeText(DownloadService.this, &quot;Download Success&quot;, Toast.LENGTH_SHORT).show(); &#125; @Override public void onFailed() &#123; downloadTask = null; // 下载失败时将前台服务通知关闭，并创建一个下载失败的通知 stopForeground(true); getNotificationManager().notify(1, getNotification(&quot;Download Failed&quot;, -1)); Toast.makeText(DownloadService.this, &quot;Download Failed&quot;, Toast.LENGTH_SHORT).show(); &#125; @Override public void onPaused() &#123; downloadTask = null; Toast.makeText(DownloadService.this, &quot;Paused&quot;, Toast.LENGTH_SHORT).show(); &#125; @Override public void onCanceled() &#123; downloadTask = null; stopForeground(true); Toast.makeText(DownloadService.this, &quot;Canceled&quot;, Toast.LENGTH_SHORT).show(); &#125; &#125; ; private DownloadBinder mBinder =new DownloadBinder(); /* public DownloadService() &#123; &#125;*/ @Override public IBinder onBind(Intent intent) &#123; return mBinder; &#125; class DownloadBinder extends Binder&#123; public void startDownload(String url)&#123; if(downloadUrl == null)&#123; downloadUrl =url; downloadTask = new DownloadTask(listener); downloadTask.execute(downloadUrl); startForeground(1,getNotification(&quot;正在下载...&quot;,0)); Log.i(&quot;判断点击次数&quot;, &quot;startDownload: &quot;+i); i++; Toast.makeText(DownloadService.this, &quot;正在下载...&quot;, Toast.LENGTH_SHORT).show(); &#125; &#125; public void pauseDownload()&#123; if(downloadTask !=null)&#123; downloadTask.pausedDownload(); &#125; &#125; public void cancelDownload()&#123; if(downloadTask != null)&#123; downloadTask.canceledDownlod(); &#125;else&#123; if(downloadUrl != null)&#123; //取消下载时需要将文件删除，并通知关闭 String fileName = downloadUrl.substring(downloadUrl.lastIndexOf(&quot;/&quot;)); String directory = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS).getPath(); File file = new File(directory + fileName); if(file.exists())&#123; file.delete(); &#125; getNotificationManager().cancel(1); stopForeground(true); Toast.makeText(DownloadService.this, &quot;Canceled&quot;, Toast.LENGTH_SHORT).show(); &#125; &#125; &#125; &#125; // 获取通知管理器 private NotificationManager getNotificationManager()&#123; return (NotificationManager) getSystemService(NOTIFICATION_SERVICE); &#125; //通知详情 private Notification getNotification(String title,int progress)&#123; // Intent intent = new Intent(this,MainActivity.class); // PendingIntent pi = PendingIntent.getActivities(this,0,new Intent[]&#123;intent&#125;,0); Intent intent = new Intent(this, MainActivity.class); PendingIntent pi = PendingIntent.getActivity(this, 0, intent, 0); NotificationCompat.Builder builder = new NotificationCompat.Builder(this); builder.setSmallIcon(R.mipmap.ic_launcher); builder.setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher)); builder.setContentIntent(pi); builder.setContentTitle(title); if(progress &gt;= 0)&#123; builder.setContentText(progress + &quot;%&quot;); builder.setProgress(100,progress,false); &#125; return builder.build(); &#125;&#125; Mainactivity实现 UI布局简单就不贴了* 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394package com.lvc.downloaddemo;import android.Manifest;import android.content.ComponentName;import android.content.Intent;import android.content.ServiceConnection;import android.content.pm.PackageManager;import android.os.IBinder;import android.support.annotation.NonNull;import android.support.v4.app.ActivityCompat;import android.support.v4.content.ContextCompat;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.Toast;public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; private DownloadService.DownloadBinder downloadBinder; private ServiceConnection connection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName componentName, IBinder iBinder) &#123; downloadBinder = (DownloadService.DownloadBinder) iBinder; &#125; @Override public void onServiceDisconnected(ComponentName componentName) &#123; &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button startDownload = (Button) findViewById(R.id.btn_start); Button pauseDownload = (Button) findViewById(R.id.btn_paused); Button cancelDownload = (Button) findViewById(R.id.btn_cancel); startDownload.setOnClickListener(this); pauseDownload.setOnClickListener(this); cancelDownload.setOnClickListener(this); Intent intent = new Intent(this,DownloadService.class); startService(intent); bindService(intent,connection,BIND_AUTO_CREATE); if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) &#123; ActivityCompat.requestPermissions(MainActivity.this, new String[]&#123; Manifest.permission. WRITE_EXTERNAL_STORAGE &#125;, 1); &#125; &#125; @Override public void onClick(View view) &#123; if (downloadBinder == null) &#123; return; &#125; switch (view.getId()) &#123; case R.id.btn_start: String url = &quot;http://www.runoob.com/wp-content/uploads/2015/09/DownLoadDemo1.zip&quot;; downloadBinder.startDownload(url); break; case R.id.btn_paused: downloadBinder.pauseDownload(); break; case R.id.btn_cancel: downloadBinder.cancelDownload(); break; default: break; &#125; &#125; @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; switch (requestCode) &#123; case 1: if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] != PackageManager.PERMISSION_GRANTED) &#123; Toast.makeText(this, &quot;拒绝权限将无法使用程序&quot;, Toast.LENGTH_SHORT).show(); finish(); &#125; break; default: &#125; &#125; @Override protected void onDestroy() &#123; super.onDestroy(); unbindService(connection); &#125;&#125; 多线程下载 多线程的下载流程 获取网络连接 本地磁盘创建相同大小的空文件 计算每条线程需从文件哪个部分开始下载，结束 依次创建，启动多条线程来下载网络资源的指定部分 核心代码：12]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[android笔记-HttpURLConnection]]></title>
      <url>%2F2017%2F02%2F07%2Fandroid%E7%AC%94%E8%AE%B0-HttpURLConnection%2F</url>
      <content type="text"><![CDATA[android笔记-HttpURLConnection报错 调用InputStream in = connection.getErrorStream(); 报错 主要代码 使用okhttp直接上代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788package com.lvc.nnetworktest.util;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.net.HttpURLConnection;import java.net.URL;import okhttp3.OkHttpClient;import okhttp3.Request;import okhttp3.Response;/** * Created by lvc on 2017/2/7. * 网络请求util * 封装了 httpURLConnection &amp; okhttp3 */public class HtppUtil &#123; public static void sendHttpRequest(final String address,final HttpCallbackListener listener)&#123; new Thread(new Runnable() &#123; @Override public void run() &#123; HttpURLConnection connection = null; //InputStream in =null; try &#123; URL url = new URL(address); connection = (HttpURLConnection) url.openConnection(); connection.setRequestMethod(&quot;GET&quot;); connection.setConnectTimeout(8000); connection.setReadTimeout(8000); connection.setDoInput(true); connection.setDoOutput(true); InputStream in = connection.getErrorStream(); BufferedReader reader = new BufferedReader(new InputStreamReader(in)); StringBuilder response = new StringBuilder(); String line; while((line =reader.readLine())!=null)&#123; response.append(line); &#125; if(listener != null)&#123; listener.onFinish(response.toString()); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); if(listener != null)&#123; listener.onError(e); &#125; &#125;finally &#123; if(connection != null)&#123; connection.disconnect(); &#125; /* if (in != null)&#123; try &#123; in.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;*/ &#125; &#125; &#125;).start(); &#125; public interface HttpCallbackListener&#123; void onFinish(String response); void onError(Exception e); &#125; /** * okhttp3 */ public static void sendOkhttpRequest(String address , okhttp3.Callback callback)&#123; OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder() .url(address) .build(); client.newCall(request).enqueue(callback); //调用回调 &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[闲言碎语-西游降魔篇]]></title>
      <url>%2F2017%2F02%2F06%2F%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD-%E8%A5%BF%E6%B8%B8%E9%99%8D%E9%AD%94%E7%AF%87%2F</url>
      <content type="text"><![CDATA[西游真的是那个西游吗许久不见，或许是一种情怀！可这又有什么关系呢？佛是什么？你又是什么？我又是什么？西游真的是西游吗？22部天竺真经真的能普度众生吗？度的人，应该是他自己吧。 一生所爱 是被用坏了的情怀吗？终究你我将不复存在关于执念你我懂多少不同的人有不同世界一生真的能爱个够吗陈先生历经千辛万苦只寻普度众生的良药可是大爱小爱说不清道不明在制服猪刚鬣的之时孙先生出了一个法子在月圆之夜，绝山之巅段小姐翩然起舞，宛若谪仙，人间不应有一生所爱的歌声，纵然是情怀作祟。 我的西游我希望寻找自己的西游之路，不为普度众生只为度我自己。西游终究是被烙印在骨子里，流淌的血液在轰轰的燃烧着，可是红尘真的有 真 善 美 ？愿意相信的谎言，我愿意，那就有。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[android笔记-调用摄像头相册]]></title>
      <url>%2F2017%2F02%2F06%2Fandroid%E7%AC%94%E8%AE%B0-%E8%B0%83%E7%94%A8%E6%91%84%E5%83%8F%E5%A4%B4%E7%9B%B8%E5%86%8C%2F</url>
      <content type="text"><![CDATA[调用摄像头调用摄像头拍照获取图片 Demo：效果展示 重要代码123456789101112131415161718192021//创建File 对象，用于存储拍照后的图片File outputImage = new File(getExternalCacheDir(),&quot;output_image.jsp&quot;);try &#123; if(outputImage.exists())&#123; outputImage.delete(); &#125; outputImage.createNewFile();&#125;catch (IOException e)&#123; e.printStackTrace();&#125;if(Build.VERSION.SDK_INT&gt;=24)&#123; imageUri = FileProvider.getUriForFile(MainActivity.this,&quot;com.example.cramea.fileprovider&quot;, outputImage);&#125;else&#123; imageUri = Uri.fromFile(outputImage);&#125;//启动相机程序Intent intent = new Intent(&quot;android.media.action.IMAGE_CAPTURE&quot;);intent.putExtra(MediaStore.EXTRA_OUTPUT,imageUri);startActivityForResult(intent,TAKE_PHOTO); 从相册中选择图片全部代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208package com.lvc.cameraalbumtest;import android.Manifest;import android.annotation.TargetApi;import android.app.Activity;import android.content.ContentUris;import android.content.Intent;import android.content.pm.PackageManager;import android.database.Cursor;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.net.Uri;import android.os.Build;import android.provider.DocumentsContract;import android.provider.MediaStore;import android.support.annotation.NonNull;import android.support.v4.app.ActivityCompat;import android.support.v4.content.ContextCompat;import android.support.v4.content.FileProvider;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.ImageView;import android.widget.Toast;import java.io.File;import java.io.FileNotFoundException;import java.io.IOException;public class MainActivity extends AppCompatActivity &#123; public static final int TAKE_PHOTO = 1; public static final int CHOOSE_PHOTO = 2; private Button takephoto ; private Button choosephoto ; private ImageView pictrue ; private Uri imageUri ; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); /** * 1.获取实例 * 2.绑定监听事件 * */ takephoto = (Button) findViewById(R.id.take_photo); choosephoto = (Button) findViewById(R.id.choose_from_album); pictrue = (ImageView) findViewById(R.id.picture); takephoto.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; //创建File 对象，用于存储拍照后的图片 File outputImage = new File(getExternalCacheDir(),&quot;output_image.jsp&quot;); try &#123; if(outputImage.exists())&#123; outputImage.delete(); &#125; outputImage.createNewFile(); &#125;catch (IOException e)&#123; e.printStackTrace(); &#125; if(Build.VERSION.SDK_INT&gt;=24)&#123; imageUri = FileProvider.getUriForFile(MainActivity.this,&quot;com.example.cramea.fileprovider&quot;, outputImage); &#125;else&#123; imageUri = Uri.fromFile(outputImage); &#125; //启动相机程序 Intent intent = new Intent(&quot;android.media.action.IMAGE_CAPTURE&quot;); intent.putExtra(MediaStore.EXTRA_OUTPUT,imageUri); startActivityForResult(intent,TAKE_PHOTO); &#125; &#125;); choosephoto.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; if(ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED)&#123; ActivityCompat.requestPermissions(MainActivity.this,new String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;,1); &#125;else&#123; openAlbum(); &#125; &#125; &#125;); &#125; /** * */ private void openAlbum()&#123; Intent intent =new Intent(&quot;android.intent.action.GET_CONTENT&quot;); intent.setType(&quot;image/*&quot;); startActivityForResult(intent,CHOOSE_PHOTO); &#125; @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; // super.onActivityResult(requestCode, resultCode, data); switch (requestCode)&#123; case TAKE_PHOTO: try &#123; Bitmap bitmap = BitmapFactory.decodeStream(getContentResolver() .openInputStream(imageUri)); pictrue.setImageBitmap(bitmap); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; break; case CHOOSE_PHOTO: if(resultCode == RESULT_OK )&#123; //判断手机系统版本号 if(Build.VERSION.SDK_INT&gt;=19)&#123; //4.4及以上版本使用这个方法处理图片 handleImageOnKiKat(data); &#125;else&#123; //4.4以下版本使用这个方法处理图片 handleImageBeforeKiKat(data); &#125; &#125; break; default: break; &#125; &#125; private void handleImageBeforeKiKat(Intent data) &#123; Uri uri = data.getData(); String imagepath = getImagePath(uri,null); displayImage(imagepath); &#125; @TargetApi(19) private void handleImageOnKiKat(Intent data) &#123; String imagePath= null; Uri uri = data.getData(); if(DocumentsContract.isDocumentUri(this,uri))&#123; String docId = DocumentsContract.getDocumentId(uri); if(&quot;com.android.providers.media.documents&quot;.equals(uri.getAuthority()))&#123; String id = docId.split(&quot;:&quot;)[1]; String selection = MediaStore.Images.Media._ID+&quot;=&quot;+id; imagePath = getImagePath(MediaStore.Images.Media.EXTERNAL_CONTENT_URI,selection); &#125;else if(&quot;com.android.providers.downloads.documents&quot;.equals(uri.getAuthority()))&#123; Uri contentUri = ContentUris.withAppendedId(Uri.parse(&quot;content://downloads/public_downloads&quot;),Long.valueOf(docId)); imagePath = getImagePath(contentUri,null); &#125; &#125;else if(&quot;content&quot;.equalsIgnoreCase(uri.getScheme()))&#123; imagePath = getImagePath(uri,null); &#125;else if(&quot;file&quot;.equalsIgnoreCase(uri.getScheme()))&#123; imagePath = uri.getPath(); &#125; displayImage(imagePath); &#125; @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; //super.onRequestPermissionsResult(requestCode, permissions, grantResults); switch (requestCode)&#123; case 1: if(grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED )&#123; openAlbum(); &#125;else&#123; Toast.makeText(this,&quot;you denied the permisson&quot;,Toast.LENGTH_SHORT).show(); // openAlbum(); &#125; break; default: break; &#125; &#125; private String getImagePath(Uri uri,String selection)&#123; String path =null; //通过Uri和 selection 来获取真实的图片路径 Cursor cursor = getContentResolver().query(uri,null,selection,null,null); if(cursor != null)&#123; if (cursor.moveToNext())&#123; path = cursor.getString(cursor.getColumnIndex(MediaStore.Images.Media.DATA)); &#125; cursor.close(); &#125; return path; &#125; private void displayImage(String imagePath)&#123; if (imagePath !=null)&#123; Bitmap bitmap = BitmapFactory.decodeFile(imagePath); pictrue.setImageBitmap(bitmap); &#125;else&#123; Toast.makeText(this,&quot;Failed to get image&quot;,Toast.LENGTH_SHORT).show(); &#125; &#125;&#125; 总结 博客真难写想做个记录发现不知道怎么去记汗颜啊]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[android笔记-使用通知]]></title>
      <url>%2F2017%2F02%2F05%2Fandroid%E7%AC%94%E8%AE%B0-%E4%BD%BF%E7%94%A8%E9%80%9A%E7%9F%A5%2F</url>
      <content type="text"><![CDATA[Android笔记-使用通知通知的基本用法 代码 123456789NotificationManager notificationManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE); Notification notification = new NotificationCompat.Builder(this) .setContentTitle(&quot;通知&quot;) .setContentText(&quot;这是一个通知！&quot;) .setWhen(System.currentTimeMillis()) .setSmallIcon(R.mipmap.ic_launcher) .setLargeIcon(BitmapFactory.decodeResource(getResources(),R.mipmap.ic_launcher)) .build(); notificationManager.notify(1,notification); PendingIntent可以简单的理解为延迟执行的Intent pendingIntent 用法1.获取PendingIntent实例： getActivity() getBroadcast() getService() &gt; 以上方法参数相同： * 1 context * 2 0 通常传入0 * 3 Intent对象 * 4 用于确定PendingIntent的行为 有4个值：FLAG_ONE_SHOT FLAG_ON_CREATE FLAG_CANEL_CURRENT FLAG_UPDATE_CURRENT 给通知添加响应 代码12345678910111213Intent intent = new Intent(this,NotificationActivity.class); Intent[] intents = &#123;intent&#125;; PendingIntent pi = PendingIntent.getActivities(this,0,intents,0); NotificationManager notificationManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE); Notification notification = new NotificationCompat.Builder(this) .setContentTitle(&quot;通知&quot;) .setContentText(&quot;这是一个通知！&quot;) .setWhen(System.currentTimeMillis()) .setSmallIcon(R.mipmap.ic_launcher) .setLargeIcon(BitmapFactory.decodeResource(getResources(),R.mipmap.ic_launcher)) .setContentIntent(pi) .build(); notificationManager.notify(1,notification); 取消通知栏上的通知`.setAutoCancel(true)` 在响应的Activity中 添加 1.NotificationManager notificationManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE); 2.notificationManager.cancel(1);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[我的第一篇博客]]></title>
      <url>%2F2017%2F02%2F03%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
      <content type="text"><![CDATA[没有正式文章，仅作为当前内容的测试！ 做个简单的小结昨天在慕课网手记中看到 hexo + github pages 搭建个人博客 经过长时间的学习，再一次觉得开源的伟大! 用了不到一天的时间，杂七杂八的也就成这个样子了 实践才是检验真理的唯一标准 坚持每天学点东西吧。这也算还了我一个小愿望！2017 任重而道远! 下一步，开发一个APP！ ——Lvc]]></content>
    </entry>

    
  
  
</search>
