<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[mybatis入门到精通:(二)入门实战]]></title>
      <url>%2F2017%2F03%2F28%2Fmybatis%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A-%E4%BA%8C-%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98%2F</url>
      <content type="text"><![CDATA[开篇有益 项目已经发布到Github本篇主要是对 入门篇 的代码实现。你好吗？:blush: 搭建 mybatis 开发环境 使用的mysql数据库，建数据库bd_mybaits ，新建表user 创建项目Mybatis3，引入mybatis-3.4.2.jar jar包以及mysql驱动包mybatis-3.4.2.jar 引入模板 Configuration.xml小技巧： D:\WEB\mybatis\mybatis-3-mybatis-3.4.2\src\test\java\org\apache\ibatis\submitted\complex_property我的mybatis源码包解压目录如上，在这个目录下可以找到配置模板如图： configuration.xml12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;settings&gt; &lt;setting name=&quot;useGeneratedKeys&quot; value=&quot;true&quot;/&gt; &lt;setting name=&quot;useColumnLabel&quot; value=&quot;true&quot;/&gt; &lt;/settings&gt; &lt;!-- &lt;typeAliases&gt; &lt;typeAlias alias=&quot;UserAlias&quot; type=&quot;org.apache.ibatis.submitted.complex_property.User&quot;/&gt; &lt;/typeAliases&gt; --&gt;// 环境配置 &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;&gt; &lt;property name=&quot;&quot; value=&quot;&quot;/&gt; &lt;/transactionManager&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/db_mybatis&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;sa&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;lvc159357&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt;// 映射文件 &lt;mappers&gt; &lt;mapper resource=&quot;&quot;/&gt; &lt;mapper resource=&quot;&quot;/&gt; &lt;package name=&quot;&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 项目包层次结构基本讲解：src.party.pjc| /dao 数据访问 /date 配置文件包 /db 获取SqlSession 类 /model 模型层 /test 测试类 配置Mybatis 开发Mybatis 的90%是在配置文件xml中，使用流程: 配置configuration.xml 12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;settings&gt; &lt;setting name=&quot;useGeneratedKeys&quot; value=&quot;true&quot;/&gt; &lt;setting name=&quot;useColumnLabel&quot; value=&quot;true&quot;/&gt; &lt;/settings&gt; &lt;!-- &lt;typeAliases&gt; &lt;typeAlias alias=&quot;UserAlias&quot; type=&quot;org.apache.ibatis.submitted.complex_property.User&quot;/&gt; &lt;/typeAliases&gt; --&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;&gt; &lt;property name=&quot;&quot; value=&quot;&quot;/&gt; &lt;/transactionManager&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/db_mybatis&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;sa&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;lvc159357&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=&quot;party/pjc/date/User.xml&quot;/&gt; &lt;mapper resource=&quot;party/pjc/date/NewsInfoMapper.xml&quot;/&gt; &lt;package name=&quot;party.pjc.dao&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 配置domel层中的pojo 映射文件，命名方式：类名.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;User&quot;&gt; &lt;resultMap type=&quot;party.pjc.model.User&quot; id=&quot;UserResult&quot;&gt; &lt;id column=&quot;id&quot; jdbcType=&quot;INTEGER&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;username&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;username&quot;/&gt; &lt;result column=&quot;password&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;password&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;finduserbyid&quot; parameterType=&quot;int&quot; resultMap=&quot;UserResult&quot; &gt; SELECT * FROM user WHERE id = #&#123;id:INTEGER&#125; &lt;/select&gt; &lt;select id=&quot;version&quot; parameterType=&quot;long&quot; resultType=&quot;int&quot;&gt; SELECT version FROM user WHERE id = #&#123;id,jdbcType=INTEGER&#125; &lt;/select&gt; &lt;delete id=&quot;delete&quot; parameterType=&quot;party.pjc.model.User&quot;&gt; DELETE FROM user WHERE id = #&#123;id:INTEGER&#125; &lt;/delete&gt; &lt;insert id=&quot;insert&quot; parameterType=&quot;party.pjc.model.User&quot; useGeneratedKeys=&quot;true&quot;&gt; INSERT INTO user ( username, password ) VALUES ( #&#123;username,jdbcType=VARCHAR&#125;, #&#123;password,jdbcType=VARCHAR&#125; ) &lt;/insert&gt; &lt;update id=&quot;update&quot; parameterType=&quot;party.pjc.model.User&quot;&gt; UPDATE user SET username = #&#123;username,jdbcType=VARCHAR&#125;, password = #&#123;password,jdbcType=VARCHAR&#125; WHERE id = #&#123;id,jdbcType=INTEGER&#125; &lt;/update&gt; &lt;!-- Unique constraint check --&gt; &lt;select id=&quot;isUniqueUsername&quot; parameterType=&quot;map&quot; resultType=&quot;boolean&quot;&gt; SELECT (count(*) = 0) FROM user WHERE ((#&#123;userId,jdbcType=BIGINT&#125; IS NOT NULL AND id != #&#123;userId,jdbcType=BIGINT&#125;) OR #&#123;userId,jdbcType=BIGINT&#125; IS NULL) other than me AND (username = #&#123;username,jdbcType=VARCHAR&#125;) &lt;/select&gt;&lt;/mapper&gt; 使用注解类映射 ，与上一步实现的功能是一样的。 12345678910111213141516171819202122232425262728293031package party.pjc.dao;import java.util.List;import org.apache.ibatis.annotations.Insert;import org.apache.ibatis.annotations.Result;import org.apache.ibatis.annotations.Results;import org.apache.ibatis.annotations.Select;import party.pjc.model.User;public interface UserMapper &#123; int deleteByPrimaryKey(Integer id); @Insert(&quot; INSERT INTO user ( username,password) VALUES( #&#123;username,jdbcType=VARCHAR&#125;,#&#123;password,jdbcType=VARCHAR&#125; )&quot;) int insert(User user); int insertSelective(User user); User selectByPrimaryKey(Integer id); int updateByPrimaryKeySelective(User user); int updateByPrimaryKey(User user); @Results(id = &quot;userResult&quot;, value = &#123; @Result(property = &quot;id&quot;, column = &quot;id&quot;, id = true), @Result(property = &quot;username&quot;, column = &quot;username&quot;), @Result(property = &quot;password&quot;, column = &quot;password&quot;)&#125;) @Select(&quot; select * from user order by id desc &quot;) List&lt;User&gt; findAll();&#125; 测试 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137package party.pjc.dao;import java.io.IOException;import java.util.List;import org.apache.ibatis.session.SqlSession;import party.pjc.db.SqlSessionHelp;import party.pjc.model.User;public class UserDao &#123; public User findUserById(int id)&#123; SqlSession sqlSession =null; User user2=null; try &#123; sqlSession =SqlSessionHelp.getSqlSession(); user2= sqlSession.selectOne(&quot;finduserbyid&quot;, id); sqlSession.commit(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;finally &#123; if(sqlSession!=null)&#123; sqlSession.close(); &#125; &#125; return user2; &#125; public void deleteUser(User user)&#123; SqlSession sqlSession =null; int result=0; try &#123; sqlSession =SqlSessionHelp.getSqlSession(); result= sqlSession.delete(&quot;delete&quot;, user); System.out.println(&quot;删除的行数：&quot;+result); sqlSession.commit(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;finally &#123; if(sqlSession!=null)&#123; sqlSession.close(); &#125; &#125; &#125; public int updateUser(User user)&#123; SqlSession sqlSession =null; int result=0; try &#123; sqlSession =SqlSessionHelp.getSqlSession(); result= sqlSession.update(&quot;update&quot;,user); System.out.println(&quot;删除的行数：&quot;+result); sqlSession.commit(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;finally &#123; if(sqlSession!=null)&#123; sqlSession.close(); &#125; &#125; return result; &#125; public int saveUser(User user)&#123; SqlSession sqlSession =null; int result=0; try &#123; sqlSession =SqlSessionHelp.getSqlSession(); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); result= userMapper.insert(user); System.out.println(&quot;删除的行数：&quot;+result); sqlSession.commit(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;finally &#123; if(sqlSession!=null)&#123; sqlSession.close(); &#125; &#125; return result; &#125; public List&lt;User&gt; findAll()&#123; SqlSession sqlSession =null; List&lt;User&gt; userList =null; try &#123; sqlSession =SqlSessionHelp.getSqlSession(); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); userList= userMapper.findAll(); sqlSession.commit(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;finally &#123; if(sqlSession!=null)&#123; sqlSession.close(); &#125; &#125; return userList; &#125; public static void main(String[] args) &#123; UserDao userDao = new UserDao(); User user= new User(); user.setUsername(&quot;lisi&quot;); user.setPassword(&quot;3838438&quot;); List&lt;User&gt; users = userDao.findAll(); for (User user2 : users) &#123; System.out.println(user2); &#125; &#125;&#125; 其他方法就不一一测试了。 入门案例就完成了，但是肯定还有好多疑问，接下来就是讲解一些关键知识点，直接贴的代码有点莫名其妙哈 关键知识点通过上面的图，能了解一定 mybatis 的架构。这样理解起来，就比较轻松的啦。看一段代码：1234567891011121314151617181920public User findUserById(int id)&#123; SqlSession sqlSession =null; User user=null; try &#123; String resoure =&quot;party/pjc/date/Configuration.xml&quot;; Reader reader = Resources.getResourceAsReader(resoure); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader); SqlSession sqlSession= sqlSessionFactory.openSession(); user= sqlSession.selectOne(&quot;finduserbyid&quot;, id); sqlSession.commit(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;finally &#123; if(sqlSession!=null)&#123; sqlSession.close(); &#125; &#125; return user; &#125; 上述代码，就是除了配置文件外的10%的代码了。不理解上述的意思的，先去看一下 ==&gt;mybatis入门到精通:(一)入门 案例中，使用了两种不同的映射方式： 1.基于xml 2.基于注解两种实现方式，在configuration.xml 的 配置为：12345&lt;mappers&gt; &lt;mapper resource=&quot;party/pjc/date/User.xml&quot;/&gt; &lt;mapper resource=&quot;party/pjc/date/NewsInfoMapper.xml&quot;/&gt; &lt;package name=&quot;party.pjc.dao&quot;/&gt; &lt;/mappers&gt; 贴一下，两种方式的对应：在实际开发中，这两种映射器 是结合起来用的。因为最初设计时,MyBatis 是一个 XML 驱动的框架。配置信息是基于 XML 的,而且 映射语句也是定义在 XML 中的。而到了 MyBatis 3,有新的可用的选择了。MyBatis 3 构建 在基于全面而且强大的 Java 配置 API 之上。这个配置 API 是基于 XML 的 MyBatis 配置的 基础,也是新的基于注解配置的基础。注解提供了一种简单的方式来实现简单映射语句,而 不会引入大量的开销。 注意 不幸的是,Java 注解限制了它们的表现和灵活。尽管很多时间都花调查,设计和 实验上,最强大的 MyBatis 映射不能用注解来构建,那并不可笑。C#属性(做示例)就没 有这些限制,因此 MyBatis.NET 将会比 XML 有更丰富的选择。也就是说,基于 Java 注解 的配置离不开它的特性。 小工具 代码自动生成工具使用方法，资源里有，你也可以者百度或google一下。 链接：http://pan.baidu.com/s/1qXJ3lqW 密码：dam9 目前接触到就这些了，思路清晰，要get到啊。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[mybatis入门到精通:(一)入门]]></title>
      <url>%2F2017%2F03%2F28%2Fmybatis%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A-%E4%B8%80-%E5%85%A5%E9%97%A8%2F</url>
      <content type="text"><![CDATA[开篇有益，先了解什么是mybatis点我MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以对配置和原生Map使用简单的 XML 或注解，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。 mybatis3 入门安装要使用 MyBatis， 只需将 mybatis-x.x.x.jar 文件置于 classpath 中即可。如果使用 Maven 来构建项目，则需将下面的 dependency 代码置于 pom.xml 文件中：12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;x.x.x&lt;/version&gt;&lt;/dependency&gt; 从 XML 中构建 SqlSessionFactory每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为中心的。SqlSessionFactory 的实例可以通过 SqlSessionFactoryBuilder 获得。而 SqlSessionFactoryBuilder 则可以从 XML 配置文件或一个预先定制的 Configuration 的实例构建出 SqlSessionFactory 的实例。 从 XML 文件中构建 SqlSessionFactory 的实例非常简单，建议使用类路径下的资源文件进行配置。但是也可以使用任意的输入流(InputStream)实例，包括字符串形式的文件路径或者 file:// 的 URL 形式的文件路径来配置。MyBatis 包含一个名叫 Resources 的工具类，它包含一些实用方法，可使从 classpath 或其他位置加载资源文件更加容易。123String resource = &quot;org/mybatis/example/mybatis-config.xml&quot;;InputStream inputStream = Resources.getResourceAsStream(resource);sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); XML 配置文件（configuration XML）中包含了对 MyBatis 系统的核心设置，包含获取数据库连接实例的数据源（DataSource）和决定事务作用域和控制方式的事务管理器（TransactionManager）。XML 配置文件的详细内容后面再探讨，这里先给出一个简单的示例：1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=&quot;org/mybatis/example/BlogMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 当然，还有很多可以在XML 文件中进行配置，上面的示例指出的则是最关键的部分。要注意 XML 头部的声明，用来验证 XML 文档正确性。environment 元素体中包含了事务管理和连接池的配置。mappers 元素则是包含一组 mapper 映射器（这些 mapper 的 XML 文件包含了 SQL 代码和映射定义信息）。 不使用 XML 构建 SqlSessionFactory如果你更愿意直接从 Java 程序而不是 XML 文件中创建 configuration，或者创建你自己的 configuration 构建器，MyBatis 也提供了完整的配置类，提供所有和 XML 文件相同功能的配置项。123456DataSource dataSource = BlogDataSourceFactory.getBlogDataSource();TransactionFactory transactionFactory = new JdbcTransactionFactory();Environment environment = new Environment(&quot;development&quot;, transactionFactory, dataSource);Configuration configuration = new Configuration(environment);configuration.addMapper(BlogMapper.class);SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(configuration); 注意该例中，configuration 添加了一个映射器类（mapper class）。映射器类是 Java 类，它们包含 SQL 映射语句的注解从而避免了 XML 文件的依赖。不过，由于 Java 注解的一些限制加之某些 MyBatis 映射的复杂性，XML 映射对于大多数高级映射（比如：嵌套 Join 映射）来说仍然是必须的。有鉴于此，如果存在一个对等的 XML 配置文件的话，MyBatis 会自动查找并加载它（这种情况下， BlogMapper.xml 将会基于类路径和 BlogMapper.class 的类名被加载进来）。具体细节稍后讨论。 从 SqlSessionFactory 中获取 SqlSession既然有了 SqlSessionFactory ，顾名思义，我们就可以从中获得 SqlSession 的实例了。SqlSession 完全包含了面向数据库执行 SQL 命令所需的所有方法。你可以通过 SqlSession 实例来直接执行已映射的 SQL 语句。例如：123456SqlSession session = sqlSessionFactory.openSession();try &#123; Blog blog = (Blog) session.selectOne(&quot;org.mybatis.example.BlogMapper.selectBlog&quot;, 101);&#125; finally &#123; session.close();&#125; 诚然这种方式能够正常工作，并且对于使用旧版本 MyBatis 的用户来说也比较熟悉，不过现在有了一种更直白的方式。使用对于给定语句能够合理描述参数和返回值的接口（比如说BlogMapper.class），你现在不但可以执行更清晰和类型安全的代码，而且还不用担心易错的字符串字面值以及强制类型转换。 例如：12345678SqlSession session = sqlSessionFactory.openSession();try &#123; BlogMapper mapper = session.getMapper(BlogMapper.class); Blog blog = mapper.selectBlog(101);&#125; finally &#123; session.close();&#125;现在我们来探究一下这里到底是怎么执行的。 探究已映射的 SQL 语句现在，或许你很想知道 SqlSession 和 Mapper 到底执行了什么操作，而 SQL 语句映射是个相当大的话题，可能会占去文档的大部分篇幅。不过为了让你能够了解个大概，这里会给出几个例子。 在上面提到的两个例子中，一个语句应该是通过 XML 定义，而另外一个则是通过注解定义。先看 XML 定义这个，事实上 MyBatis 提供的全部特性可以利用基于 XML 的映射语言来实现，这使得 MyBatis 在过去的数年间得以流行。如果你以前用过 MyBatis，这个概念应该会比较熟悉。不过 XML 映射文件已经有了很多的改进，随着文档的进行会愈发清晰。这里给出一个基于 XML 映射语句的示例，它应该可以满足上述示例中 SqlSession 的调用。123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;org.mybatis.example.BlogMapper&quot;&gt; &lt;select id=&quot;selectBlog&quot; resultType=&quot;Blog&quot;&gt; select * from Blog where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 对于这个简单的例子来说似乎有点小题大做了，但实际上它是非常轻量级的。在一个 XML 映射文件中，你想定义多少个映射语句都是可以的，这样下来，XML 头部和文档类型声明占去的部分就显得微不足道了。文件的剩余部分具有很好的自解释性。在命名空间“org.mybatis.example.BlogMapper”中定义了一个名为“selectBlog”的映射语句，这样它就允许你使用指定的完全限定名“org.mybatis.example.BlogMapper.selectBlog”来调用映射语句，就像上面的例子中做的那样： Blog blog = (Blog) session.selectOne(&quot;org.mybatis.example.BlogMapper.selectBlog&quot;, 101);你可能注意到这和使用完全限定名调用 Java 对象的方法是相似的，之所以这样做是有原因的。这个命名可以直接映射到在命名空间中同名的 Mapper 类，并在已映射的 select 语句中的名字、参数和返回类型匹配成方法。这样你就可以向上面那样很容易地调用这个对应 Mapper 接口的方法。不过让我们再看一遍下面的例子： BlogMapper mapper = session.getMapper(BlogMapper.class);Blog blog = mapper.selectBlog(101);第二种方法有很多优势，首先它不是基于字符串常量的，就会更安全；其次，如果你的 IDE 有代码补全功能，那么你可以在有了已映射 SQL 语句的基础之上利用这个功能。 提示命名空间的一点注释 命名空间（Namespaces）在之前版本的 MyBatis 中是可选的，容易引起混淆因此是没有益处的。现在的命名空间则是必须的，目的是希望能比只是简单的使用更长的完全限定名来区分语句更进一步。 命名空间使得你所见到的接口绑定成为可能，尽管你觉得这些东西未必用得上，你还是应该遵循这里的规定以防哪天你改变了主意。出于长远考虑，使用命名空间，并将它置于合适的 Java 包命名空间之下，你将拥有一份更加整洁的代码并提高了 MyBatis 的可用性。 命名解析：为了减少输入量，MyBatis 对所有的命名配置元素（包括语句，结果映射，缓存等）使用了如下的命名解析规则。 完全限定名（比如“com.mypackage.MyMapper.selectAllThings”）将被直接查找并且找到即用。 短名称（比如“selectAllThings”）如果全局唯一也可以作为一个单独的引用。如果不唯一，有两个或两个以上的相同名称（比如“com.foo.selectAllThings ”和“com.bar.selectAllThings”），那么使用时就会收到错误报告说短名称是不唯一的，这种情况下就必须使用完全限定名。对于像 BlogMapper 这样的映射器类（Mapper class）来说，还有另一招来处理。它们的映射的语句可以不需要用 XML 来做，取而代之的是可以使用 Java 注解。比如，上面的 XML 示例可被替换如下：12345package org.mybatis.example;public interface BlogMapper &#123; @Select(&quot;SELECT * FROM blog WHERE id = #&#123;id&#125;&quot;) Blog selectBlog(int id);&#125; 对于简单语句来说，注解使代码显得更加简洁，然而 Java 注解对于稍微复杂的语句就会力不从心并且会显得更加混乱。因此，如果你需要做很复杂的事情，那么最好使用 XML 来映射语句。 选择何种方式以及映射语句的定义的一致性对你来说有多重要这些完全取决于你和你的团队。换句话说，永远不要拘泥于一种方式，你可以很轻松的在基于注解和 XML 的语句映射方式间自由移植和切换。 作用域（Scope）和生命周期理解我们目前已经讨论过的不同作用域和生命周期类是至关重要的，因为错误的使用会导致非常严重的并发问题。 提示 对象生命周期和依赖注入框架 依赖注入框架可以创建线程安全的、基于事务的 SqlSession 和映射器（mapper）并将它们直接注入到你的 bean 中，因此可以直接忽略它们的生命周期。如果对如何通过依赖注入框架来使用 MyBatis 感兴趣可以研究一下 MyBatis-Spring 或 MyBatis-Guice 两个子项目。 SqlSessionFactoryBuilder这个类可以被实例化、使用和丢弃，一旦创建了 SqlSessionFactory，就不再需要它了。因此 SqlSessionFactoryBuilder 实例的最佳作用域是方法作用域（也就是局部方法变量）。你可以重用 SqlSessionFactoryBuilder 来创建多个 SqlSessionFactory 实例，但是最好还是不要让其一直存在以保证所有的 XML 解析资源开放给更重要的事情。 SqlSessionFactorySqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由对它进行清除或重建。使用 SqlSessionFactory 的最佳实践是在应用运行期间不要重复创建多次，多次重建 SqlSessionFactory 被视为一种代码“坏味道（bad smell）”。因此 SqlSessionFactory 的最佳作用域是应用作用域。有很多方法可以做到，最简单的就是使用单例模式或者静态单例模式。 SqlSession每个线程都应该有它自己的 SqlSession 实例。SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。绝对不能将 SqlSession 实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。也绝不能将 SqlSession 实例的引用放在任何类型的管理作用域中，比如 Serlvet 架构中的 HttpSession。如果你现在正在使用一种 Web 框架，要考虑 SqlSession 放在一个和 HTTP 请求对象相似的作用域中。换句话说，每次收到的 HTTP 请求，就可以打开一个 SqlSession，返回一个响应，就关闭它。这个关闭操作是很重要的，你应该把这个关闭操作放到 finally 块中以确保每次都能执行关闭。下面的示例就是一个确保 SqlSession 关闭的标准模式：123456SqlSession session = sqlSessionFactory.openSession();try &#123; // do work&#125; finally &#123; session.close();&#125; 在你的所有的代码中一致性地使用这种模式来保证所有数据库资源都能被正确地关闭。 映射器实例（Mapper Instances）映射器是创建用来绑定映射语句的接口。映射器接口的实例是从 SqlSession 中获得的。因此从技术层面讲，映射器实例的最大作用域是和 SqlSession 相同的，因为它们都是从 SqlSession 里被请求的。尽管如此，映射器实例的最佳作用域是方法作用域。也就是说，映射器实例应该在调用它们的方法中被请求，用过之后即可废弃。并不需要显式地关闭映射器实例，尽管在整个请求作用域（request scope）保持映射器实例也不会有什么问题，但是很快你会发现，像 SqlSession 一样，在这个作用域上管理太多的资源的话会难于控制。所以要保持简单，最好把映射器放在方法作用域（method scope）内。下面的示例就展示了这个实践：1234567SqlSession session = sqlSessionFactory.openSession();try &#123; BlogMapper mapper = session.getMapper(BlogMapper.class); // do work&#125; finally &#123; session.close();&#125; 注:本文来自mybatis3参考文档]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CET-4:83day go on]]></title>
      <url>%2F2017%2F03%2F26%2FCET-4-83day-go-on%2F</url>
      <content type="text"><![CDATA[]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[闲言碎语-霸王别姬]]></title>
      <url>%2F2017%2F03%2F26%2F%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD-%E9%9C%B8%E7%8E%8B%E5%88%AB%E5%A7%AC%2F</url>
      <content type="text"><![CDATA[沉重到无法再沉重，一个大男人，含着眼泪看着孤独的你。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SSH:S2SH整合篇]]></title>
      <url>%2F2017%2F03%2F26%2FSSH-S2SH%E6%95%B4%E5%90%88%E7%AF%87%2F</url>
      <content type="text"><![CDATA[整合SSH 基于XML配置准备整合环境SSH 使用的版本：123struts2-2.3.24-allspring-framework-4.0.1.RELEASEhibernate-release-4.3.5.Final Eclipse Java EE IDE for Web Developers.Version: Neon.1 Release RC3 (4.6.1RC3)JDK : 1.8.0_77mysql: Ver 14.14 Distrib 5.7.15, for Win64 (x86_64)项目的包预览： 准备数据库环境创建数据库test 配置 Struts2 环境 1.导入相关jar包 2.在web.xml中配置 核心过滤器 12345678910&lt;!-- 添加对struts2的支持 --&gt; &lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 3.在src下添加 Struts.xml配置文件 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE struts PUBLIC &quot;-//Apache Software Foundation//DTD Struts Configuration 2.3//EN&quot; &quot;http://struts.apache.org/dtds/struts-2.3.dtd&quot;&gt; &lt;struts&gt; &lt;!-- 开发模式 --&gt; &lt;constant name=&quot;struts.devMode&quot; value=&quot;true&quot;&gt;&lt;/constant&gt; &lt;package name=&quot;s2sh&quot; namespace=&quot;/&quot; extends=&quot;struts-default&quot;&gt; &lt;/package&gt;&lt;/struts&gt; 配置 Spring 环境 1.导入所依赖的jar包 2.在src下添加 applicationContext.xml 配置文件 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:jee=&quot;http://www.springframework.org/schema/jee&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd&quot;&gt; &lt;/beans&gt; 3.在web.xml文件中配置Spring监听器 12345678910&lt;!-- 添加对spring的支持 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- 定义Spring监听器，加载Spring --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; 配置 Hibernate 环境 1.导入相关jar包 2.在src下添加核心配置文件 hibernate.cfg.xml123456789101112131415161718192021222324252627&lt;?xml version=&apos;1.0&apos; encoding=&apos;utf-8&apos;?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC &quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;!-- Database connection settings --&gt; &lt;property name=&quot;connection.driver_class&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=&quot;connection.url&quot;&gt;jdbc:mysql://localhost:3306/test&lt;/property&gt; &lt;property name=&quot;connection.username&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;connection.password&quot;&gt;lvc159357&lt;/property&gt; &lt;!--方言--&gt; &lt;property name=&quot;dialect&quot;&gt;org.hibernate.dialect.MySQL5Dialect&lt;/property&gt; &lt;!-- 显示sql语句 --&gt; &lt;property name=&quot;show_sql&quot;&gt;true&lt;/property&gt; &lt;!-- 自动更新 --&gt; &lt;property name=&quot;hbm2ddl.auto&quot;&gt;update&lt;/property&gt; &lt;mapping resource=&quot;party/pjc/entity/user.hbm.xml&quot;/&gt; &lt;/session-factory&gt; &lt;/hibernate-configuration&gt; Spring 和 Hibernate 的整合介绍Spring 和 Hibernate 的整合，需要添加一个支持整合的spring-orm-4.0.1.RELEASE.jar，可以在Spring解压目录的libs目录找到。在整合之前，首先需要了解三个重要的对象 HibernateTemplate：相当于 Hibernate 的 session 可以直接操作PO类，依赖于SessionFactory LocalSessionFactoryBean：获得sessionFactory HibernateTransactionManager：Hibernate 的事物管理器使用 Hibernate.cfg.xml 1.entity层User.JavaUser的 映射文件 User.hbm.xml 2.Dao层接口 UserDao.java实现类 UserDaoImpl.java 3.service层接口 UserService.java实现类 UserServiceImpl.java 4.Spring 配置文件中进行配置 5.测试 不使用 Hibernate.cfg.xml（还没写完） Spring 与 Struts2 的整合Spring 与 Struts2整合的目的是将struts2中的Action 实例化工作交给Spring进行统一管理。 介绍在Spring和Struts2整合时，需要导入jar包struts2-spring-plugin-2.3.24.jar，该jar在已下载的Struts2解压目录中lib下找到 Action 创建交予 Spring（没写） Struts2 自身创建 Action1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE struts PUBLIC &quot;-//Apache Software Foundation//DTD Struts Configuration 2.3//EN&quot; &quot;http://struts.apache.org/dtds/struts-2.3.dtd&quot;&gt; &lt;struts&gt; &lt;!-- &lt;constant name=&quot;struts.action.extension&quot; value=&quot;action&quot; /&gt; --&gt; &lt;!-- 开发模式 --&gt; &lt;constant name=&quot;struts.devMode&quot; value=&quot;true&quot;&gt;&lt;/constant&gt; &lt;package name=&quot;s2sh&quot; namespace=&quot;/&quot; extends=&quot;struts-default&quot;&gt; &lt;action name=&quot;login&quot; class=&quot;party.pjc.action.UserAction&quot;&gt; &lt;result &gt;success.jsp&lt;/result&gt; &lt;result name=&quot;error&quot;&gt;index.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 测试基于注解 整合 SSH在开始整合之前，需要知道在那些地方进行注解： 1.不需要，entity 类的映射文件，采用注解开发User.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package party.pjc.entity;import javax.persistence.Column;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.GenerationType;import javax.persistence.Id;import javax.persistence.Table;import org.springframework.stereotype.Component;@Entity@Table(name=&quot;user&quot;)@Componentpublic class User &#123; @Id @GeneratedValue(strategy=GenerationType.AUTO) private Integer id; @Column(name=&quot;username&quot;) private String username; @Column(name=&quot;password&quot;) private String password; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; @Override public String toString() &#123; return &quot;User [id=&quot; + id + &quot;, username=&quot; + username + &quot;, password=&quot; + password + &quot;]&quot;; &#125;&#125; 2.各种 Spring Bean 即 Dao层，Service层，Action层 dao层 在类名上行 添加 @Repository() service层 在类名上行 添加 @Service() Action层 在类名上行 添加 @Controller 3.配置文件的修改 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:jee=&quot;http://www.springframework.org/schema/jee&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd&quot;&gt; &lt;!-- 自动扫描注解方式配置的Bean类文件 --&gt; &lt;context:component-scan base-package=&quot;party.pjc&quot;&gt;&lt;/context:component-scan&gt; &lt;!-- 定义数据源 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt; &lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/test&quot;&gt; &lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;lvc159357&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 1.配置 sessionFactory --&gt; &lt;bean id=&quot;sessionFactory&quot; class=&quot;org.springframework.orm.hibernate4.LocalSessionFactoryBean&quot; &gt; &lt;property name=&quot;dataSource&quot;&gt; &lt;ref bean=&quot;dataSource&quot; /&gt; &lt;/property&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:hibernate.cfg.xml&quot;/&gt; &lt;!-- 自动扫描注解方式配置的hibernate类文件 --&gt; &lt;property name=&quot;packagesToScan&quot;&gt; &lt;list&gt; &lt;value&gt;party.pjc.entity&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!--2. 配置Hibernate 模板 --&gt; &lt;bean id=&quot;hibernateTemplate&quot; class=&quot;org.springframework.orm.hibernate4.HibernateTemplate&quot;&gt; &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot; &gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 3. 配置Dao --&gt; &lt;!-- &lt;bean id=&quot;userDao&quot; class=&quot;party.pjc.dao.impl.UserDaoImpl&quot;&gt; &lt;property name=&quot;hibernateTemplate&quot; ref=&quot;hibernateTemplate&quot;&gt;&lt;/property&gt; &lt;/bean&gt; --&gt; &lt;!--4. 配置Service --&gt; &lt;!-- &lt;bean id=&quot;userService&quot; class=&quot;party.pjc.service.impl.UserServiceImpl&quot;&gt; &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt;&lt;/property&gt; &lt;/bean&gt; --&gt; &lt;!-- 配置事务管理器 --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.orm.hibernate4.HibernateTransactionManager&quot;&gt; &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot; /&gt; &lt;/bean&gt; &lt;!-- 配置事务通知属性 --&gt; &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;!-- 定义事务传播属性 --&gt; &lt;tx:attributes&gt; &lt;tx:method name=&quot;insert*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;update*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;edit*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;save*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;add*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;new*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;set*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;remove*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;delete*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;change*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;get*&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;true&quot; /&gt; &lt;tx:method name=&quot;find*&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;true&quot; /&gt; &lt;tx:method name=&quot;load*&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;true&quot; /&gt; &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;true&quot; /&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 配置事务切面 --&gt; &lt;aop:config&gt; &lt;aop:pointcut id=&quot;serviceOperation&quot; expression=&quot;execution(* party.pjc.service..*.*(..))&quot; /&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;serviceOperation&quot; /&gt; &lt;/aop:config&gt;&lt;/beans&gt; 4.Struts2 也可以采用注解，但是我没用过，有兴趣的同学可以百度或google一下。 那些年踩过的坑HibernateTemplate 引入错误首先我们来介绍下，Hibernate3 and Hibernate4 怎么调用 HIbernateTemplateHibernate3 操作数据库 使用的是 HibernateTemplate ,配置如下： 123456789101112&lt;-- 1.配置 sessionFactory --&gt; &lt;bean id=&quot;sessionFactory&quot; class=&quot;org.springframework.orm.hibernate4.LocalSessionFactoryBean&quot; &gt; &lt;property name=&quot;dataSource&quot;&gt; &lt;ref bean=&quot;dataSource&quot; /&gt; &lt;/property&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:hibernate.cfg.xml&quot;/&gt; &lt;/bean&gt; &lt;--2. 配置Hibernate 模板 --&gt; &lt;bean id=&quot;hibernateTemplate&quot; class=&quot;org.springframework.orm.hibernate3.HibernateTemplate&quot;&gt; &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot; &gt;&lt;/property&gt; &lt;/bean&gt; 当然 Hibernate4 也是支持我们使用HibernateTemplate ,但是官方更推荐我们使用sessionFactory来看一下来者操作数据库：使用Hibernate模板12345678910111213141516171819public class UserDaoImpl implements UserDao&#123; @Autowired private HibernateTemplate hibernateTemplate; public HibernateTemplate getHibernateTemplate() &#123; return hibernateTemplate; &#125; public void setHibernateTemplate(HibernateTemplate hibernateTemplate) &#123; this.hibernateTemplate = hibernateTemplate; &#125; @Override public void save(User user) &#123; this.hibernateTemplate.save(user); &#125; 使用sessionFactory123456789101112131415161718192021222324public class BaseDaOImpl&lt;T&gt; implements BaseDao&lt;T&gt; &#123; private SessionFactory sessionFactory; public SessionFactory getSessionFactory() &#123; return sessionFactory; &#125; @Autowired public void setSessionFactory(SessionFactory sessionFactory) &#123; this.sessionFactory = sessionFactory; &#125; private Session getCurrentSession() &#123; return sessionFactory.getCurrentSession(); &#125; public Serializable save(T o) &#123; return this.getCurrentSession().save(o); &#125; public void delete(T o) &#123; this.getCurrentSession().delete(o); &#125; 显然，我们在使用Hibernate4 时，应该使用sessionFactory Hibernate 事务管理 错误来看一下，报错的地方1234567891011121314@Overridepublic void delete(final Object entity, final LockMode lockMode) throws DataAccessException &#123; executeWithNativeSession(new HibernateCallback&lt;Object&gt;() &#123; @Override public Object doInHibernate(Session session) throws HibernateException &#123; checkWriteOperationAllowed(session); if (lockMode != null) &#123; session.buildLockRequest(new LockOptions(lockMode)).lock(entity); &#125; session.delete(entity); return null; &#125; &#125;);&#125; 我们可以看到delete方法里面调用了checkWriteOperationAllowed(session);1234567protected void checkWriteOperationAllowed(Session session) throws InvalidDataAccessApiUsageException &#123; if (isCheckWriteOperations() &amp;&amp; session.getFlushMode().lessThan(FlushMode.COMMIT)) &#123; throw new InvalidDataAccessApiUsageException( &quot;Write operations are not allowed in read-only mode (FlushMode.MANUAL): &quot;+ &quot;Turn your Session into FlushMode.COMMIT/AUTO or remove &apos;readOnly&apos; marker from transaction definition.&quot;); &#125;&#125; 进去之后，我们找到了报错语句的源头，解决办法:加上事务相关的配置12345678910111213141516171819202122232425262728293031323334&lt;!-- 配置事务管理器 --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.orm.hibernate4.HibernateTransactionManager&quot;&gt; &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot; /&gt; &lt;/bean&gt; &lt;!-- 配置事务通知属性 --&gt; &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;!-- 定义事务传播属性 --&gt; &lt;tx:attributes&gt; &lt;tx:method name=&quot;insert*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;update*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;edit*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;save*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;add*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;new*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;set*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;remove*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;delete*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;change*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;get*&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;true&quot; /&gt; &lt;tx:method name=&quot;find*&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;true&quot; /&gt; &lt;tx:method name=&quot;load*&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;true&quot; /&gt; &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;true&quot; /&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 配置事务切面 --&gt; &lt;aop:config&gt; &lt;aop:pointcut id=&quot;serviceOperation&quot; expression=&quot;execution(* party.pjc.service..*.*(..))&quot; /&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;serviceOperation&quot; /&gt; &lt;/aop:config&gt; Hibernate 不能删除数据INFO: HHH000114: Handling transient entity in delete processing 首选我们来理解下 Hibernate 持久化对象的状态 1.瞬时态（transient） 2.持久态（persistent） 3.托管态（detached） 来看一下我们自己代码：1234567891011121314@Test public void test() &#123; User user = new User(); user.setUsername(&quot;lvc&quot;); user.setPassword(&quot;123456&quot;); String xmlPath=&quot;applicationContext.xml&quot;; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(xmlPath); UserService userService =(UserService) applicationContext.getBean(&quot;userService&quot;); // userService.findUserById(1); // userService.saveUser(user); userService.deleteUser(user); // System.out.println(userService.findUserById(1)); System.out.println(userService.findAllUser()); &#125; 我们 new 了一个对象，这个对象 就是瞬时态尚未于Hibernate Session 关联起来。而我调用的最底层方法session.delete(entity) 传入的是持久化的对象，而不是我new出来的 所以，我们改进一下userService.deleteUser(userService.findUserById(3)); 那这样删除数据，是不是很麻烦呢？先留下一个问题。 整合不使用 hibernate.cfg.xml报了一个，不是活动的事务。我特么就傻眼了。 我们说下，不使用hibernate.cfg.xml的流程， * 1.删掉Hibernate.cfg.xml 文件 * 2.将配置信息全部写在，applicationContext.xml 的sessionFactory Bean中 * 3.修改UserDaoImpl.java 继承 HibernateDateSupport，直接获取 getHibernateTemplate() 大致就是上述的流程，但是一次没有成功，上课没网O(∩_∩)O哈哈~。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CET-4:84day Dream it Possible]]></title>
      <url>%2F2017%2F03%2F25%2FCET-4-84day-Dream-it-Possible%2F</url>
      <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394词根、词缀预习表catal- 下面 catalog n.目录，目录册brilli 发光 brilliant adj. 光辉的；卓越的calcul 计算 calculate 计算，计划log，logu 说话 slogan 标语，广告语-able (形容词后缀)可···得的，能···的，具有某种性质的 comparable 可比较的，比得上的-acity (名词后缀) 表状态、情况 capatity 容量；能力；身份-ate (动词、形容词、名词后缀) 做，使···；如···形状，具有··的；表人、职位， considerate 考虑周到的，体贴的-ary (名词后缀) 表人、物、场所 boundary 分界线，边界-et (名词后缀)小 booklet 小册子-ure (名词后缀) 表行为、状态 adventure 奇遇，冒险活动--------------------------------------------------boring bounce (使)弹起，反弹；颠婆；弹，反弹bound round 圆boundary bracket 括号；把···归为一类brake 闸，刹车；制动；刹住（车），用闸使（车）放慢速度brandbrass 黄铜，黄铜器，铜管乐器bravebreadth 宽度；幅度，幅面breakdown 垮，衰竭；损坏，故障；倒塌breastbreed 品种；繁殖；养育，培育；酿成，产生breeze 微风，和风；飘然而行freeze 冰冻brick 砖，砖块，砖状物bride 新娘brief 简短的，短暂的；向···介绍基本情况，做···的提要；概要，摘要brilliantbroom 扫帚brow 额，眉，眉毛bubble 泡；冒泡；沸腾bucket 水桶，吊桶；铲斗budget 预算，预算拨款；规划，安排；编预算；低廉的，收费公道cabbage cabin 小屋，船舱，机舱cabinet 橱，柜；内阁cable 线，索，电缆；电报calculate calculator 计算器，计算者calendar 日历，历书，历法calm 静的，平静的；（使）镇静camelcampaign 战役，运动；参加（或发起）运动；参加竞选campuscanal 运河，渠道；管cancelcanser 癌，癌症；肿瘤candidate 候选人；投考者，申请求职者candy 糖果capable 有能力的，有才能的capacity capture 捕获，俘获；夺得carbon 碳carbon dioxide 二氧化碳career 生涯，职业，经历Korea 韩国cargo 船货，获取carpenter 木匠，木工carpet 地毯carriage 客车厢，四轮 .-&apos; _..`. / .&apos;_.&apos;.&apos; | .&apos; (.)`. ;&apos; ,_ `. .--.__________.&apos; ; `.;-&apos;| ./ /| | /`..&apos;`-._ _____, ..&apos; / | | | |\ \ / /| | | | \ \ / / | | | | \ \ /_/ |_| |_| \_\ |__\ |__\ |__\ |__\车carrier 运输工具，运载工具；带菌者；载重架，置物架carrot 胡萝卜cart 运货车cartoon cashcashier 出纳cassette 盒式录音带cast 投，扔，抛；浇筑，演员表，全体演员；石膏绷带；铸型，铸件 casual 偶然的；非正式的；临时的；不定期的；漠不关心的，冷淡的catalogcataloguecategory 种类，类，类别cattle 牛，牲口，家畜]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CET-4:86day 时间赶不上了 老B]]></title>
      <url>%2F2017%2F03%2F22%2FCET-4-86day-%E6%97%B6%E9%97%B4%E8%B5%B6%E4%B8%8D%E4%B8%8A%E4%BA%86-%E8%80%81B%2F</url>
      <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687词根、词缀预习表bene 善，好 benefit 有益于，得意bio 生物，生命 biology 生物学，生态学cap(t),cep(t) [同下] capture 捕获，俘获ceive,cip 拿，抓，握住 fic 做 artificial 人工的，人为的rupt 断裂-ant (形容词和名称后缀)···的；表人、物 relevant 有关的；切题的-logy (名词后缀)···学 technology 工艺学，工艺-ery (名词后缀)场所；表行为、状态；行业 gallery 画廊，美术馆-oon (名词后缀)表物 Balloon 气球-ward (形容词、副词后缀)方位，方向 downward 向下的-------backgroundbackwardbacon 咸肉bacteria 细菌baggage bake 烤，烘，焙balancebalconyballoonbanband 乐队；群，伙；带；条纹；波段；用带绑扎bang 巨响，枪声；猛击；banktupt 破产的bannerbarber 理发师bare 赤裸的；光秃的，无遮盖的；刚刚够得，勉强的；露出，显露blank 空白hollow 指物体中空的vacant 指本应利用起来但闲置起来的东西barely 仅仅，只不过，几乎不bargainbark 吠，叫；树皮barn 谷仓；牲口棚barrel 桶；圆筒；枪管barrier 栅栏；检票口；屏障；障碍，隔阂baseballbasicallybasisbat 蝙蝠；球棒，球拍bathe 洗澡；游泳battery 电池（组），蓄电池；排炮，炮组；一系列，一套baybeam 梁，横梁；束，柱；笑容，喜色；面如喜色；定向发出，播送beanbeard 胡须，络腮胡子bearing 举止，风度；方位，方向感；影响beast 兽，野兽；牲畜；凶残的人，beggarbehalfbehave 表现，举止；运转，做出反应behaviorbeing 存在；生物；生命belief 信任，相信，信念belovedbeneath 在···下方；底下，次于；在···掩盖下，连···也不值得，有失···的身份 beneficialbenefitbesides 而且；除···之外betbeyondBible 圣经bidbillionbindbiologybiotechnologybladeblankblanket 毛毯，毯子，羊毛毯blastbleed 勒索···的钱；出血，流血；泌脂blend 混合bloodybloom 花，开花，开花期；青春焕发（的时期）；boardboastbold 勇敢的；鲁莽的；粗体的；醒目的bolt 螺栓，插销，门闩bondboomboostbootborderbore 使厌烦；钻，挖；令人讨厌的人]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CET-4:88day 最后的 A 老大]]></title>
      <url>%2F2017%2F03%2F21%2FCET-4-87day-%E6%9C%80%E5%90%8E%E7%9A%84-A-%E8%80%81%E5%A4%A7%2F</url>
      <content type="text"><![CDATA[YOU ARE MAN！你知道凌晨两点钟的南昌吗？下着雨和噼里啪啦的键盘声，此刻，和窗外的雨更配哦。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071architect 建筑师，设计师；缔造者architeture 建筑学；建筑式样，建筑风格argueargument arise 出现；由···引起；起身,起床arithmetic 算术，四则运算arouse 引起；唤起，唤醒arrange 安排，筹备，整理arrangementarrest 逮捕arrival 到达，到来；到达者，到达物arrowartificial 人工的，人为的；矫揉造作的；模拟的artistic 艺术的，艺术家的；富有艺术性的，精美的；精彩的ash 灰，灰末；骨灰ashamedasideaspect 方面；（建筑物的）朝向，方向；样子，外表assemble 集合，召集；装配 (强调为特定目标而聚集)aaccumulate 累积，积聚 (通过有规律的增加而聚集)gather (指把分散的事物聚集在一起)collect (指有计划地为一定目的而有选择的收集)pile 推起，堆叠assembly 立法机构；议会；集合；集会的人们；装配，组装assess 对（财产等）估价；评论，评价asset 资产，财产；有价值的特性或技能，优点assign 指派，分配，布置（作业）；指定（时间，地点等）assignment 任务，指定的作业；分配，指派assist 援助，帮助，协助assistanceassistant 助手，助理，助教；助理的，辅助的associate (在思想上)把···联系在一起；使联合；结合；交往；伙伴，同事；副的association 协会，团体；联合，交往assum 假定，假设，臆断；承担，担任；呈现assumptionassure 使确定；确保，向···保证astonish 使惊讶，使吃惊athlete 运动员，体育家atmosphere 大气，空气；气氛，环境atomic 原子的，原子能的，原子武器的attach 缚，系，贴；附加；使依恋，使喜爱；使嘱咐；认为有（重要，责任等）attackattain 达到，获得，努力attitude 态度，看法；姿势attorney 律师；（业务或法律事务上的）代理人attract 吸引，引起···注意attractionattractiveattribute 把···归因于；属性audienceaudioauthorauthority 官方；权利；当权者。行政管理机构；权威，专家auto 汽车automatic 自动的，机械的；不假思索的，无意识的；必然的，自然的；自动手枪automobile 汽车，机动车auxiliary 辅助的，附属的；后背的available 现成可使用的，通用的；可取的；联系的；可得到的ready 准备就绪的approachable 可靠近的，可接近的probable 很可能的，大概的acceptable 可接受的advisable 可取的；适当的，贤明的avenue 林荫道，道路，大街average 平均数，平均；平均的，平常的avoid 避免，躲开，撤销awaitaward 奖，奖品，判定；授予，给予；判给，裁定awful 令人不愉快的，（感到）难过的 ；非常的，极大的awkward 笨拙的，尴尬的；难操纵的，使用不便的；不灵活的ax 斧子 每天一点语法 代名词1.人称代词 人称代名词的人称及 格（表现） it 的用法 it 可表示天候，时间，地点···等等 It a it 可表示某一状况，多半是说话的人和听的人都能了解知道的特定状况 it 可当假主词 ==&gt; 代替一件事 It is difficult to learn Spanish.(不定词) It’s important that you should tell the truth.（连词）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Struts2框架:项目实战-简单的新闻发布系统]]></title>
      <url>%2F2017%2F03%2F21%2FStruts2%E6%A1%86%E6%9E%B6-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98-%E7%AE%80%E5%8D%95%E7%9A%84%E6%96%B0%E9%97%BB%E5%8F%91%E5%B8%83%E7%B3%BB%E7%BB%9F%2F</url>
      <content type="text"><![CDATA[项目分析技术的可行性本项目采用MVC模式，利用Struts2框架实现MVC。 首先要说的是，mvc是一种架构模式，它是一种思想，而不是一种框架，但是struts2是一种框架，它运用的是mvc思想。。以下是struts2和mvc的一一对应关系：核心控制器：FilterDispatcher FilterDispatcher是Struts2框架的核心控制器，该控制器作为一个Filter运行在Web应用中，它负责拦截所有用户请求，当用户请求到达时，该Filter会过滤用户请求。如果用户请求以.action结尾，该请求将被转入Struts2框架处理。业务控制器组件：用户Action业务控制器组件就是用户实现Action类的实例，Action类里通常包含了一个execute方法，该方法返回一个字符串–该字符串就是一个逻辑视图名，每个字符串对应一个视图名。每个Action都要处理一个用户请求，而用户请求总是包含了指定URL。当FilterDispatcher拦截到用户请求后，根据请求的URL和Action处理URL之间的对应关系来处理转发。模型组件 模型组件已经超出了MVC框架的覆盖范围。对于Struts2框架而言，通常没有为模型组件的实现提供太多的帮助。 J2EE应用里的模型组件，通常指系统的业务逻辑组件以及隐藏其下的DAO、领域对象等组件。通常，MVC框架里的业务控制器会调用模型组件的方法来处理用户请求。也就是说，业务逻辑控制器不会对用户请求进行任何实际处理，用户请求最终由模型组件负责处理。业务控制器只是是间负责调度的调试器，这也是称Action为控制器的原因。视图组件 Struts2允许使用其他的模板技术，如FreeMarker、Velocity作为视图技术。当Struts2的控制器返回逻辑视图名时，逻辑视图并未与任何的视图技术关联，仅仅是返回一个字符串，该字符器作为逻辑视图名。 当在struts.xml文件中配置Action时，不仅需要指定Action的name属性和class属性，还要为Action元素指定系列result了元素，每个result子元素定义一个逻辑视图和物理视图之间的映射。当没有在result子元素中指定type属性时，默认使用JSP作为视图资源引用自：Struts2与Mvc的关系 简单的项目需求草图 效果展示]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CET-4:88day 这样不行啊]]></title>
      <url>%2F2017%2F03%2F20%2FCET-4-88day-%E8%BF%99%E6%A0%B7%E4%B8%8D%E8%A1%8C%E5%95%8A%2F</url>
      <content type="text"><![CDATA[思考一个问题 A你大爷这样子背，非我所愿，非我所意so，应该改变策略恩，先眼熟它，一回生二回熟。我们还是好朋友，我是为了国家为了人民才学英语的！ 12345678910111213141516171819202122232425262728293031323334353637angleangel 天使ankle n. 踝，踝关节anniversaryannoyannualannoymous adj. 匿名的；无名的；无特色的anticipate vt. 预料，期望，预望；提前使用；先于···行动antique 古董；过时的anxiety 焦虑，忧虑；渴望，热望anxious 忧虑的anyhowanywayapartapartment 公寓apologizeapology 道歉，认错，谢罪apparent 表面上的，明显的appeal 上诉，呼吁，申诉；感染力，吸引力appearance 出现，来到；外观appetite 食欲，胃口；欲望applause appliance 用具，器具，机械；家电applicant 申请人applicable 能应用的；合适的，适当的application 申请，申请书；施用，涂抹；应用，实施；实用性apply appoint 任命，委任；约定，指定（时间，地点）appointment appreciate 重视，赏识。领会，体会；感谢；增长approach 向···靠近；靠近appropriate 恰当的，适当的approval 赞成，同意，批准approveapproximate 近似的；近似；估计arbitrary 随心所欲，专断的astrophysics 天体物理学 每天一点语法 be 动词 · 一般动词的过去式be 动词的过去式： was 和 were 现在式 过去式 be动词 am was be动词 is was be动词 are were “ 要看语句的时态: 如果是一般过去时,就用was/were 如果是一般现在时,就用am/is/are 如果是一般将来时,就用will be 然后看主语的人称及复数形式: 一般过去时： 第一人称和第三人称的单数形式，则用was 第一人称和第二人称、第三人称的复数，则用were 一般现在时： 第一人称单数形式，用am 第三人称单数形式，用is 第一人称复数、第二人称、第三人称的复数形式，则用are 一般将来时： will be 口诀：一般时态有关be动词的口诀 我用am，你用are，is连着他她它，单数主语用is，复数主语全用are“]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CET-4:89day 还是 A 系列]]></title>
      <url>%2F2017%2F03%2F20%2FCET-4-89day-%E8%BF%98%E6%98%AF-A-%E7%B3%BB%E5%88%97%2F</url>
      <content type="text"><![CDATA[还是 A 系列A 系列 高频词汇，3个 Word List尼玛 差不多300 个单词长这么大，还没有看过这么多单词 1234567891011121314151617181920212223242526272829303132333435363738394041agent 代理人aggressive 侵略agricultureaidaircraftairlineairportalarmalcoholalertalikeallianceallocateallowallowance 津贴，补贴；零用钱ally 联合，结盟alongsidealphabet 字母表alteralternativealtitude 海拔，高度，高处aluminium 铝iron 铁gold 金silver 银lead 铅tin 锡copper 铜amateum 业余爱好者amazeambassadorambition 雄心，抱负ambulanceamid amongst 在····之中amuse 逗···乐，给···娱乐analyse 分析，分解；解析analysisancestor 祖宗，祖先；原型；先驱anchor 锚；固定，扎根；抛锚；把···系住ancient 古代的，古老的；年老的 打完下来，有点力不从心了革命尚未成功，同志仍需努力！ 恩，竟然还看了be动词 am/is/aredo/dosehava/has第三人称 ，这么奇怪，总是叫它变来变去，中文极好咧。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CET-4:90day 单词你大爷]]></title>
      <url>%2F2017%2F03%2F19%2FCET-4-90day-%E5%8D%95%E8%AF%8D%E4%BD%A0%E5%A4%A7%E7%88%B7%2F</url>
      <content type="text"><![CDATA[单词你大爷 A系列 高频词汇背单词效率太低，一个小时不见得能被得了几个终于完成了 Word List 1but，我连中学词汇都不知道啊 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647accountance 会计工作；会计学accountant 会计人员；会计师accumulate accurancy 准确，精准accurateaccursation 谴责，指控accuseaccustomed 惯常的，习惯的echeachievementacidacknowledgeacquaint 使认识，使了解acquaintance 认识，了解；熟人acquireacquisitionacreactionactiveactivityacuteadaptaddtionaddtionaladequate 足够的，可以胜任的adjustadministrationadmireadmitionadmitadoptadoptive 收养关系的adultadvancedadvantage 优点，优势，好处adventureadvartise 为···做广告，宣传；公告，登广告advertisement 广告advisable 明智的，可取的advocate 拥护，提倡，主张earoplaneeffecteffection 情感，爱，爱慕afford 担负得起；提供affterwordagency 经办，代理；代理处；专门行政部门agenda 议事日程]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CET-4:92day 战起烽火不连天]]></title>
      <url>%2F2017%2F03%2F17%2FCET-4-92day-%E6%88%98%E8%B5%B7%E7%83%BD%E7%81%AB%E4%B8%8D%E8%BF%9E%E5%A4%A9%2F</url>
      <content type="text"><![CDATA[战起青春的热血沸腾，在岁月的成长中消磨殆尽。在渐去渐少的日子里，思考着人生的意义，以及几个月后的告别大学生活，越发越重的生活鸭梨。 英语基础(将从考试大纲的能力要求，个人分十级)：1.词汇：0-12.语法：0-13.阅读能力：0-14.听的能力：0-15.说的能力：0-16.写的能力：0-17.翻译能力：0-1能力要求，参见我做的英语四级脑图 资料准备0.计划1.词汇 《新东方四级词汇 词根+联想 记忆法》2.语法 互联网3.试卷：真题 12345678910111213141516171819202122232425262728单词：abandonabilityaboardabroadabcenceabcentabsoluteabsorbabstractabundantabuseaccademicaccademyaccelerateaccentacceptanceaccessaccidentaccidentalaccommodationaccompanyacceplishaccordaccordanceaccordingaccordinglyaccount]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Struts2框架-拦截器(Interceptor)]]></title>
      <url>%2F2017%2F03%2F16%2FStruts2%E6%A1%86%E6%9E%B6-%E6%8B%A6%E6%88%AA%E5%99%A8-Interceptor%2F</url>
      <content type="text"><![CDATA[学习目标 理解拦截器的工作原理 掌握拦截器的配置和使用 学会自定义拦截器 拦截器概述拦截器（Interceptor）是Struts2的核心组成部分。 它可以动态拦截Action调用的对象，类似Servlet中的过滤器。 Struts2中拦截器是AOP（Aspect-Object—Programming，面向切面编程）的一种实现策略， 是可以“插拔”，需要就插入，不需要就拔出。 拦截器的工作原理通常情况下，拦截器都是以代理方式调用的，它在一个Action 执行前后进行拦截，围绕着Action和Result的执行而执行。 对真正要执行的方法（execute()）进行拦截。首先执行ACtion配置的拦截器，在Action和Result执行之后，拦截器在再次执行（与先前的调用的顺序相反）,在次链式执行的过程中，每一个拦截器在执行execute（）方法前都可以直接返回。 &lt;!-- more --&gt; 拦截器的配置自定义拦截器 1.实现 com.opensymphoy.xwork2.interceptor.Interceptor 123void destroy(); void init(); String intercept(ActionInvocation invocation) throws Exception; 继承 com.opensymphony.xwork2.interceptor.AbstractInterceptor1public String intercept(ActionInvocation invocation) throws Exception 配置拦截器拦截器 1234&lt;interceptors&gt; &lt;interceptor name=&quot;myInterceptor&quot; class=&quot;com.java1234.interceptor.MyInterceptor&quot;&gt;&lt;/interceptor&gt; &lt;interceptor name=&quot;privilege&quot; class=&quot;com.java1234.interceptor.PrivilegeInterceptor&quot;&gt;&lt;/interceptor&gt; &lt;/interceptors&gt; 拦截器栈默认拦截器案例–使用拦截器实现权限控制]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Struts2框架入门]]></title>
      <url>%2F2017%2F03%2F15%2FStruts2%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8%2F</url>
      <content type="text"><![CDATA[Struts2框架系列（一）—— Struts2框架入门Struts2简介什么是Struts2？参见百度百科：Struts2Struts2是一个基于MVC设计模式的Web应用框架，它本质上相当于一个servlet，在MVC设计模式中，Struts2作为控制器(Controller)来建立模型与视图的数据交互。Struts 2是Struts的下一代产品，是在 struts 1和WebWork的技术基础上进行了合并的全新的Struts 2框架。其全新的Struts 2的体系结构与Struts 1的体系结构差别巨大。Struts 2以WebWork为核心，采用拦截器的机制来处理用户的请求，这样的设计也使得业务逻辑控制器能够与ServletAPI完全脱离开，所以Struts 2可以理解为WebWork的更新产品。虽然从Struts 1到Struts 2有着太大的变化，但是相对于WebWork，Struts 2的变化很小。 工作原理Struts2的工作原理图 Struts2de 下载和使用下载Struts 官方网站 http://struts.apache.org/ 使用将下载后的 文件解压 入门案例–Struts2： Hello World！ 1.创建web项目 LvcStruts2 2.添加Struts2的依赖基础jar包 3.在src 根目录下新建 struts.xml 12345678 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE struts PUBLIC &quot;-//Apache Software Foundation//DTD Struts Configuration 2.0//EN&quot; &quot;http://struts.apache.org/dtds/struts-2.0.dtd&quot;&gt;&lt;struts&gt;&lt;/struts&gt; 4.配置web.xml文件 添加 struts2 核心过滤器 12345678910 &lt;filter&gt; &lt;filter-name&gt;Struts2&lt;/filter-name&gt; &lt;filter-class&gt; org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter &lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;Struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 5.新建HelloWorldAction.java 实现 ActionSupport 类 123456789101112 package party.pjc.action;import com.opensymphony.xwork2.ActionSupport;public class HelloWorldAction extends ActionSupport &#123; @Override public String execute() throws Exception &#123; // TODO Auto-generated method stub return SUCCESS; &#125;&#125; 6.配置Struts.xml 文件 123456789101112131415 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE struts PUBLIC &quot;-//Apache Software Foundation//DTD Struts Configuration 2.0//EN&quot; &quot;http://struts.apache.org/dtds/struts-2.0.dtd&quot;&gt;&lt;struts&gt; &lt;package name=&quot;helloWorld&quot; extends=&quot;struts-default&quot;&gt; &lt;action name=&quot;hello&quot; class=&quot;party.pjc.action.HelloWorldAction&quot;&gt; &lt;result name=&quot;success&quot;&gt;helloworld.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 7.新建helloworld.jsp ` &lt;body&gt; Strust2 Hello world! &lt;/body&gt; ` 8.效果]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[自定义 EL 函数]]></title>
      <url>%2F2017%2F03%2F15%2F%E8%87%AA%E5%AE%9A%E4%B9%89-EL-%E5%87%BD%E6%95%B0%2F</url>
      <content type="text"><![CDATA[EL表达式-自定义函数 表达式语言除了可以使用基本的运运算符之外，还可以使用自定义的函数。 通过使用自定义函数，加强了表达式语言功能。 EL表达式函数，主要空能是完成对数据的修改，统一格式化。 使用步骤 1.开发函数处理类，处理类就是普通的 java类；每个函数对应类中的一个静态方法。 2.建立TLD文件，定义表达式函数。 3.在WEB.xml文件中配置（可省略） 4.在jsp 页面引入及使用 案例——自定义 EL 函数防止 HTML 注入 1.开发函数处理类 12345678910111213141516171819202122232425262728293031 package com.lvc.chapter7.utils;public class HTMLFilter &#123; public static String filter(String message) &#123; if (message == null)&#123; return (null); &#125; char content[] = new char[message.length()]; message.getChars(0, message.length(), content, 0); StringBuffer result = new StringBuffer(content.length + 50); for (int i = 0; i &lt; content.length; i++) &#123; switch (content[i]) &#123; case &apos;&lt;&apos;: result.append(&quot;&amp;lt;&quot;); break; case &apos;&gt;&apos;: result.append(&quot;&amp;gt;&quot;); break; case &apos;&amp;&apos;: result.append(&quot;&amp;amp;&quot;); break; case &apos;&quot;&apos;: result.append(&quot;&amp;quot;&quot;); break; default: result.append(content[i]); &#125; &#125; return (result.toString()); &#125;&#125; 2.建立TLD文件 12345678910111213141516171819 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;taglib xmlns=&quot;http://java.sun.com/xml/ns/j2ee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd&quot; version=&quot;2.0&quot;&gt; &lt;tlib-version&gt;1.0&lt;/tlib-version&gt; &lt;short-name&gt;function&lt;/short-name&gt; &lt;uri&gt;/WEB-INF/ElTag.tld&lt;/uri&gt; &lt;function&gt; &lt;name&gt;filter&lt;/name&gt; &lt;function-class&gt; com.lvc.chapter7.utils.HTMLFilter &lt;/function-class&gt; &lt;function-signature&gt; java.lang.String filter(java.lang.String) &lt;/function-signature&gt; &lt;/function&gt;&lt;/taglib&gt; 3.在web.xml下配置 1234567891011121314151617 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;web-app version=&quot;2.5&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;&gt; &lt;jsp-config&gt; &lt;taglib&gt; &lt;!-- 配置标签的引用地址 JSP页面中引用时使用--&gt; &lt;taglib-uri&gt;/WEB-INF/ElTag.tld&lt;/taglib-uri&gt; &lt;!-- 配置标签的TLD文件地址 --&gt; &lt;taglib-location&gt;/WEB-INF/ElTag.tld&lt;/taglib-location&gt; &lt;/taglib&gt; &lt;/jsp-config&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;/web-app&gt; 4.在jsp页面中引入和使用 123456789101112 &lt;%@ page language=&quot;java&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;%@ taglib prefix=&quot;lvc&quot; uri=&quot;/WEB-INF/mytaglib.tld&quot; %&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 用户名:$&#123;name&#125;&lt;br /&gt; 留言:$&#123;message&#125;&lt;br/&gt; 过滤后的留言：$&#123;lvc:filter(message)&#125;&lt;/body&gt;&lt;/html&gt; 显示效果]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[js页面跳转]]></title>
      <url>%2F2017%2F03%2F13%2Fjs%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC%2F</url>
      <content type="text"><![CDATA[js 页面跳转参考资料: &lt; http://www.w3cschool.com.cn &gt; 当前页面 跳转window.location.self=&quot;url&quot;;‘ ‘ 新建窗口 跳转window.open(&quot;URL&quot;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[闲言碎语-心灵访客]]></title>
      <url>%2F2017%2F03%2F11%2F%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD-%E5%BF%83%E7%81%B5%E8%AE%BF%E5%AE%A2%2F</url>
      <content type="text"><![CDATA[《心灵访客》]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[android：卫星式菜单]]></title>
      <url>%2F2017%2F03%2F11%2Fandroid%EF%BC%9A%E5%8D%AB%E6%98%9F%E5%BC%8F%E8%8F%9C%E5%8D%95%2F</url>
      <content type="text"><![CDATA[Android自定义控件实现步骤： * 一、动画 * 二、自定义属性]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[深入理解Android中的自定义属性]]></title>
      <url>%2F2017%2F03%2F11%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Android%E4%B8%AD%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%2F</url>
      <content type="text"><![CDATA[转载请标明出处：http://blog.csdn.net/lmj623565791/article/details/45022631 本文出自:【张鸿洋的博客】 1.引言对于自定义属性，大家肯定都不陌生，遵循以下几步，就可以实现： 自定义一个CustomView(extends View )类 编写values/attrs.xml，在其中编写styleable和item等标签元素 在布局文件中CustomView使用自定义的属性（注意namespace） 在CustomView的构造方法中通过TypedArray获取]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[学习方法：黑马高薪学习方法]]></title>
      <url>%2F2017%2F03%2F05%2F%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%EF%BC%9A%E9%BB%91%E9%A9%AC%E9%AB%98%E8%96%AA%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[学习方法：黑马高薪学习方法原文地址 此文章是黑马老学员给新学员的学习建议，一个来自高薪学员的心声，望仔细耐心看完，这将是你在黑马学习的重要指南。 四个半月的时光转瞬而逝，我如愿以偿地拿到了让自己满意的offer，这都必须归功于黑马辛苦教学的老师以及身边勤奋学习的同学们对我不断地鼓励和支持。在黑马学习期间，我享受到了以前从未有过的充实生活，并且这段人生经历激发了我对技术难以磨灭的热情，这份热情即使在我就职之后依然持续地灼烧着。因此，怀着感恩的心情，我认为自己必须为黑马做点什么，所以才有了这篇关于学习方法的总结。希望学弟学妹们能从这里汲取到有利于自己的学习思路，从而让自己能够用更短的时间学习到更多的知识，利用黑马这优质的平台，让自己在技术的道路上走得更快，更远。 记得入学后不久，我们就进行了第一次测验。然后，同学们学习效率的差距惊人地暴露出来了。令人诧异的是，很多同学学习很辛苦，甚至经常熬夜，但是学习效果并没有预想的那么好。反之，很多同学学习时间很短，但是效果却非常地惊人。于是，我就开始思考是什么原因导致了这种差异？通过与很多同学的沟通和交流，我终于明白学习方法起到了至关重要的作用。那么好的学习方法应该注意哪些方面呢？我认为只要你能够经常问自己下面八个问题，你就可以确定自己是不是走在正轨上。 Question 1：明天会上哪些内容的课程呢？ 如果可以的话，你可以拷贝到往届学长学姐们的笔记，每天利用5分钟的时间大致浏览第二天的课程，从而能够从全局把握课程结构，从而使自己在第二天老师6个小时的狂轰滥炸中不至于处于被动，然后不知道自己所处何处。反之，你就可以化被动为主动，从而可以将6个小时的课程切割成对应于各个知识点的小模块。通过这种方式，你就可以极大地提升自己的听课质量。 Question 2：今天的课程我完全听懂了吗？ 听课质量的高低对学习效果可以说起到了中流砥柱的作用。试想一下，如果你的听课效率质量很高，那么晚上敲代码、复习的时间就可以大大地减少。因为，你不会再对着老师分发的代码和资料问自己一些愚蠢的问题。例如：这段代码是干什么的来着？这个知识点好像完全没听懂。这些令人抓狂的问题会严重挫伤你学习的积极性。因此，如果上课有任何内容没有听懂，那么不要忽略掉，应该把自己想问的问题记录下来，下课之后，立刻通过与同学和老师的讨论解决掉。 Question 3：今天我对哪些问题有疑问呢？ 如果你是抱着积极的学习态度在听课，那么你一定会在上课期间产生各种各样的idea。你可能在想一种代码效果有没有另外一种实现方式，或者另外一种配置方式会有什么效果。这时候，一定要迅速记录下来这些问题，不要占用上课时间跟同学讨论或者自己纠结于此。因为，一旦你这样做，后面的课程你就完全不会在用心听了，这就降低了听课的质量。 Question 4：有疑问的问题自己可以通过网络或者写一些例子得到结果吗？ 产生任何问题之后，不要急于问老师和同学，而是要培养自己独立学习和解决问题的能力。你可以通过网络或者API文档查询到结果，又或者自己写一个例子程序得到答案。如果实在有困难，再向学生和老师求助。这样，可以培养你独立解决问题的能力。毕竟，在公司里，是没有太多人给你全方位的指导和帮助的，不是吗？ Question 5：今天的代码我有敲完吗？ 很多同学有时候会进入一个误区，那就是他认为上课的时候代码已经完全理解了，下课就没有必要再敲这些代码了，这就走向了一个极端。另外一个极端则是认为代码必须自己从头到尾一个字母不漏的敲出来才算掌握了。实际上，代码最重要的是写出思路，然后通过查询API文档完成代码。当然，第一次敲代码的时候最好可以临摹老师的代码，然后再自己独立完成。否则，由于难度太大，可能会打消学习的积极性并且浪费时间在回忆代码上。另外一个需要指出的点是，千万不要给自己拖延的理由，今天的代码今天必须要完成，即使奋战到凌晨2点也在所不惜。如果你拖延到明天，那么再加上第二天的代码量，你会倾向于放弃昨天的代码，甚至对今天的代码也感到厌烦。毕竟学习的时间是有限的，利用一天的时间承担两天的任务量，没有压力才怪呢！ Question 6：我可以对这些代码进行封装或者优化吗？我可以做一些小应用吗？ 任何的知识想要活学活用都必须要经过自我优化并且不断应用从而达到熟能生巧的过程。如果仅仅局限于老师的例子代码，你将会发现自己解决问题的能力并不强，还只是处于粘贴拷贝的码农阶段。但是如果你能够思考这些代码怎么去封装和优化，并且自己试图做一些应用，那么恭喜你，你就在朝着架构师以及高级软件工程师的方向发展了。 Question 7：今天我的任务完成了吗？ “今日事，今日毕”。古人的这句话说明了执行力的重要性。所以，千万不要给自己任何拖延的理由。不要说，今天几个玩的很好的哥们邀我玩dota，今天的任务明天我一定做！如果这样的话，你会发现，第二天你已经生疏了第一天的知识。因为你没有复习也没有敲代码。你会感到更大的阻力去重新学习昨天的课程。这时候厌倦的情绪会大大的降低你的学习效果。所以，不要让任何事情阻碍你去完成你今天的任务。你需要明白，拖延不是选项，你甚至根本不要去考虑它。 Question 8：我有明确而有效的复习计划吗？ 孔子有句话，“温故而知新，可以为师矣”。见名知意，就是经常温习就可以学到新的东西，也就是熟能生巧。很多同学在学习后面知识的时候经常会抱怨以前的知识已经遗忘了。因而，当他们学习后面的知识时，就会感觉到非常的有压力，甚至产生了放弃学习的念头。这种心态会严重扼杀一个人的自信心并且学习效率极低。等到就业找工作的时候，这些同学会变得极度不自信。因为，他认为所有的知识在他心中越来越模糊。那么，好的措施就是制定明确有效的学习计划，定期复习将会使你保持对知识的熟悉程度。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[春雏集-流动的思绪]]></title>
      <url>%2F2017%2F03%2F05%2F%E6%98%A5%E9%9B%8F%E9%9B%86-%E6%B5%81%E5%8A%A8%E7%9A%84%E6%80%9D%E7%BB%AA%2F</url>
      <content type="text"><![CDATA[&nbsp; &nbsp; &nbsp; &nbsp;所有的思绪被一场大雨冲刷的一干二净，窗花外的朦胧又梦幻般的世界，炫耀了莫名的姿色，五颜六色霓虹如五味杂陈般又塞满了整个空间。 &nbsp; &nbsp; &nbsp; &nbsp;车如流水马如龙，身如浮萍，难定踪迹。安静的车厢，闪烁的车灯，荧屏映衬着冷漠的脸，扶手也冷冷的释放着冷意，窗外的雨越发的朦胧，翻起的水雾遮拢了这个小城。 &nbsp; &nbsp; &nbsp; &nbsp;从繁华到落幕，笔直的大道，到底掩含了多少如流水般如你我般在相似而又落寞的世界里禹禹独行。追寻着光明，却曾未被照耀。但还是，在黑夜中坚持的前进着，心中一直坚定的信念，曾未如此光明过，不断的放大放大，直到思绪飘离了这里，在苍穹之上，默默的俯视着光怪陆离的世界。我看到了街边行乞的流浪人，祈求着每一个路人，只为了一顿三餐；我看到了在公园里哭泣的小女孩，眼中充满的渴望和泪水，只是想得到关爱；我看到了吵架的情侣，相互指责着对方，可是他倆又是那么的相爱；我看到了，我看到了世界，我看到了平常未曾感知到的色彩，生活如此。 &nbsp; &nbsp; &nbsp; &nbsp;“我的心愿的是世界和平！”一句会被嘲笑的话，此刻却是那么有力，那么渴望。相互扮演着让着这个世界运行下去的角色，有时你会生出挫败的无力感，此刻些许能明白些所谓的“看破红尘，遁入空门”这般话语。追心而去，逐念而去，坚守本心。 &nbsp; &nbsp; &nbsp;&nbsp;谁的思绪飞越了尽头，如流水般一去不返。 &nbsp; &nbsp; &nbsp; &nbsp;昨日而去，今日而追。心若有念，不曾有晚。 &nbsp; &nbsp; &nbsp; &nbsp;流动的思绪，翻腾的水雾，220照样在行驶，霓虹照样五味杂陈。每一次行程，如洗礼般，净化污浊，保持自我的纯真和最初的信念。 &nbsp; &nbsp; &nbsp; &nbsp;飘飞的思绪，随着耸动的人流下了车。我在窗外，看了看脚下的流水，却没了在窗内的思绪，笃定了思绪，默默前行。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[javaee上课笔记-Servlet事件监听器]]></title>
      <url>%2F2017%2F03%2F03%2Fjavaee%E4%B8%8A%E8%AF%BE%E7%AC%94%E8%AE%B0-Servlet%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E5%99%A8%2F</url>
      <content type="text"><![CDATA[学习目标 掌握监听器的相关API 掌握监听器域对象中的属性变更 掌握感知被HttpSession绑定的事件监听器 Servlet事件监听器概述 监听器组成：1.事件（Event）：用户的一个操作，如单机一个按钮、调用一个方法、创建一个对象吗等2.事件源：产生事件的对象3.事件监听器（Listener）：负责监听发生在事件源上的事件。4.事件处理器：监听器的成员方法，当事件发生的时候会触发的处理器（成员方法） 事件监听器工作步骤1.将监听器绑定到事件源，也就是注册监听器。2.事件发生时会触发监听器的的成员方法，即事件的处理器，传递事件对象。3.事件处理器通过事件 对象获得事件源，并对事件源进行处理。 Servlet事件监听器根据监听事件的不同分为三类1.用于监听域对象的创建和销毁的事件监听器（ServletContextListener 接口、HttpSessionListener 接口、ServletRequestListener 接口）。2.用于监听域对象属性增加和删除的事件监听器（ServletContextAttributeListener 接口、HttpSessionAttributeListener 接口、ServletRequestAttributeListener 接口）3.用于监听绑定到HttpSession域中某个对象状态的事件监听器（HttpSessionBindingListener接口、HttpsessionActivationListener 接口） 监听域对象的生命周期ServletContextListener 接口 方法： contextInitalized（）方法public void contextInitalized(ServletContextEvent sce)当ServletContext 对象被创建时，web容器会调用该方法，传入ServletContextEvent类型参数，在方法内容通过该参数来获取 创建的ServletContext对象 contextDestroyed（）方法public vid contextDestroyed(ServletContextEvent sce)内容描述差不多，就不写了HttpSessionListener 接口 sessionCreated()方法public vid sessionCreated（httpsessionEvent se） sessionDestroyed（）方法public vid sessionDestroyed（）方法 se）ServletRequestListener 接口 requestInitalized（）方法public void requestInitalized(ServletRequestEvent sre) requestDestroyed方法public void requestDestroyed(ServletRequestEvent sre) 案例-监听域对象的生命周期对Servlet域对象的生命周期进行监听，首先要实现域对象相应的接口 123456789101112131415161718192021222324package party.pjc.chapter05.listener;import javax.servlet.*;import javax.servlet.http.*;public class MyListener implements ServletContextListener, HttpSessionListener, ServletRequestListener &#123; public void contextInitialized(ServletContextEvent arg0) &#123; System.out.println(&quot;ServletContext对象被创建了&quot;); &#125; public void contextDestroyed(ServletContextEvent arg0) &#123; System.out.println(&quot;ServletContext对象被销毁了&quot;); &#125; public void requestInitialized(ServletRequestEvent arg0) &#123; System.out.println(&quot;ServletRequest对象被创建了&quot;); &#125; public void requestDestroyed(ServletRequestEvent arg0) &#123; System.out.println(&quot;ServletRequest对象被销毁了&quot;); &#125; public void sessionCreated(HttpSessionEvent arg0) &#123; System.out.println(&quot;HttpSession对象被创建了&quot;); &#125; public void sessionDestroyed(HttpSessionEvent arg0) &#123; System.out.println(&quot;HttpSession对象被销毁了&quot;); &#125;&#125; 配置文件，部署Mylistener监听器 12345&lt;listener&gt; &lt;listener-class&gt; packagePath &lt;/listener-class&gt;&lt;/listener&gt; 统计在线人数 贴上核心代码： 123456789101112131415161718package party.pjc.chapter05.listener;import javax.servlet.*;import javax.servlet.http.*;public class CountListener implements HttpSessionListener &#123; private int count = 0;// 用于统计在线人数 public void sessionCreated(HttpSessionEvent hse) &#123; count++;// session对象创建时count变量加1 ServletContext context = hse.getSession().getServletContext(); context.setAttribute(&quot;count&quot;, new Integer(count)); &#125; public void sessionDestroyed(HttpSessionEvent hse) &#123; count--;// session对象销毁时count变量减1 ServletContext context = hse.getSession().getServletContext(); context.setAttribute(&quot;count&quot;, new Integer(count)); &#125;&#125; 监听域对象中的属性变更监听对象属性变更的接口 attributeAdded（）方法public void attributeAdded(ServletContextAttributeEvent scab)public void attributeAdded(HttpSessionOnBindingEvent se)public void attributeAdded(ServletRequestAttributeEvent srae) attributeRemove()方法public void attributeRemove(ServletContextAttributeEvent scab)public void attributeRemove(HttpSessionOnBindingEvent se)public void attributeRemove(ServletRequestAttributeEvent srae)案例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package party.pjc.chapter05.listener;import javax.servlet.*;import javax.servlet.http.*;public class MyAttributeListener implementsServletContextAttributeListener,HttpSessionAttributeListener, ServletRequestAttributeListener &#123; public void attributeAdded(ServletContextAttributeEvent sae) &#123; String name = sae.getName(); System.out.println(&quot;ServletContext添加属性：&quot; + name + &quot;=&quot; + sae.getServletContext().getAttribute(name)); &#125; public void attributeRemoved(ServletContextAttributeEvent sae) &#123; String name = sae.getName(); System.out.println(&quot;ServletContext移除属性: &quot; + name); &#125; public void attributeReplaced(ServletContextAttributeEvent sae) &#123; String name = sae.getName(); System.out.println(&quot;ServletContext替换属性：&quot; + name + &quot;=&quot; + sae.getServletContext().getAttribute(name)); &#125; public void attributeAdded(HttpSessionBindingEvent hbe) &#123; String name = hbe.getName(); System.out.println(&quot;HttpSession添加属性：&quot; + name + &quot;=&quot; + hbe.getSession().getAttribute(name)); &#125; public void attributeRemoved(HttpSessionBindingEvent hbe) &#123; String name = hbe.getName(); System.out.println(&quot;HttpSession移除属性: &quot; + name); &#125; public void attributeReplaced(HttpSessionBindingEvent hbe) &#123; String name = hbe.getName(); System.out.println(&quot;HttpSession替换属性：&quot; + name + &quot;=&quot; + hbe.getSession().getAttribute(name)); &#125; public void attributeAdded(ServletRequestAttributeEvent sra) &#123; String name = sra.getName(); System.out.println(&quot;ServletRequest添加属性：&quot; + name + &quot;=&quot; + sra.getServletRequest().getAttribute(name)); &#125; public void attributeRemoved(ServletRequestAttributeEvent sra) &#123; String name = sra.getName(); System.out.println(&quot;ServletRequest移除属性: &quot; + name); &#125; public void attributeReplaced(ServletRequestAttributeEvent sra) &#123; String name = sra.getName(); System.out.println(&quot;ServletRequest替换属性：&quot; + name + &quot;=&quot; + sra.getServletRequest().getAttribute(name)); &#125;&#125; 别忘了在web.xml下配置 感知被HttpSession绑定的事件监听器HttpSessionBindingListener 接口 valueBound（）方法public void valueBound(HttpSessionBindingEvent event) valueUnBound()方法public void valueUnbound(HttpSessionBindingEvent event) 统计登录用户]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[春雏集：看见花落也凋零]]></title>
      <url>%2F2017%2F03%2F01%2F%E6%98%A5%E9%9B%8F%E9%9B%86%EF%BC%9A%E7%9C%8B%E8%A7%81%E8%8A%B1%E8%90%BD%E4%B9%9F%E5%87%8B%E9%9B%B6%2F</url>
      <content type="text"><![CDATA[春雏集：看见花落也凋零 看见花落也凋零。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[javaee上课笔记:DBUtils工具]]></title>
      <url>%2F2017%2F03%2F01%2Fjavaee%E4%B8%8A%E8%AF%BE%E7%AC%94%E8%AE%B0-DBUtils%E5%B7%A5%E5%85%B7%2F</url>
      <content type="text"><![CDATA[javaee上课笔记:DBUtils工具学习目标 了解DBUtils工具中的api 学会使用DBUtils工具对数据库进行增删改查的操作 学会使用DBUtils工具处理事务点我下载DBUtils API介绍核心类 &amp; 接口 类org.apache.commons.dbutils.DbUtilsorg.apache.commons.dbutils.QueryRunner 接口 org.apache.commons.dbutils.ResultSetHandler DBUtils 类 DBUtils类 主要为如何关闭，装载JDBC驱动程序之类的常规工作提供方法，它提供的方法都是静态方法， 1.close() 方法关闭数据库连接 2.closeQuietly(Connection con,Statement stmt,ResultSet rs) 方法该方法用来关闭Connection，Statement和ResultSet对象。还会隐藏一些在程序中抛出的sql异常 3.commitAndCloseQuiely(Connection con)该方法用来提交连接，然后关闭连接， 且在关闭时不抛出sql异常 4.LoadDrive（java.lang.String driverClassName）该方法用于装载jdbc驱动程序，如果成功返回true。使用时，不需要捕捉ClassNotFoundException异常 QueryRunner 类 该类简化了执行sql语句的代码，它与ResultSetHandler 组合在一起，能完成大部分的数据库操作，大大减少编码量。 提供了两个构造方法： 1.默认的构造方法 2.需要javax.sql.DataSource 作为参数 1.query(Connection conn,String sql,ResultSetHandler rsh,Object[] params) 方法该方法用于执行查询操作参数params表示一个对象数组，该数组中每个元素都被用来作为查询语句的置换参数注意：该方法会自动处理PrepareSatement 和 ResultSet的创建和关闭 2.query(String sql,ResultSetHandler rsh,Object[] params)方法该方法用于执行查询操作，与第一个方法相比它不需要传递Connection对象给方法，它可以从提供给构造方法的数据源DateSource或使用setDateSource()中获得连接。 3.query(Connection conn，String sql,ResultSetHandler rsh)方法该方法用于执一个不需要置换参数的查询操作 4.update(Connection conn，String sql,Object[] params)方法该方法用来执行插入、更新或者删除操作，其中，参数params 表示SQL语句中的置换参数。 5.update(Connection conn,String sql) 方法该方法用于执行插入、更新或者删操作，它需要置换参数操作。 ## ResultSetHandler 接口 该接口用于处理ResultSet结果集，它可以将结果集中的数据转化为不同的形式。根据结果集中数据类型的不同，ResultHandler提供了不同的实现类。如下： 1.AbstractKeyedHandler:该类为抽象类，能够把结果集里面的数据转换为用Map存储。 2.AbstractListHandler：该类为抽象类，—如上—-转换为用List存储。 3.ArrayHandler：把结果集中的第一行数据转成数据对象数组 4.ArrayListHandler：把结果集中的每一行数据转成一个对象数组，再将数组存放到List中。 5.BaseResultSetHandler：把结果集转换成其他对象的扩展。 6.BeanHandler :将结果集中的第一行数据封到一个对应的JavaBean实例中。 7.BeanListHandler：将结果集中的每一行数据都封装到一个对应的 JavaBean实例中，存放到list中 8.BeanMapHandler：结果集中的每一行数据都封装到一个对应的 JavaBean实例中，然后在根据指定的key把每个JavaBean在存放到一个Map里 9.ColumnListHandler：将结果集中某一列的数据存放到List中 10.将结果集中的每一行数据封装到一个map里，然后在根据指定的key把每个MAp在存放到一个map里。 11.MapHandler：将结集中的每一行数据封装到一个map里。可以是列名，value是对应的值。 12.MapListHandler：将结果集中的每一行数据封装到一个Map中，然后在存放到list中 13.ScalarHandler：将结果集中的某一条记录的其中某一列的数据存储成Object对象 另外，在ResultSetHandler接口中，提供了一个单独的方法handle（java.sql.ResultSet rs）,如果上述实现类没有提供想要的功能，可以通过自定义一个实现ResultSetHandler接口的类，然后重写handel()方法，实现结果集的处理。 代码实现ArrayHandler 和 ArrayListHandler 12345678public static void testArrayHandler() throws SQLException&#123; BaseDao beseDao = new BaseDao(); String sql = &quot;select * from NEWSINFO where nid=?&quot;; Object[] arr = (Object[]) BaseDao.query(sql, new ArrayHandler(), new Object[]&#123;50&#125;); for(int i=0;i&lt;arr.length;i++)&#123; System.out.println(arr[i]+&quot;,&quot;); &#125; 实现步骤 1.创建QueryRunner对象 （配置了C3p0数据池，参数获取数据源） QueryRunner runner = new QueryRunner（C3p0Utils.getDateSource（）） 2.编写Sql语句 String sql = &quot;&quot; 3.调用QueryRunner中的方法 runner.query() runner.update() 参数参考上面 DBUtils 处理事务 创建JDBCUtils,该类封装了创建连接，开启事务，关闭事务等方法 需要注意的是，请求中的一个事务涉及到了多个数据库操作，如果这些Connection是 从连接池中获取的，两个DAO操作就用到了两个Connection，这样是没办法完成一个事务的， 所以，需要借助ThreadLoacl类。 ThreadLoacl类的作用是在一个线程里记录变量。可以生成一个连接放在这个线程中， 只要是这个线程中的任何对象都可以共享这个连接，当线程结束后就删除这个连接，这样， 就保证了一个事务，一个连接。直接上代码:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package party.lvc.jdbc.utils;import java.sql.Connection;import java.sql.SQLException;import javax.sql.DataSource;import com.mchange.v2.c3p0.ComboPooledDataSource;public class JDBCUtils &#123; // 创建一个ThreadLocal 对象，以当前线程作为key private static ThreadLocal&lt;Connection&gt; threadLocal = new ThreadLocal&lt;Connection&gt;(); // 从c3p0-config.xml配置文件中读取默认的数据库配置，生成c3p0数据源 private static DataSource ds = new ComboPooledDataSource(); // 返回数据源对象 public static DataSource getDataSource() &#123; return ds; &#125; // 获取c3p0数据库连接池中的连接对象 public static Connection getConnection() throws SQLException &#123; Connection conn = threadLocal.get(); if (conn == null) &#123; conn = ds.getConnection(); threadLocal.set(conn); &#125; return conn; &#125; // 开启事务 public static void startTransaction() &#123; try &#123; // 获得链接 Connection conn = getConnection(); // 开启事务 conn.setAutoCommit(false); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; // 提交事务 public static void commit() &#123; try &#123; // 获得链接 Connection conn = threadLocal.get(); // 提交事务 if (conn != null) conn.commit(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; // 回滚事务 public static void rollback() &#123; try &#123; // 获得链接 Connection conn = threadLocal.get(); // 回滚事务 if (conn != null) conn.rollback(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; // 关闭数据库连接，释放资源 public static void close() &#123; // 获得链接 Connection conn = threadLocal.get(); // 关闭事务 if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; // 从集合中移除当前绑定的连接 threadLocal.remove(); conn = null; &#125; &#125; &#125;&#125; 事务的实现。通过银行转账业务，来举个栗子。创建Business，该类包括了转账过程的逻辑方法。1234567891011121314151617181920212223242526272829303132333435363738394041package party.lvc.example;import java.sql.SQLException;import cn.itcast.jdbc.example.dao.AccountDao;import cn.itcast.jdbc.example.domain.Account;import cn.itcast.jdbc.utils.JDBCUtils;public class Business &#123; public static void transfer(String sourceAccountName, String toAccountName, float money) &#123; try &#123; // 开启事务 JDBCUtils.startTransaction(); // 根据用户名查询数据并存入实体类对象中 AccountDao dao = new AccountDao(); Account accountfrom = dao.find(sourceAccountName); Account accountto = dao.find(toAccountName); // 完成转账操作 if(money&lt;accountfrom.getMoney())&#123; accountfrom.setMoney(accountfrom.getMoney()-money); &#125;else&#123; System.out.println(&quot;转出账户余额不足&quot;); &#125; accountto.setMoney(accountto.getMoney()+money); dao.update(accountfrom); dao.update(accountto); // 提交事务 JDBCUtils.commit(); System.out.println(&quot;提交成功&quot;); &#125; catch (SQLException e) &#123; System.out.println(&quot;提交失败&quot;); JDBCUtils.rollback(); e.printStackTrace(); &#125; finally &#123; // 关闭事务 JDBCUtils.close(); &#125; &#125; public static void main(String[] args) throws SQLException &#123; // 调用方法，实现a向b转账200元操作 transfer(&quot;a&quot;, &quot;b&quot;, 200); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android上课笔记-快速入门]]></title>
      <url>%2F2017%2F02%2F25%2FAndroid%E4%B8%8A%E8%AF%BE%E7%AC%94%E8%AE%B0-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%2F</url>
      <content type="text"><![CDATA[Android项目的目录结构 Activity：应用被打开时显示的界面 src：项目代码 R.java：项目中所有资源文件的资源id Android.jar：Android的jar包，导入此包方可使用Android的api libs：导入第三方jar包 assets：存放资源文件，比方说mp3、视频文件 bin：存放编译打包后的文件 res：存放资源文件，存放在此文件夹下的所有资源文件都会生成资源id drawable：存放图片资源 layout：存放布局文件，把布局文件通过资源id指定给activity，界面就会显示出该布局文件定义的布局 menu：定义菜单的样式 Strings.xml：存放字符串资源，每个资源都会有一个资源id Android的配置文件（清单文件） 指定应用的包名 package=”com.itheima.helloworld”data/data/com.itheima.helloworld(上面代码指定的包名)应用生成的文件都会存放在此路径下 Android的四大组件在使用前全部需要在清单文件中配置 的配置对整个应用生效 的配置对该activity生效DDMS Dalvik debug monitor service Dalvik调试监控服务 常用的adb指令Android debug bridge：安卓调试桥 adb start-server:启动adb进程 adb kill-server：杀死adb进程 adb devices：查看当前与开发环境连接的设备，此命令也可以启动adb进程 adb install XXX.apk：往模拟器安装apk adb uninstall 包名：删除模拟器中的应用 adb shell:进入linux命令行 ps：查看运行进程 ls：查看当前目录下的文件结构 netstat -ano：查看占用端口的进程电话拨号器 功能：用户输入一个号码，点击拨打按钮，启动系统打电话的应用把号码拨打出去 1. 定义布局 组件必须设置宽高，否则不能通过编译 12android:layout_width=&quot;wrap_content&quot;android:layout_height=&quot;wrap_content&quot; 如果要在java代码中操作某个组件，则组件需要设置id，这样才能在代码中通过id拿到这个组件 android:id=&quot;@+id/et_phone&quot; 2. 给按钮设置点击侦听 给按钮设置侦听1234 //通过id拿到按钮对象Button bt_call = (Button) findViewById(R.id.bt_call);//给按钮设置点击bt_call.setOnClickListener(new MyListener()); 3. 得到用户输入的号码123//得到用户输入的号码，先拿到输入框组件EditText et_phone = (EditText) findViewById(R.id.et_phone);String phone = et_phone.getText().toString(); 4. 把号码打出去 Android系统中基于动作机制，来调用系统的应用，你告诉系统你想做什么动作，系统就会把能做这个动作的应用给你，如果没有这个应用，会抛异常 设置动作，通过意图告知系统12345678//把号码打出去 //先创建一个意图对象 Intent intent = new Intent(); //设置动作，打电话 intent.setAction(Intent.ACTION_CALL); intent.setData(Uri.parse(&quot;tel:&quot; + phone)); //把意图告诉系统 startActivity(intent); 添加权限 &lt;uses-permission android:name=&quot;android.permission.CALL_PHONE&quot;/&gt; 点击事件的四种写法第一种 定义一个MyListener实现onClickListener接口 12Button bt1 = (Button) findViewById(R.id.bt1);bt1.setOnClickListener(new MyListener()); 第二种 定义一个匿名内部类实现onClickListener接口 123456789Button bt2 = (Button) findViewById(R.id.bt2);bt2.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; System.out.println(&quot;第二种&quot;); &#125;&#125;); 第三种 让当前activity实现onClickListener接口 12Button bt3 = (Button) findViewById(R.id.bt3);bt3.setOnClickListener(this); 第四种 给Button节点设置onClick属性， android:onClick=&quot;click&quot; 然后在activity中定义跟该属性值同名的方法 123public void click(View v)&#123; System.out.println(&quot;第四种&quot;);&#125; 短信发送器 功能：用户输入号码和短信内容，点击发送按钮，调用短信api把短信发送给指定号码 1. 定义布局 输入框的提示android:hint=&quot;请输入号码&quot; 2. 完成点击事件 先给Button组件设置onClick属性onClick=&quot;send&quot; 在Activity中定义此方法public void send(View v){} 3. 获取到用户输入的号码和内容1234EditText et_phone = (EditText) findViewById(R.id.et_phone);EditText et_content = (EditText) findViewById(R.id.et_content);String phone = et_phone.getText().toString();String content = et_content.getText().toString(); 4. 调用发送短信的api12345//调用发送短信的apiSmsManager sm = SmsManager.getDefault();//发送短信sm.sendTextMessage(phone, null, content, null, null); 添加权限 1&lt;uses-permission android:name=&quot;android.permission.SEND_SMS&quot;/&gt; 如果短信过长，需要拆分List&lt;String&gt; smss = sm.divideMessage(content);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[android笔记-Drawable]]></title>
      <url>%2F2017%2F02%2F24%2Fandroid%E7%AC%94%E8%AE%B0-Drawable%2F</url>
      <content type="text"><![CDATA[Android 的 Drawable Drawable 表示的是一中可以在Canvas上进行绘制的抽象概念，它的种类很多，最常见的颜色和 图片度可以是一个Drawable。 Drawable一般都是通过XML定义的，也可以使用代码来创建。 Drawable的分类BitmapDrawable 几乎是是最简单的Drawable，它就是表示一张图片。 xml文件， 属性123456789android:antialias 抗锯齿 android:dither 抖动效果 android:filter 过滤效果android:gravity 对图片进行定位，当图片小于容器时。android:mipMap android:src android:tileMode 平铺模式 disabled 、clamp、reapt 、mirrorandroid:tileModeXandroid:tileModeY ShapeDrawable 形状的Drawable咯,定义基本的几何图形,如(矩形,圆形,线条等),根元素是 节点比较多，相关的节点如下： ① shape: ~ visible:设置是否可见 ~ shape:形状,可选:rectangle(矩形,包括正方形),oval(椭圆,包括圆),line(线段),ring(环形) ~ innerRadiusRatio:当shape为ring才有效,表示环内半径所占半径的比率,如果设置了innerRadius, 他会被忽略 ~ innerRadius:当shape为ring才有效,表示环的内半径的尺寸 ~ thicknessRatio:当shape为ring才有效,表环厚度占半径的比率 ~ thickness:当shape为ring才有效,表示环的厚度,即外半径与内半径的差 ~ useLevel:当shape为ring才有效,表示是否允许根据level来显示环的一部分 ② size ~ width:图形形状宽度 ~ height:图形形状高度 ③ &lt;gradient 》 后面GradientDrawable再讲~ ④ solid ~ color:背景填充色,设置solid后会覆盖gradient设置的所有效果!!!!!! ⑤ stroke ~ width:边框的宽度 ~ color:边框的颜色 ~ dashWidth:边框虚线段的长度 ~ dashGap:边框的虚线段的间距 ⑥ conner ~ radius:圆角半径,适用于上下左右四个角 ~ topLeftRadius,topRightRadius,BottomLeftRadius,tBottomRightRadius: 依次是左上,右上,左下,右下的圆角值,按自己需要设置! ⑦ padding left,top,right,bottm:依次是左上右下方向上的边距! LayerDrawableStateListDrawable属性： drawable:引用的Drawable位图,我们可以把他放到最前面,就表示组件的正常状态~ state_focused:是否获得焦点 state_window_focused:是否获得窗口焦点 state_enabled:控件是否可用 state_checkable:控件可否被勾选,eg:checkbox state_checked:控件是否被勾选 state_selected:控件是否被选择,针对有滚轮的情况 state_pressed:控件是否被按下 state_active:控件是否处于活动状态,eg:slidingTab state_single:控件包含多个子控件时,确定是否只显示一个子控件 state_first:控件包含多个子控件时,确定第一个子控件是否处于显示状态 state_middle:控件包含多个子控件时,确定中间一个子控件是否处于显示状态 state_last:控件包含多个子控件时,确定最后一个子控件是否处于显示状态 LeveListDrawableTransitionDrawablwInsetDrawableScaleDrawableclipDrawable自定义Drawable]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[春雏集:优雅的活着]]></title>
      <url>%2F2017%2F02%2F22%2F%E6%98%A5%E9%9B%8F%E9%9B%86-%E4%BC%98%E9%9B%85%E7%9A%84%E6%B4%BB%E7%9D%80%2F</url>
      <content type="text"><![CDATA[春雏集:优雅的活着 我和丽丽有相同的观点就是，优雅的活着 每天一句早安，每天一句晚安，相逢总是思念。 她想优雅的活着，我想优雅的陪她，陪伴每个366天，多一天都是值得。 那一天，在回寝室的路上，抬头看落叶的飘零，不知为何，又想起了优雅的活着，优雅的生活，心中的那个念头，牵扯了感触。 今天给她分享了，李宗盛的《山丘》，她说，看不懂。其实很简单，我想，越过每一个山丘，然后陪你。 越发想念的越是醉人的，迷蒙的夜色神游的我俩。 晚安，亲爱的丽丽!我想陪你，过优雅的日子。 我希望有个如你一般的人如山间清爽的风如古城温暖的光从清晨到夜晚由山野到书房只要最后是你就好 ——张嘉佳 《从你的全世界路过》]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android笔记-第一课]]></title>
      <url>%2F2017%2F02%2F20%2FAndroid%E4%B8%8A%E8%AF%BE%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E8%AF%BE%2F</url>
      <content type="text"><![CDATA[Android 简介 通信技术 Android 起源 Android 体系架构 Dalvik 虚拟机Dalvik 包含了一整套的Android运行环境虚拟机，每个app都会分配Dalvik虚拟机来保证相互之间不收干扰，并不保持独立。它的特点是在运行时编译。 ART采用的是安装时就进行编译。 克服瓶颈期的最好办好就是六个字–总结 、归纳、演绎。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[javaweb实战：网上书城]]></title>
      <url>%2F2017%2F02%2F20%2Fjavaweb%E5%AE%9E%E6%88%98%EF%BC%9A%E7%BD%91%E4%B8%8A%E4%B9%A6%E5%9F%8E%2F</url>
      <content type="text"><![CDATA[javawe实战：网上书城 前台项目概述需求分析 1.统一友好的操作界面，具有良好的用户体验。 2.商品分类详尽，可按不同类别查看商品信息。 3.公告栏，本周热卖。 4.网站首页轮播图满足图书广告的需要。 5.用户信息的注册和验证。 6.通过图书名模糊搜索相关商品。 7.通过购物车一次购买多件商品。 8.提供简单的安全模型，用户必须登录后购买商品。 9.用户选择商品后可以在线提交订单。 10.用户可以查看自己的订单信息。 11.设计网站后台，管理网站的各项基本数据. 12.系统运行安全稳定且响应及时。 功能结构 项目预览数据库设计E-R图设计创建数据库和数据表项目前期准备 1.新建一个动态的web项目，名称为BooKStore 2.确定项目运行的环境版本 网上书城项目使用数据库MYSQL5.7版本，Java开发包为1.8 ，开发IDE MyEclipse 2016 3.将本项目所需jar包导入项目的lib文件下。 a.本项目使用c3p0数据源链接数据库，需要c3p0的jar包。 b.项目的jsp页面使用了JSTL标签库，需要jstl.jar和 standard.jar包。 c.项目中使用DBUtils工具处理数据的持久化操作，需要导入BeanUtils工具包。 d.由于在注册时系统还会给注册用户填写的邮箱发送一封激活码，需要导入mail.jar包。 本项目所需jar包如图所示： 4.配置c3p0-config.xml。 在项目Src根目录下创建该文件夹 配置如图所示： 5.编写filter过滤器 a.防止项目请求和响应时出现的乱码情况，需要编写一个过滤器 EcondingFilter.java 来统一全站编码， b.由于本项目分为前后台，只有超级用户才能登陆后台管理系统，所以在用户登录时需要 一个能够判断当前用户是否具有权限登录后台的过滤器，AdminPrivilegeFilter.java 编写工具类DataSourceUtils该类用于获取数据源和数据库的链接 用户注册和登录模块用户注册用户登录购物车模块模块描述实现购物车的基本功能实现订单的相关功能图书信息查询模块商品分类导航栏搜索功能公告板和本周热卖前台小结javawe实战：网上书城 后端管理后台管理系统概述商品管理模块商品管理模块简介实现查询商品列表功能实现添加商品信息功能实现编辑商品信息功能实现删除商品信息功能销售榜单模块订单管理模块订单管理模块简介实现查询订单列表功能实现查看订单详情功能实现删除订单功能后台小结]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[开学笔记]]></title>
      <url>%2F2017%2F02%2F20%2F%E5%BC%80%E5%AD%A6%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[语录 javaEE开学第一课 学习项目开发 项目框架非常的熟 业务走向，业务开发能力 学习要达到精通水平，是为了就业 学习三大框架ssh，只是学习了 编程的魅力，今天你学习了这个知识，过一段时间回过头来，一定会有全新的体验，不同的理解总结：温故而知新 荒唐的背后是什么 看小说，收到小说的的毒害。打架之后面的东西，是勇气。 总结：什么都懂一点，但是不深奥。寻求本质！ 基于MVC开发模式 课程计划–javaweb程序开发进阶 传智播客 jsp进阶 为期 10周 过滤器 监听器 EL表达式 JSP标签库 数据池 文件上传与下载 收现金开发一个 学习的本质，just with youself 新打算 以后将在此记录上课笔记，仅当记录那些年我们学过的 Hello World！ lvc唯爱]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[春雏集-三月花]]></title>
      <url>%2F2017%2F02%2F10%2F%E6%98%A5%E9%9B%8F%E9%9B%86-%E4%B8%89%E6%9C%88%E8%8A%B1%2F</url>
      <content type="text"><![CDATA[三月花二月的小城沾酒的夜色有些隐晦，暖冬的天气有些燥热，燥动的不安是二月的酒气。 盘着白雾的悬梁木板，是二月老人家的烟火，干烈的柴火是温暖的老宅。 二月的小城，我的家，几处青青，三月的花。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[android笔记-Android文件下载]]></title>
      <url>%2F2017%2F02%2F09%2Fandroid%E7%AC%94%E8%AE%B0-Android%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%2F</url>
      <content type="text"><![CDATA[android笔记-Android文件下载单线程下载效果展示： 主要过程：1.新建DownloadLinstener接口2.新建DoadloadTask继承AsycnTak3.新建DownloadService 继承service4.UI和Mainactivity实现 代码 DownloadLinstener接口实现* 1234567891011121314public interface DownloadListener &#123; void onProgress(int progress); void onSuccess(); void onFailed(); void onPaused(); void onCanceled();&#125; DownloadTask实现 * 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176package com.lvc.downloaddemo;import android.os.AsyncTask;import android.os.Environment;import java.io.File;import java.io.IOException;import java.io.InputStream;import java.io.RandomAccessFile;import okhttp3.OkHttpClient;import okhttp3.Request;import okhttp3.Response;/** * Created by lvc on 2017/2/9. */public class DownloadTask extends AsyncTask&lt;String ,Integer ,Integer&gt; &#123; // 下载常量 标识状态 public static final int TYPE_SUCCESS = 0; public static final int TYPE_FAILED = 1; public static final int TYPE_PAUSED = 2; public static final int TYPE_CANCELED = 3; private DownloadListener listener; private Boolean isPaused =false; private Boolean isCanceled = false; private int lastProgress; public DownloadTask(DownloadListener listener) &#123; this.listener = listener; &#125; // 后台执行的下载逻辑 @Override protected Integer doInBackground(String... params) &#123; InputStream in = null; RandomAccessFile savedFile = null; File file = null; try &#123; long downloadLength = 0; String downloadUrl = params[0]; String fileName = downloadUrl.substring(downloadUrl.lastIndexOf(&quot;/&quot;)); String directory = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS).getPath(); file = new File(directory+fileName); if (file.exists())&#123; downloadLength = file.length(); &#125; long contentLength = getContentLength(downloadUrl); if (contentLength == 0)&#123; return TYPE_FAILED; &#125;else if (contentLength == downloadLength)&#123; return TYPE_SUCCESS; &#125; OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder() //断点下载 .addHeader(&quot;RANGE&quot;, &quot;bytes=&quot; + downloadLength + &quot;-&quot;) .url(downloadUrl) .build(); Response response = client.newCall(request).execute(); if (response != null)&#123; in = response.body().byteStream(); savedFile = new RandomAccessFile(file,&quot;rw&quot;); savedFile.seek(downloadLength); byte[] b = new byte[1024]; int total =0; int len ; while ((len = in.read(b)) != -1)&#123; if (isCanceled)&#123; return TYPE_CANCELED; &#125; else if(isPaused)&#123; return TYPE_PAUSED; &#125; else&#123; total += len; savedFile.write(b,0,len); // 计算下载的百分比 int progress = (int)((total+downloadLength)*100 / contentLength); publishProgress(progress); &#125; &#125; response.body().close(); return TYPE_SUCCESS; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; if(in != null)&#123; try &#123; in.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; if(savedFile != null)&#123; try &#123; savedFile.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (isCanceled &amp;&amp; file != null)&#123; file.delete(); &#125; return TYPE_FAILED; &#125; // 更新 下载进度 @Override protected void onProgressUpdate(Integer... values) &#123; int progress = values[0]; if(progress &gt; lastProgress)&#123; listener.onProgress(progress); lastProgress = progress; &#125; &#125; //最终下载的结果 @Override protected void onPostExecute(Integer status) &#123; //super.onPostExecute(status); switch (status) &#123; case TYPE_SUCCESS: listener.onSuccess(); break; case TYPE_FAILED: listener.onFailed(); break; case TYPE_PAUSED: listener.onPaused(); break; case TYPE_CANCELED: listener.onCanceled(); default: break; &#125; &#125; private long getContentLength(String downloadUrl) throws IOException &#123; OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder() .url(downloadUrl) .build(); Response response = client.newCall(request).execute(); if (response != null &amp;&amp; response.isSuccessful())&#123; long contentlength = response.body().contentLength(); response.close(); return contentlength; &#125; return 0; &#125; public void pausedDownload()&#123; isPaused = true; &#125; public void canceledDownlod()&#123; isCanceled = true; &#125;&#125; DwonloadService实现* 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143package com.lvc.downloaddemo;import android.app.Notification;import android.app.NotificationManager;import android.app.PendingIntent;import android.app.Service;import android.content.Intent;import android.graphics.BitmapFactory;import android.os.Binder;import android.os.Environment;import android.os.IBinder;import android.support.v4.app.NotificationCompat;import android.util.Log;import android.widget.Toast;import java.io.File;public class DownloadService extends Service &#123; private DownloadTask downloadTask ; private String downloadUrl = null; int i = 0; private DownloadListener listener = new DownloadListener() &#123; @Override public void onProgress(int progress) &#123; getNotificationManager().notify(1,getNotification(&quot;正在下载...&quot;,progress)); &#125; @Override public void onSuccess() &#123; downloadTask = null; // 下载成功时将前台服务通知关闭，并创建一个下载成功的通知 stopForeground(true); getNotificationManager().notify(1, getNotification(&quot;Download Success&quot;, -1)); Toast.makeText(DownloadService.this, &quot;Download Success&quot;, Toast.LENGTH_SHORT).show(); &#125; @Override public void onFailed() &#123; downloadTask = null; // 下载失败时将前台服务通知关闭，并创建一个下载失败的通知 stopForeground(true); getNotificationManager().notify(1, getNotification(&quot;Download Failed&quot;, -1)); Toast.makeText(DownloadService.this, &quot;Download Failed&quot;, Toast.LENGTH_SHORT).show(); &#125; @Override public void onPaused() &#123; downloadTask = null; Toast.makeText(DownloadService.this, &quot;Paused&quot;, Toast.LENGTH_SHORT).show(); &#125; @Override public void onCanceled() &#123; downloadTask = null; stopForeground(true); Toast.makeText(DownloadService.this, &quot;Canceled&quot;, Toast.LENGTH_SHORT).show(); &#125; &#125; ; private DownloadBinder mBinder =new DownloadBinder(); /* public DownloadService() &#123; &#125;*/ @Override public IBinder onBind(Intent intent) &#123; return mBinder; &#125; class DownloadBinder extends Binder&#123; public void startDownload(String url)&#123; if(downloadUrl == null)&#123; downloadUrl =url; downloadTask = new DownloadTask(listener); downloadTask.execute(downloadUrl); startForeground(1,getNotification(&quot;正在下载...&quot;,0)); Log.i(&quot;判断点击次数&quot;, &quot;startDownload: &quot;+i); i++; Toast.makeText(DownloadService.this, &quot;正在下载...&quot;, Toast.LENGTH_SHORT).show(); &#125; &#125; public void pauseDownload()&#123; if(downloadTask !=null)&#123; downloadTask.pausedDownload(); &#125; &#125; public void cancelDownload()&#123; if(downloadTask != null)&#123; downloadTask.canceledDownlod(); &#125;else&#123; if(downloadUrl != null)&#123; //取消下载时需要将文件删除，并通知关闭 String fileName = downloadUrl.substring(downloadUrl.lastIndexOf(&quot;/&quot;)); String directory = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS).getPath(); File file = new File(directory + fileName); if(file.exists())&#123; file.delete(); &#125; getNotificationManager().cancel(1); stopForeground(true); Toast.makeText(DownloadService.this, &quot;Canceled&quot;, Toast.LENGTH_SHORT).show(); &#125; &#125; &#125; &#125; // 获取通知管理器 private NotificationManager getNotificationManager()&#123; return (NotificationManager) getSystemService(NOTIFICATION_SERVICE); &#125; //通知详情 private Notification getNotification(String title,int progress)&#123; // Intent intent = new Intent(this,MainActivity.class); // PendingIntent pi = PendingIntent.getActivities(this,0,new Intent[]&#123;intent&#125;,0); Intent intent = new Intent(this, MainActivity.class); PendingIntent pi = PendingIntent.getActivity(this, 0, intent, 0); NotificationCompat.Builder builder = new NotificationCompat.Builder(this); builder.setSmallIcon(R.mipmap.ic_launcher); builder.setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher)); builder.setContentIntent(pi); builder.setContentTitle(title); if(progress &gt;= 0)&#123; builder.setContentText(progress + &quot;%&quot;); builder.setProgress(100,progress,false); &#125; return builder.build(); &#125;&#125; Mainactivity实现 UI布局简单就不贴了* 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394package com.lvc.downloaddemo;import android.Manifest;import android.content.ComponentName;import android.content.Intent;import android.content.ServiceConnection;import android.content.pm.PackageManager;import android.os.IBinder;import android.support.annotation.NonNull;import android.support.v4.app.ActivityCompat;import android.support.v4.content.ContextCompat;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.Toast;public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; private DownloadService.DownloadBinder downloadBinder; private ServiceConnection connection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName componentName, IBinder iBinder) &#123; downloadBinder = (DownloadService.DownloadBinder) iBinder; &#125; @Override public void onServiceDisconnected(ComponentName componentName) &#123; &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button startDownload = (Button) findViewById(R.id.btn_start); Button pauseDownload = (Button) findViewById(R.id.btn_paused); Button cancelDownload = (Button) findViewById(R.id.btn_cancel); startDownload.setOnClickListener(this); pauseDownload.setOnClickListener(this); cancelDownload.setOnClickListener(this); Intent intent = new Intent(this,DownloadService.class); startService(intent); bindService(intent,connection,BIND_AUTO_CREATE); if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) &#123; ActivityCompat.requestPermissions(MainActivity.this, new String[]&#123; Manifest.permission. WRITE_EXTERNAL_STORAGE &#125;, 1); &#125; &#125; @Override public void onClick(View view) &#123; if (downloadBinder == null) &#123; return; &#125; switch (view.getId()) &#123; case R.id.btn_start: String url = &quot;http://www.runoob.com/wp-content/uploads/2015/09/DownLoadDemo1.zip&quot;; downloadBinder.startDownload(url); break; case R.id.btn_paused: downloadBinder.pauseDownload(); break; case R.id.btn_cancel: downloadBinder.cancelDownload(); break; default: break; &#125; &#125; @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; switch (requestCode) &#123; case 1: if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] != PackageManager.PERMISSION_GRANTED) &#123; Toast.makeText(this, &quot;拒绝权限将无法使用程序&quot;, Toast.LENGTH_SHORT).show(); finish(); &#125; break; default: &#125; &#125; @Override protected void onDestroy() &#123; super.onDestroy(); unbindService(connection); &#125;&#125; 多线程下载 多线程的下载流程 获取网络连接 本地磁盘创建相同大小的空文件 计算每条线程需从文件哪个部分开始下载，结束 依次创建，启动多条线程来下载网络资源的指定部分 核心代码：12]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[android笔记-HttpURLConnection]]></title>
      <url>%2F2017%2F02%2F07%2Fandroid%E7%AC%94%E8%AE%B0-HttpURLConnection%2F</url>
      <content type="text"><![CDATA[android笔记-HttpURLConnection报错 调用InputStream in = connection.getErrorStream(); 报错 主要代码 使用okhttp直接上代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788package com.lvc.nnetworktest.util;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.net.HttpURLConnection;import java.net.URL;import okhttp3.OkHttpClient;import okhttp3.Request;import okhttp3.Response;/** * Created by lvc on 2017/2/7. * 网络请求util * 封装了 httpURLConnection &amp; okhttp3 */public class HtppUtil &#123; public static void sendHttpRequest(final String address,final HttpCallbackListener listener)&#123; new Thread(new Runnable() &#123; @Override public void run() &#123; HttpURLConnection connection = null; //InputStream in =null; try &#123; URL url = new URL(address); connection = (HttpURLConnection) url.openConnection(); connection.setRequestMethod(&quot;GET&quot;); connection.setConnectTimeout(8000); connection.setReadTimeout(8000); connection.setDoInput(true); connection.setDoOutput(true); InputStream in = connection.getErrorStream(); BufferedReader reader = new BufferedReader(new InputStreamReader(in)); StringBuilder response = new StringBuilder(); String line; while((line =reader.readLine())!=null)&#123; response.append(line); &#125; if(listener != null)&#123; listener.onFinish(response.toString()); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); if(listener != null)&#123; listener.onError(e); &#125; &#125;finally &#123; if(connection != null)&#123; connection.disconnect(); &#125; /* if (in != null)&#123; try &#123; in.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;*/ &#125; &#125; &#125;).start(); &#125; public interface HttpCallbackListener&#123; void onFinish(String response); void onError(Exception e); &#125; /** * okhttp3 */ public static void sendOkhttpRequest(String address , okhttp3.Callback callback)&#123; OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder() .url(address) .build(); client.newCall(request).enqueue(callback); //调用回调 &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[闲言碎语-西游降魔篇]]></title>
      <url>%2F2017%2F02%2F06%2F%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD-%E8%A5%BF%E6%B8%B8%E9%99%8D%E9%AD%94%E7%AF%87%2F</url>
      <content type="text"><![CDATA[西游真的是那个西游吗许久不见，或许是一种情怀！可这又有什么关系呢？佛是什么？你又是什么？我又是什么？西游真的是西游吗？22部天竺真经真的能普度众生吗？度的人，应该是他自己吧。 一生所爱 是被用坏了的情怀吗？终究你我将不复存在关于执念你我懂多少不同的人有不同世界一生真的能爱个够吗陈先生历经千辛万苦只寻普度众生的良药可是大爱小爱说不清道不明在制服猪刚鬣的之时孙先生出了一个法子在月圆之夜，绝山之巅段小姐翩然起舞，宛若谪仙，人间不应有一生所爱的歌声，纵然是情怀作祟。 我的西游我希望寻找自己的西游之路，不为普度众生只为度我自己。西游终究是被烙印在骨子里，流淌的血液在轰轰的燃烧着，可是红尘真的有 真 善 美 ？愿意相信的谎言，我愿意，那就有。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[android笔记-调用摄像头相册]]></title>
      <url>%2F2017%2F02%2F06%2Fandroid%E7%AC%94%E8%AE%B0-%E8%B0%83%E7%94%A8%E6%91%84%E5%83%8F%E5%A4%B4%E7%9B%B8%E5%86%8C%2F</url>
      <content type="text"><![CDATA[调用摄像头调用摄像头拍照获取图片 Demo：效果展示 重要代码123456789101112131415161718192021//创建File 对象，用于存储拍照后的图片File outputImage = new File(getExternalCacheDir(),&quot;output_image.jsp&quot;);try &#123; if(outputImage.exists())&#123; outputImage.delete(); &#125; outputImage.createNewFile();&#125;catch (IOException e)&#123; e.printStackTrace();&#125;if(Build.VERSION.SDK_INT&gt;=24)&#123; imageUri = FileProvider.getUriForFile(MainActivity.this,&quot;com.example.cramea.fileprovider&quot;, outputImage);&#125;else&#123; imageUri = Uri.fromFile(outputImage);&#125;//启动相机程序Intent intent = new Intent(&quot;android.media.action.IMAGE_CAPTURE&quot;);intent.putExtra(MediaStore.EXTRA_OUTPUT,imageUri);startActivityForResult(intent,TAKE_PHOTO); 从相册中选择图片全部代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208package com.lvc.cameraalbumtest;import android.Manifest;import android.annotation.TargetApi;import android.app.Activity;import android.content.ContentUris;import android.content.Intent;import android.content.pm.PackageManager;import android.database.Cursor;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.net.Uri;import android.os.Build;import android.provider.DocumentsContract;import android.provider.MediaStore;import android.support.annotation.NonNull;import android.support.v4.app.ActivityCompat;import android.support.v4.content.ContextCompat;import android.support.v4.content.FileProvider;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.ImageView;import android.widget.Toast;import java.io.File;import java.io.FileNotFoundException;import java.io.IOException;public class MainActivity extends AppCompatActivity &#123; public static final int TAKE_PHOTO = 1; public static final int CHOOSE_PHOTO = 2; private Button takephoto ; private Button choosephoto ; private ImageView pictrue ; private Uri imageUri ; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); /** * 1.获取实例 * 2.绑定监听事件 * */ takephoto = (Button) findViewById(R.id.take_photo); choosephoto = (Button) findViewById(R.id.choose_from_album); pictrue = (ImageView) findViewById(R.id.picture); takephoto.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; //创建File 对象，用于存储拍照后的图片 File outputImage = new File(getExternalCacheDir(),&quot;output_image.jsp&quot;); try &#123; if(outputImage.exists())&#123; outputImage.delete(); &#125; outputImage.createNewFile(); &#125;catch (IOException e)&#123; e.printStackTrace(); &#125; if(Build.VERSION.SDK_INT&gt;=24)&#123; imageUri = FileProvider.getUriForFile(MainActivity.this,&quot;com.example.cramea.fileprovider&quot;, outputImage); &#125;else&#123; imageUri = Uri.fromFile(outputImage); &#125; //启动相机程序 Intent intent = new Intent(&quot;android.media.action.IMAGE_CAPTURE&quot;); intent.putExtra(MediaStore.EXTRA_OUTPUT,imageUri); startActivityForResult(intent,TAKE_PHOTO); &#125; &#125;); choosephoto.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; if(ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED)&#123; ActivityCompat.requestPermissions(MainActivity.this,new String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;,1); &#125;else&#123; openAlbum(); &#125; &#125; &#125;); &#125; /** * */ private void openAlbum()&#123; Intent intent =new Intent(&quot;android.intent.action.GET_CONTENT&quot;); intent.setType(&quot;image/*&quot;); startActivityForResult(intent,CHOOSE_PHOTO); &#125; @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; // super.onActivityResult(requestCode, resultCode, data); switch (requestCode)&#123; case TAKE_PHOTO: try &#123; Bitmap bitmap = BitmapFactory.decodeStream(getContentResolver() .openInputStream(imageUri)); pictrue.setImageBitmap(bitmap); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; break; case CHOOSE_PHOTO: if(resultCode == RESULT_OK )&#123; //判断手机系统版本号 if(Build.VERSION.SDK_INT&gt;=19)&#123; //4.4及以上版本使用这个方法处理图片 handleImageOnKiKat(data); &#125;else&#123; //4.4以下版本使用这个方法处理图片 handleImageBeforeKiKat(data); &#125; &#125; break; default: break; &#125; &#125; private void handleImageBeforeKiKat(Intent data) &#123; Uri uri = data.getData(); String imagepath = getImagePath(uri,null); displayImage(imagepath); &#125; @TargetApi(19) private void handleImageOnKiKat(Intent data) &#123; String imagePath= null; Uri uri = data.getData(); if(DocumentsContract.isDocumentUri(this,uri))&#123; String docId = DocumentsContract.getDocumentId(uri); if(&quot;com.android.providers.media.documents&quot;.equals(uri.getAuthority()))&#123; String id = docId.split(&quot;:&quot;)[1]; String selection = MediaStore.Images.Media._ID+&quot;=&quot;+id; imagePath = getImagePath(MediaStore.Images.Media.EXTERNAL_CONTENT_URI,selection); &#125;else if(&quot;com.android.providers.downloads.documents&quot;.equals(uri.getAuthority()))&#123; Uri contentUri = ContentUris.withAppendedId(Uri.parse(&quot;content://downloads/public_downloads&quot;),Long.valueOf(docId)); imagePath = getImagePath(contentUri,null); &#125; &#125;else if(&quot;content&quot;.equalsIgnoreCase(uri.getScheme()))&#123; imagePath = getImagePath(uri,null); &#125;else if(&quot;file&quot;.equalsIgnoreCase(uri.getScheme()))&#123; imagePath = uri.getPath(); &#125; displayImage(imagePath); &#125; @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; //super.onRequestPermissionsResult(requestCode, permissions, grantResults); switch (requestCode)&#123; case 1: if(grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED )&#123; openAlbum(); &#125;else&#123; Toast.makeText(this,&quot;you denied the permisson&quot;,Toast.LENGTH_SHORT).show(); // openAlbum(); &#125; break; default: break; &#125; &#125; private String getImagePath(Uri uri,String selection)&#123; String path =null; //通过Uri和 selection 来获取真实的图片路径 Cursor cursor = getContentResolver().query(uri,null,selection,null,null); if(cursor != null)&#123; if (cursor.moveToNext())&#123; path = cursor.getString(cursor.getColumnIndex(MediaStore.Images.Media.DATA)); &#125; cursor.close(); &#125; return path; &#125; private void displayImage(String imagePath)&#123; if (imagePath !=null)&#123; Bitmap bitmap = BitmapFactory.decodeFile(imagePath); pictrue.setImageBitmap(bitmap); &#125;else&#123; Toast.makeText(this,&quot;Failed to get image&quot;,Toast.LENGTH_SHORT).show(); &#125; &#125;&#125; 总结 博客真难写想做个记录发现不知道怎么去记汗颜啊]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[android笔记-使用通知]]></title>
      <url>%2F2017%2F02%2F05%2Fandroid%E7%AC%94%E8%AE%B0-%E4%BD%BF%E7%94%A8%E9%80%9A%E7%9F%A5%2F</url>
      <content type="text"><![CDATA[Android笔记-使用通知通知的基本用法 代码 123456789NotificationManager notificationManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE); Notification notification = new NotificationCompat.Builder(this) .setContentTitle(&quot;通知&quot;) .setContentText(&quot;这是一个通知！&quot;) .setWhen(System.currentTimeMillis()) .setSmallIcon(R.mipmap.ic_launcher) .setLargeIcon(BitmapFactory.decodeResource(getResources(),R.mipmap.ic_launcher)) .build(); notificationManager.notify(1,notification); PendingIntent可以简单的理解为延迟执行的Intent pendingIntent 用法1.获取PendingIntent实例： getActivity() getBroadcast() getService() &gt; 以上方法参数相同： * 1 context * 2 0 通常传入0 * 3 Intent对象 * 4 用于确定PendingIntent的行为 有4个值：FLAG_ONE_SHOT FLAG_ON_CREATE FLAG_CANEL_CURRENT FLAG_UPDATE_CURRENT 给通知添加响应 代码12345678910111213Intent intent = new Intent(this,NotificationActivity.class); Intent[] intents = &#123;intent&#125;; PendingIntent pi = PendingIntent.getActivities(this,0,intents,0); NotificationManager notificationManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE); Notification notification = new NotificationCompat.Builder(this) .setContentTitle(&quot;通知&quot;) .setContentText(&quot;这是一个通知！&quot;) .setWhen(System.currentTimeMillis()) .setSmallIcon(R.mipmap.ic_launcher) .setLargeIcon(BitmapFactory.decodeResource(getResources(),R.mipmap.ic_launcher)) .setContentIntent(pi) .build(); notificationManager.notify(1,notification); 取消通知栏上的通知`.setAutoCancel(true)` 在响应的Activity中 添加 1.NotificationManager notificationManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE); 2.notificationManager.cancel(1);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[我的第一篇博客]]></title>
      <url>%2F2017%2F02%2F03%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
      <content type="text"><![CDATA[没有正式文章，仅作为当前内容的测试！ 做个简单的小结昨天在慕课网手记中看到 hexo + github pages 搭建个人博客 经过长时间的学习，再一次觉得开源的伟大! 用了不到一天的时间，杂七杂八的也就成这个样子了 实践才是检验真理的唯一标准 坚持每天学点东西吧。这也算还了我一个小愿望！2017 任重而道远! 下一步，开发一个APP！ ——Lvc]]></content>
    </entry>

    
  
  
</search>
