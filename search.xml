<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Android上课笔记-快速入门]]></title>
      <url>%2F2017%2F02%2F25%2FAndroid%E4%B8%8A%E8%AF%BE%E7%AC%94%E8%AE%B0-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%2F</url>
      <content type="text"><![CDATA[Android项目的目录结构 Activity：应用被打开时显示的界面 src：项目代码 R.java：项目中所有资源文件的资源id Android.jar：Android的jar包，导入此包方可使用Android的api libs：导入第三方jar包 assets：存放资源文件，比方说mp3、视频文件 bin：存放编译打包后的文件 res：存放资源文件，存放在此文件夹下的所有资源文件都会生成资源id drawable：存放图片资源 layout：存放布局文件，把布局文件通过资源id指定给activity，界面就会显示出该布局文件定义的布局 menu：定义菜单的样式 Strings.xml：存放字符串资源，每个资源都会有一个资源id Android的配置文件（清单文件） 指定应用的包名 package=”com.itheima.helloworld”data/data/com.itheima.helloworld(上面代码指定的包名)应用生成的文件都会存放在此路径下 Android的四大组件在使用前全部需要在清单文件中配置 的配置对整个应用生效 的配置对该activity生效DDMS Dalvik debug monitor service Dalvik调试监控服务 常用的adb指令Android debug bridge：安卓调试桥 adb start-server:启动adb进程 adb kill-server：杀死adb进程 adb devices：查看当前与开发环境连接的设备，此命令也可以启动adb进程 adb install XXX.apk：往模拟器安装apk adb uninstall 包名：删除模拟器中的应用 adb shell:进入linux命令行 ps：查看运行进程 ls：查看当前目录下的文件结构 netstat -ano：查看占用端口的进程电话拨号器 功能：用户输入一个号码，点击拨打按钮，启动系统打电话的应用把号码拨打出去 1. 定义布局 组件必须设置宽高，否则不能通过编译 12android:layout_width=&quot;wrap_content&quot;android:layout_height=&quot;wrap_content&quot; 如果要在java代码中操作某个组件，则组件需要设置id，这样才能在代码中通过id拿到这个组件 android:id=&quot;@+id/et_phone&quot; 2. 给按钮设置点击侦听 给按钮设置侦听1234 //通过id拿到按钮对象Button bt_call = (Button) findViewById(R.id.bt_call);//给按钮设置点击bt_call.setOnClickListener(new MyListener()); 3. 得到用户输入的号码123//得到用户输入的号码，先拿到输入框组件EditText et_phone = (EditText) findViewById(R.id.et_phone);String phone = et_phone.getText().toString(); 4. 把号码打出去 Android系统中基于动作机制，来调用系统的应用，你告诉系统你想做什么动作，系统就会把能做这个动作的应用给你，如果没有这个应用，会抛异常 设置动作，通过意图告知系统12345678//把号码打出去 //先创建一个意图对象 Intent intent = new Intent(); //设置动作，打电话 intent.setAction(Intent.ACTION_CALL); intent.setData(Uri.parse(&quot;tel:&quot; + phone)); //把意图告诉系统 startActivity(intent); 添加权限 &lt;uses-permission android:name=&quot;android.permission.CALL_PHONE&quot;/&gt; 点击事件的四种写法第一种 定义一个MyListener实现onClickListener接口 12Button bt1 = (Button) findViewById(R.id.bt1);bt1.setOnClickListener(new MyListener()); 第二种 定义一个匿名内部类实现onClickListener接口 123456789Button bt2 = (Button) findViewById(R.id.bt2);bt2.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; System.out.println(&quot;第二种&quot;); &#125;&#125;); 第三种 让当前activity实现onClickListener接口 12Button bt3 = (Button) findViewById(R.id.bt3);bt3.setOnClickListener(this); 第四种 给Button节点设置onClick属性， android:onClick=&quot;click&quot; 然后在activity中定义跟该属性值同名的方法 123public void click(View v)&#123; System.out.println(&quot;第四种&quot;);&#125; 短信发送器 功能：用户输入号码和短信内容，点击发送按钮，调用短信api把短信发送给指定号码 1. 定义布局 输入框的提示android:hint=&quot;请输入号码&quot; 2. 完成点击事件 先给Button组件设置onClick属性onClick=&quot;send&quot; 在Activity中定义此方法public void send(View v){} 3. 获取到用户输入的号码和内容1234EditText et_phone = (EditText) findViewById(R.id.et_phone);EditText et_content = (EditText) findViewById(R.id.et_content);String phone = et_phone.getText().toString();String content = et_content.getText().toString(); 4. 调用发送短信的api12345//调用发送短信的apiSmsManager sm = SmsManager.getDefault();//发送短信sm.sendTextMessage(phone, null, content, null, null); 添加权限 1&lt;uses-permission android:name=&quot;android.permission.SEND_SMS&quot;/&gt; 如果短信过长，需要拆分List&lt;String&gt; smss = sm.divideMessage(content);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[android笔记-Drawable]]></title>
      <url>%2F2017%2F02%2F24%2Fandroid%E7%AC%94%E8%AE%B0-Drawable%2F</url>
      <content type="text"><![CDATA[Android 的 Drawable Drawable 表示的是一中可以在Canvas上进行绘制的抽象概念，它的种类很多，最常见的颜色和 图片度可以是一个Drawable。 Drawable一般都是通过XML定义的，也可以使用代码来创建。 Drawable的分类BitmapDrawable 几乎是是最简单的Drawable，它就是表示一张图片。 xml文件， 属性123456789android:antialias 抗锯齿 android:dither 抖动效果 android:filter 过滤效果android:gravity 对图片进行定位，当图片小于容器时。android:mipMap android:src android:tileMode 平铺模式 disabled 、clamp、reapt 、mirrorandroid:tileModeXandroid:tileModeY ShapeDrawableLayerDrawableStateListDrawableLeveListDrawableTransitionDrawablwInsetDrawableScaleDrawableclipDrawable自定义Drawable]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[春雏集:优雅的活着]]></title>
      <url>%2F2017%2F02%2F22%2F%E6%98%A5%E9%9B%8F%E9%9B%86-%E4%BC%98%E9%9B%85%E7%9A%84%E6%B4%BB%E7%9D%80%2F</url>
      <content type="text"><![CDATA[春雏集:优雅的活着 我和丽丽有相同的观点就是，优雅的活着 每天一句早安，每天一句晚安，相逢总是思念。 她想优雅的活着，我想优雅的陪她，陪伴每个366天，多一天都是值得。 那一天，在回寝室的路上，抬头看落叶的飘零，不知为何，又想起了优雅的活着，优雅的生活，心中的那个念头，牵扯了感触。 今天给她分享了，李宗盛的《山丘》，她说，看不懂。其实很简单，我想，越过每一个山丘，然后陪你。 越发想念的越是醉人的，迷蒙的夜色神游的我俩。 晚安，亲爱的丽丽!我想陪你，过优雅的日子。 我希望有个如你一般的人如山间清爽的风如古城温暖的光从清晨到夜晚由山野到书房只要最后是你就好 ——张嘉佳 《从你的全世界路过》]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android上课笔记-第一课]]></title>
      <url>%2F2017%2F02%2F20%2FAndroid%E4%B8%8A%E8%AF%BE%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E8%AF%BE%2F</url>
      <content type="text"><![CDATA[Android 简介 通信技术 Android 起源 Android 体系架构 Dalvik 虚拟机Dalvik 包含了一整套的Android运行环境虚拟机，每个app都会分配Dalvik虚拟机来保证相互之间不收干扰，并不保持独立。它的特点是在运行时编译。 ART采用的是安装时就进行编译。 克服瓶颈期的最好办好就是六个字–总结 、归纳、演绎。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[javaweb实战：网上书城]]></title>
      <url>%2F2017%2F02%2F20%2Fjavaweb%E5%AE%9E%E6%88%98%EF%BC%9A%E7%BD%91%E4%B8%8A%E4%B9%A6%E5%9F%8E%2F</url>
      <content type="text"><![CDATA[javawe实战：网上书城 前台项目概述需求分析 1.统一友好的操作界面，具有良好的用户体验。 2.商品分类详尽，可按不同类别查看商品信息。 3.公告栏，本周热卖。 4.网站首页轮播图满足图书广告的需要。 5.用户信息的注册和验证。 6.通过图书名模糊搜索相关商品。 7.通过购物车一次购买多件商品。 8.提供简单的安全模型，用户必须登录后购买商品。 9.用户选择商品后可以在线提交订单。 10.用户可以查看自己的订单信息。 11.设计网站后台，管理网站的各项基本数据. 12.系统运行安全稳定且响应及时。 功能结构 项目预览数据库设计E-R图设计创建数据库和数据表项目前期准备 1.新建一个动态的web项目，名称为BooKStore 2.确定项目运行的环境版本 网上书城项目使用数据库MYSQL5.7版本，Java开发包为1.8 ，开发IDE MyEclipse 2016 3.将本项目所需jar包导入项目的lib文件下。 a.本项目使用c3p0数据源链接数据库，需要c3p0的jar包。 b.项目的jsp页面使用了JSTL标签库，需要jstl.jar和 standard.jar包。 c.项目中使用DBUtils工具处理数据的持久化操作，需要导入BeanUtils工具包。 d.由于在注册时系统还会给注册用户填写的邮箱发送一封激活码，需要导入mail.jar包。 本项目所需jar包如图所示： 4.配置c3p0-config.xml。 在项目Src根目录下创建该文件夹 配置如图所示： 5.编写filter过滤器 a.防止项目请求和响应时出现的乱码情况，需要编写一个过滤器 EcondingFilter.java 来统一全站编码， b.由于本项目分为前后台，只有超级用户才能登陆后台管理系统，所以在用户登录时需要 一个能够判断当前用户是否具有权限登录后台的过滤器，AdminPrivilegeFilter.java 编写工具类DataSourceUtils该类用于获取数据源和数据库的链接 用户注册和登录模块用户注册用户登录购物车模块模块描述实现购物车的基本功能实现订单的相关功能图书信息查询模块商品分类导航栏搜索功能公告板和本周热卖前台小结javawe实战：网上书城 后端管理后台管理系统概述商品管理模块商品管理模块简介实现查询商品列表功能实现添加商品信息功能实现编辑商品信息功能实现删除商品信息功能销售榜单模块订单管理模块订单管理模块简介实现查询订单列表功能实现查看订单详情功能实现删除订单功能后台小结]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[开学笔记]]></title>
      <url>%2F2017%2F02%2F20%2F%E5%BC%80%E5%AD%A6%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[语录 javaEE开学第一课 学习项目开发 项目框架非常的熟 业务走向，业务开发能力 学习要达到精通水平，是为了就业 学习三大框架ssh，只是学习了 编程的魅力，今天你学习了这个知识，过一段时间回过头来，一定会有全新的体验，不同的理解总结：温故而知新 荒唐的背后是什么 看小说，收到小说的的毒害。打架之后面的东西，是勇气。 总结：什么都懂一点，但是不深奥。寻求本质！ 基于MVC开发模式 课程计划–javaweb程序开发进阶 传智播客 jsp进阶 为期 10周 过滤器 监听器 EL表达式 JSP标签库 数据池 文件上传与下载 收现金开发一个 学习的本质，just with youself 新打算 以后将在此记录上课笔记，仅当记录那些年我们学过的 Hello World！ lvc唯爱]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[春雏集-三月花]]></title>
      <url>%2F2017%2F02%2F10%2F%E6%98%A5%E9%9B%8F%E9%9B%86-%E4%B8%89%E6%9C%88%E8%8A%B1%2F</url>
      <content type="text"><![CDATA[三月花二月的小城沾酒的夜色有些隐晦，暖冬的天气有些燥热，燥动的不安是二月的酒气。 盘着白雾的悬梁木板，是二月老人家的烟火，干烈的柴火是温暖的老宅。 二月的小城，我的家，几处青青，三月的花。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[android笔记-Android文件下载]]></title>
      <url>%2F2017%2F02%2F09%2Fandroid%E7%AC%94%E8%AE%B0-Android%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%2F</url>
      <content type="text"><![CDATA[android笔记-Android文件下载单线程下载效果展示： 主要过程：1.新建DownloadLinstener接口2.新建DoadloadTask继承AsycnTak3.新建DownloadService 继承service4.UI和Mainactivity实现 代码 DownloadLinstener接口实现* 1234567891011121314public interface DownloadListener &#123; void onProgress(int progress); void onSuccess(); void onFailed(); void onPaused(); void onCanceled();&#125; DownloadTask实现 * 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176package com.lvc.downloaddemo;import android.os.AsyncTask;import android.os.Environment;import java.io.File;import java.io.IOException;import java.io.InputStream;import java.io.RandomAccessFile;import okhttp3.OkHttpClient;import okhttp3.Request;import okhttp3.Response;/** * Created by lvc on 2017/2/9. */public class DownloadTask extends AsyncTask&lt;String ,Integer ,Integer&gt; &#123; // 下载常量 标识状态 public static final int TYPE_SUCCESS = 0; public static final int TYPE_FAILED = 1; public static final int TYPE_PAUSED = 2; public static final int TYPE_CANCELED = 3; private DownloadListener listener; private Boolean isPaused =false; private Boolean isCanceled = false; private int lastProgress; public DownloadTask(DownloadListener listener) &#123; this.listener = listener; &#125; // 后台执行的下载逻辑 @Override protected Integer doInBackground(String... params) &#123; InputStream in = null; RandomAccessFile savedFile = null; File file = null; try &#123; long downloadLength = 0; String downloadUrl = params[0]; String fileName = downloadUrl.substring(downloadUrl.lastIndexOf(&quot;/&quot;)); String directory = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS).getPath(); file = new File(directory+fileName); if (file.exists())&#123; downloadLength = file.length(); &#125; long contentLength = getContentLength(downloadUrl); if (contentLength == 0)&#123; return TYPE_FAILED; &#125;else if (contentLength == downloadLength)&#123; return TYPE_SUCCESS; &#125; OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder() //断点下载 .addHeader(&quot;RANGE&quot;, &quot;bytes=&quot; + downloadLength + &quot;-&quot;) .url(downloadUrl) .build(); Response response = client.newCall(request).execute(); if (response != null)&#123; in = response.body().byteStream(); savedFile = new RandomAccessFile(file,&quot;rw&quot;); savedFile.seek(downloadLength); byte[] b = new byte[1024]; int total =0; int len ; while ((len = in.read(b)) != -1)&#123; if (isCanceled)&#123; return TYPE_CANCELED; &#125; else if(isPaused)&#123; return TYPE_PAUSED; &#125; else&#123; total += len; savedFile.write(b,0,len); // 计算下载的百分比 int progress = (int)((total+downloadLength)*100 / contentLength); publishProgress(progress); &#125; &#125; response.body().close(); return TYPE_SUCCESS; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; if(in != null)&#123; try &#123; in.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; if(savedFile != null)&#123; try &#123; savedFile.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (isCanceled &amp;&amp; file != null)&#123; file.delete(); &#125; return TYPE_FAILED; &#125; // 更新 下载进度 @Override protected void onProgressUpdate(Integer... values) &#123; int progress = values[0]; if(progress &gt; lastProgress)&#123; listener.onProgress(progress); lastProgress = progress; &#125; &#125; //最终下载的结果 @Override protected void onPostExecute(Integer status) &#123; //super.onPostExecute(status); switch (status) &#123; case TYPE_SUCCESS: listener.onSuccess(); break; case TYPE_FAILED: listener.onFailed(); break; case TYPE_PAUSED: listener.onPaused(); break; case TYPE_CANCELED: listener.onCanceled(); default: break; &#125; &#125; private long getContentLength(String downloadUrl) throws IOException &#123; OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder() .url(downloadUrl) .build(); Response response = client.newCall(request).execute(); if (response != null &amp;&amp; response.isSuccessful())&#123; long contentlength = response.body().contentLength(); response.close(); return contentlength; &#125; return 0; &#125; public void pausedDownload()&#123; isPaused = true; &#125; public void canceledDownlod()&#123; isCanceled = true; &#125;&#125; DwonloadService实现* 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143package com.lvc.downloaddemo;import android.app.Notification;import android.app.NotificationManager;import android.app.PendingIntent;import android.app.Service;import android.content.Intent;import android.graphics.BitmapFactory;import android.os.Binder;import android.os.Environment;import android.os.IBinder;import android.support.v4.app.NotificationCompat;import android.util.Log;import android.widget.Toast;import java.io.File;public class DownloadService extends Service &#123; private DownloadTask downloadTask ; private String downloadUrl = null; int i = 0; private DownloadListener listener = new DownloadListener() &#123; @Override public void onProgress(int progress) &#123; getNotificationManager().notify(1,getNotification(&quot;正在下载...&quot;,progress)); &#125; @Override public void onSuccess() &#123; downloadTask = null; // 下载成功时将前台服务通知关闭，并创建一个下载成功的通知 stopForeground(true); getNotificationManager().notify(1, getNotification(&quot;Download Success&quot;, -1)); Toast.makeText(DownloadService.this, &quot;Download Success&quot;, Toast.LENGTH_SHORT).show(); &#125; @Override public void onFailed() &#123; downloadTask = null; // 下载失败时将前台服务通知关闭，并创建一个下载失败的通知 stopForeground(true); getNotificationManager().notify(1, getNotification(&quot;Download Failed&quot;, -1)); Toast.makeText(DownloadService.this, &quot;Download Failed&quot;, Toast.LENGTH_SHORT).show(); &#125; @Override public void onPaused() &#123; downloadTask = null; Toast.makeText(DownloadService.this, &quot;Paused&quot;, Toast.LENGTH_SHORT).show(); &#125; @Override public void onCanceled() &#123; downloadTask = null; stopForeground(true); Toast.makeText(DownloadService.this, &quot;Canceled&quot;, Toast.LENGTH_SHORT).show(); &#125; &#125; ; private DownloadBinder mBinder =new DownloadBinder(); /* public DownloadService() &#123; &#125;*/ @Override public IBinder onBind(Intent intent) &#123; return mBinder; &#125; class DownloadBinder extends Binder&#123; public void startDownload(String url)&#123; if(downloadUrl == null)&#123; downloadUrl =url; downloadTask = new DownloadTask(listener); downloadTask.execute(downloadUrl); startForeground(1,getNotification(&quot;正在下载...&quot;,0)); Log.i(&quot;判断点击次数&quot;, &quot;startDownload: &quot;+i); i++; Toast.makeText(DownloadService.this, &quot;正在下载...&quot;, Toast.LENGTH_SHORT).show(); &#125; &#125; public void pauseDownload()&#123; if(downloadTask !=null)&#123; downloadTask.pausedDownload(); &#125; &#125; public void cancelDownload()&#123; if(downloadTask != null)&#123; downloadTask.canceledDownlod(); &#125;else&#123; if(downloadUrl != null)&#123; //取消下载时需要将文件删除，并通知关闭 String fileName = downloadUrl.substring(downloadUrl.lastIndexOf(&quot;/&quot;)); String directory = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS).getPath(); File file = new File(directory + fileName); if(file.exists())&#123; file.delete(); &#125; getNotificationManager().cancel(1); stopForeground(true); Toast.makeText(DownloadService.this, &quot;Canceled&quot;, Toast.LENGTH_SHORT).show(); &#125; &#125; &#125; &#125; // 获取通知管理器 private NotificationManager getNotificationManager()&#123; return (NotificationManager) getSystemService(NOTIFICATION_SERVICE); &#125; //通知详情 private Notification getNotification(String title,int progress)&#123; // Intent intent = new Intent(this,MainActivity.class); // PendingIntent pi = PendingIntent.getActivities(this,0,new Intent[]&#123;intent&#125;,0); Intent intent = new Intent(this, MainActivity.class); PendingIntent pi = PendingIntent.getActivity(this, 0, intent, 0); NotificationCompat.Builder builder = new NotificationCompat.Builder(this); builder.setSmallIcon(R.mipmap.ic_launcher); builder.setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher)); builder.setContentIntent(pi); builder.setContentTitle(title); if(progress &gt;= 0)&#123; builder.setContentText(progress + &quot;%&quot;); builder.setProgress(100,progress,false); &#125; return builder.build(); &#125;&#125; Mainactivity实现 UI布局简单就不贴了* 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394package com.lvc.downloaddemo;import android.Manifest;import android.content.ComponentName;import android.content.Intent;import android.content.ServiceConnection;import android.content.pm.PackageManager;import android.os.IBinder;import android.support.annotation.NonNull;import android.support.v4.app.ActivityCompat;import android.support.v4.content.ContextCompat;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.Toast;public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; private DownloadService.DownloadBinder downloadBinder; private ServiceConnection connection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName componentName, IBinder iBinder) &#123; downloadBinder = (DownloadService.DownloadBinder) iBinder; &#125; @Override public void onServiceDisconnected(ComponentName componentName) &#123; &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button startDownload = (Button) findViewById(R.id.btn_start); Button pauseDownload = (Button) findViewById(R.id.btn_paused); Button cancelDownload = (Button) findViewById(R.id.btn_cancel); startDownload.setOnClickListener(this); pauseDownload.setOnClickListener(this); cancelDownload.setOnClickListener(this); Intent intent = new Intent(this,DownloadService.class); startService(intent); bindService(intent,connection,BIND_AUTO_CREATE); if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) &#123; ActivityCompat.requestPermissions(MainActivity.this, new String[]&#123; Manifest.permission. WRITE_EXTERNAL_STORAGE &#125;, 1); &#125; &#125; @Override public void onClick(View view) &#123; if (downloadBinder == null) &#123; return; &#125; switch (view.getId()) &#123; case R.id.btn_start: String url = &quot;http://www.runoob.com/wp-content/uploads/2015/09/DownLoadDemo1.zip&quot;; downloadBinder.startDownload(url); break; case R.id.btn_paused: downloadBinder.pauseDownload(); break; case R.id.btn_cancel: downloadBinder.cancelDownload(); break; default: break; &#125; &#125; @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; switch (requestCode) &#123; case 1: if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] != PackageManager.PERMISSION_GRANTED) &#123; Toast.makeText(this, &quot;拒绝权限将无法使用程序&quot;, Toast.LENGTH_SHORT).show(); finish(); &#125; break; default: &#125; &#125; @Override protected void onDestroy() &#123; super.onDestroy(); unbindService(connection); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[android笔记-HttpURLConnection]]></title>
      <url>%2F2017%2F02%2F07%2Fandroid%E7%AC%94%E8%AE%B0-HttpURLConnection%2F</url>
      <content type="text"><![CDATA[android笔记-HttpURLConnection报错 调用InputStream in = connection.getErrorStream(); 报错 主要代码 使用okhttp直接上代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788package com.lvc.nnetworktest.util;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.net.HttpURLConnection;import java.net.URL;import okhttp3.OkHttpClient;import okhttp3.Request;import okhttp3.Response;/** * Created by lvc on 2017/2/7. * 网络请求util * 封装了 httpURLConnection &amp; okhttp3 */public class HtppUtil &#123; public static void sendHttpRequest(final String address,final HttpCallbackListener listener)&#123; new Thread(new Runnable() &#123; @Override public void run() &#123; HttpURLConnection connection = null; //InputStream in =null; try &#123; URL url = new URL(address); connection = (HttpURLConnection) url.openConnection(); connection.setRequestMethod(&quot;GET&quot;); connection.setConnectTimeout(8000); connection.setReadTimeout(8000); connection.setDoInput(true); connection.setDoOutput(true); InputStream in = connection.getErrorStream(); BufferedReader reader = new BufferedReader(new InputStreamReader(in)); StringBuilder response = new StringBuilder(); String line; while((line =reader.readLine())!=null)&#123; response.append(line); &#125; if(listener != null)&#123; listener.onFinish(response.toString()); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); if(listener != null)&#123; listener.onError(e); &#125; &#125;finally &#123; if(connection != null)&#123; connection.disconnect(); &#125; /* if (in != null)&#123; try &#123; in.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;*/ &#125; &#125; &#125;).start(); &#125; public interface HttpCallbackListener&#123; void onFinish(String response); void onError(Exception e); &#125; /** * okhttp3 */ public static void sendOkhttpRequest(String address , okhttp3.Callback callback)&#123; OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder() .url(address) .build(); client.newCall(request).enqueue(callback); //调用回调 &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[闲言碎语-西游降魔篇]]></title>
      <url>%2F2017%2F02%2F06%2F%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD-%E8%A5%BF%E6%B8%B8%E9%99%8D%E9%AD%94%E7%AF%87%2F</url>
      <content type="text"><![CDATA[西游真的是那个西游吗许久不见，或许是一种情怀！可这又有什么关系呢？佛是什么？你又是什么？我又是什么？西游真的是西游吗？22部天竺真经真的能普度众生吗？度的人，应该是他自己吧。 一生所爱 是被用坏了的情怀吗？终究你我将不复存在关于执念你我懂多少不同的人有不同世界一生真的能爱个够吗陈先生历经千辛万苦只寻普度众生的良药可是大爱小爱说不清道不明在制服猪刚鬣的之时孙先生出了一个法子在月圆之夜，绝山之巅段小姐翩然起舞，宛若谪仙，人间不应有一生所爱的歌声，纵然是情怀作祟。 我的西游我希望寻找自己的西游之路，不为普度众生只为度我自己。西游终究是被烙印在骨子里，流淌的血液在轰轰的燃烧着，可是红尘真的有 真 善 美 ？愿意相信的谎言，我愿意，那就有。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[android笔记-调用摄像头相册]]></title>
      <url>%2F2017%2F02%2F06%2Fandroid%E7%AC%94%E8%AE%B0-%E8%B0%83%E7%94%A8%E6%91%84%E5%83%8F%E5%A4%B4%E7%9B%B8%E5%86%8C%2F</url>
      <content type="text"><![CDATA[调用摄像头调用摄像头拍照获取图片 Demo：效果展示 重要代码123456789101112131415161718192021//创建File 对象，用于存储拍照后的图片File outputImage = new File(getExternalCacheDir(),&quot;output_image.jsp&quot;);try &#123; if(outputImage.exists())&#123; outputImage.delete(); &#125; outputImage.createNewFile();&#125;catch (IOException e)&#123; e.printStackTrace();&#125;if(Build.VERSION.SDK_INT&gt;=24)&#123; imageUri = FileProvider.getUriForFile(MainActivity.this,&quot;com.example.cramea.fileprovider&quot;, outputImage);&#125;else&#123; imageUri = Uri.fromFile(outputImage);&#125;//启动相机程序Intent intent = new Intent(&quot;android.media.action.IMAGE_CAPTURE&quot;);intent.putExtra(MediaStore.EXTRA_OUTPUT,imageUri);startActivityForResult(intent,TAKE_PHOTO); 从相册中选择图片全部代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208package com.lvc.cameraalbumtest;import android.Manifest;import android.annotation.TargetApi;import android.app.Activity;import android.content.ContentUris;import android.content.Intent;import android.content.pm.PackageManager;import android.database.Cursor;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.net.Uri;import android.os.Build;import android.provider.DocumentsContract;import android.provider.MediaStore;import android.support.annotation.NonNull;import android.support.v4.app.ActivityCompat;import android.support.v4.content.ContextCompat;import android.support.v4.content.FileProvider;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.ImageView;import android.widget.Toast;import java.io.File;import java.io.FileNotFoundException;import java.io.IOException;public class MainActivity extends AppCompatActivity &#123; public static final int TAKE_PHOTO = 1; public static final int CHOOSE_PHOTO = 2; private Button takephoto ; private Button choosephoto ; private ImageView pictrue ; private Uri imageUri ; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); /** * 1.获取实例 * 2.绑定监听事件 * */ takephoto = (Button) findViewById(R.id.take_photo); choosephoto = (Button) findViewById(R.id.choose_from_album); pictrue = (ImageView) findViewById(R.id.picture); takephoto.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; //创建File 对象，用于存储拍照后的图片 File outputImage = new File(getExternalCacheDir(),&quot;output_image.jsp&quot;); try &#123; if(outputImage.exists())&#123; outputImage.delete(); &#125; outputImage.createNewFile(); &#125;catch (IOException e)&#123; e.printStackTrace(); &#125; if(Build.VERSION.SDK_INT&gt;=24)&#123; imageUri = FileProvider.getUriForFile(MainActivity.this,&quot;com.example.cramea.fileprovider&quot;, outputImage); &#125;else&#123; imageUri = Uri.fromFile(outputImage); &#125; //启动相机程序 Intent intent = new Intent(&quot;android.media.action.IMAGE_CAPTURE&quot;); intent.putExtra(MediaStore.EXTRA_OUTPUT,imageUri); startActivityForResult(intent,TAKE_PHOTO); &#125; &#125;); choosephoto.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; if(ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED)&#123; ActivityCompat.requestPermissions(MainActivity.this,new String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;,1); &#125;else&#123; openAlbum(); &#125; &#125; &#125;); &#125; /** * */ private void openAlbum()&#123; Intent intent =new Intent(&quot;android.intent.action.GET_CONTENT&quot;); intent.setType(&quot;image/*&quot;); startActivityForResult(intent,CHOOSE_PHOTO); &#125; @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; // super.onActivityResult(requestCode, resultCode, data); switch (requestCode)&#123; case TAKE_PHOTO: try &#123; Bitmap bitmap = BitmapFactory.decodeStream(getContentResolver() .openInputStream(imageUri)); pictrue.setImageBitmap(bitmap); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; break; case CHOOSE_PHOTO: if(resultCode == RESULT_OK )&#123; //判断手机系统版本号 if(Build.VERSION.SDK_INT&gt;=19)&#123; //4.4及以上版本使用这个方法处理图片 handleImageOnKiKat(data); &#125;else&#123; //4.4以下版本使用这个方法处理图片 handleImageBeforeKiKat(data); &#125; &#125; break; default: break; &#125; &#125; private void handleImageBeforeKiKat(Intent data) &#123; Uri uri = data.getData(); String imagepath = getImagePath(uri,null); displayImage(imagepath); &#125; @TargetApi(19) private void handleImageOnKiKat(Intent data) &#123; String imagePath= null; Uri uri = data.getData(); if(DocumentsContract.isDocumentUri(this,uri))&#123; String docId = DocumentsContract.getDocumentId(uri); if(&quot;com.android.providers.media.documents&quot;.equals(uri.getAuthority()))&#123; String id = docId.split(&quot;:&quot;)[1]; String selection = MediaStore.Images.Media._ID+&quot;=&quot;+id; imagePath = getImagePath(MediaStore.Images.Media.EXTERNAL_CONTENT_URI,selection); &#125;else if(&quot;com.android.providers.downloads.documents&quot;.equals(uri.getAuthority()))&#123; Uri contentUri = ContentUris.withAppendedId(Uri.parse(&quot;content://downloads/public_downloads&quot;),Long.valueOf(docId)); imagePath = getImagePath(contentUri,null); &#125; &#125;else if(&quot;content&quot;.equalsIgnoreCase(uri.getScheme()))&#123; imagePath = getImagePath(uri,null); &#125;else if(&quot;file&quot;.equalsIgnoreCase(uri.getScheme()))&#123; imagePath = uri.getPath(); &#125; displayImage(imagePath); &#125; @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; //super.onRequestPermissionsResult(requestCode, permissions, grantResults); switch (requestCode)&#123; case 1: if(grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED )&#123; openAlbum(); &#125;else&#123; Toast.makeText(this,&quot;you denied the permisson&quot;,Toast.LENGTH_SHORT).show(); // openAlbum(); &#125; break; default: break; &#125; &#125; private String getImagePath(Uri uri,String selection)&#123; String path =null; //通过Uri和 selection 来获取真实的图片路径 Cursor cursor = getContentResolver().query(uri,null,selection,null,null); if(cursor != null)&#123; if (cursor.moveToNext())&#123; path = cursor.getString(cursor.getColumnIndex(MediaStore.Images.Media.DATA)); &#125; cursor.close(); &#125; return path; &#125; private void displayImage(String imagePath)&#123; if (imagePath !=null)&#123; Bitmap bitmap = BitmapFactory.decodeFile(imagePath); pictrue.setImageBitmap(bitmap); &#125;else&#123; Toast.makeText(this,&quot;Failed to get image&quot;,Toast.LENGTH_SHORT).show(); &#125; &#125;&#125; 总结 博客真难写想做个记录发现不知道怎么去记汗颜啊]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[android笔记-使用通知]]></title>
      <url>%2F2017%2F02%2F05%2Fandroid%E7%AC%94%E8%AE%B0-%E4%BD%BF%E7%94%A8%E9%80%9A%E7%9F%A5%2F</url>
      <content type="text"><![CDATA[Android笔记-使用通知通知的基本用法 代码 123456789NotificationManager notificationManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE); Notification notification = new NotificationCompat.Builder(this) .setContentTitle(&quot;通知&quot;) .setContentText(&quot;这是一个通知！&quot;) .setWhen(System.currentTimeMillis()) .setSmallIcon(R.mipmap.ic_launcher) .setLargeIcon(BitmapFactory.decodeResource(getResources(),R.mipmap.ic_launcher)) .build(); notificationManager.notify(1,notification); PendingIntent可以简单的理解为延迟执行的Intent pendingIntent 用法1.获取PendingIntent实例： getActivity() getBroadcast() getService() &gt; 以上方法参数相同： * 1 context * 2 0 通常传入0 * 3 Intent对象 * 4 用于确定PendingIntent的行为 有4个值：FLAG_ONE_SHOT FLAG_ON_CREATE FLAG_CANEL_CURRENT FLAG_UPDATE_CURRENT 给通知添加响应 代码12345678910111213Intent intent = new Intent(this,NotificationActivity.class); Intent[] intents = &#123;intent&#125;; PendingIntent pi = PendingIntent.getActivities(this,0,intents,0); NotificationManager notificationManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE); Notification notification = new NotificationCompat.Builder(this) .setContentTitle(&quot;通知&quot;) .setContentText(&quot;这是一个通知！&quot;) .setWhen(System.currentTimeMillis()) .setSmallIcon(R.mipmap.ic_launcher) .setLargeIcon(BitmapFactory.decodeResource(getResources(),R.mipmap.ic_launcher)) .setContentIntent(pi) .build(); notificationManager.notify(1,notification); 取消通知栏上的通知`.setAutoCancel(true)` 在响应的Activity中 添加 1.NotificationManager notificationManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE); 2.notificationManager.cancel(1);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[我的第一篇博客]]></title>
      <url>%2F2017%2F02%2F03%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
      <content type="text"><![CDATA[没有正式文章，仅作为当前内容的测试！ 做个简单的小结昨天在慕课网手记中看到 hexo + github pages 搭建个人博客 经过长时间的学习，再一次觉得开源的伟大! 用了不到一天的时间，杂七杂八的也就成这个样子了 实践才是检验真理的唯一标准 坚持每天学点东西吧。这也算还了我一个小愿望！2017 任重而道远! 下一步，开发一个APP！ ——Lvc]]></content>
    </entry>

    
  
  
</search>
